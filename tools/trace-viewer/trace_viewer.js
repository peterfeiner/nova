/**
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

* WARNING: This file is generated by generate_standalone_timeline_view.py
*
*        Do not edit directly.
*/

window.FLATTENED = {};
window.FLATTENED['base'] = true;
window.FLATTENED['event_target'] = true;
window.FLATTENED['measuring_stick'] = true;
window.FLATTENED['filter'] = true;
window.FLATTENED['range'] = true;
window.FLATTENED['selection'] = true;
window.FLATTENED['timeline_viewport'] = true;
window.FLATTENED['ui'] = true;
window.FLATTENED['tracks.track'] = true;
window.FLATTENED['tracks.container_track'] = true;
window.FLATTENED['fast_rect_renderer'] = true;
window.FLATTENED['color_scheme'] = true;
window.FLATTENED['tracks.canvas_based_track'] = true;
window.FLATTENED['sorted_array_utils'] = true;
window.FLATTENED['tracks.slice_track'] = true;
window.FLATTENED['guid'] = true;
window.FLATTENED['model.slice'] = true;
window.FLATTENED['model.slice_group'] = true;
window.FLATTENED['model.async_slice_group'] = true;
window.FLATTENED['model.sample'] = true;
window.FLATTENED['model.thread'] = true;
window.FLATTENED['model.counter'] = true;
window.FLATTENED['model.process_base'] = true;
window.FLATTENED['model.process'] = true;
window.FLATTENED['model.kernel'] = true;
window.FLATTENED['model.cpu'] = true;
window.FLATTENED['model'] = true;
window.FLATTENED['tracks.cpu_track'] = true;
window.FLATTENED['tracks.counter_track'] = true;
window.FLATTENED['tracks.slice_group_track'] = true;
window.FLATTENED['tracks.async_slice_group_track'] = true;
window.FLATTENED['tracks.thread_track'] = true;
window.FLATTENED['tracks.process_track'] = true;
window.FLATTENED['tracks.model_track'] = true;
window.FLATTENED['tracks.ruler_track'] = true;
window.FLATTENED['timeline_track_view'] = true;
window.FLATTENED['analysis.util'] = true;
window.FLATTENED['timeline_analysis_view'] = true;
window.FLATTENED['overlay'] = true;
window.FLATTENED['category_filter_dialog'] = true;
window.FLATTENED['find_control'] = true;
window.FLATTENED['importer.trace_event_importer'] = true;
window.FLATTENED['importer.linux_perf.parser'] = true;
window.FLATTENED['importer.linux_perf.bus_parser'] = true;
window.FLATTENED['importer.linux_perf.clock_parser'] = true;
window.FLATTENED['importer.linux_perf.cpufreq_parser'] = true;
window.FLATTENED['importer.linux_perf.disk_parser'] = true;
window.FLATTENED['importer.linux_perf.drm_parser'] = true;
window.FLATTENED['importer.linux_perf.exynos_parser'] = true;
window.FLATTENED['importer.linux_perf.gesture_parser'] = true;
window.FLATTENED['importer.linux_perf.i915_parser'] = true;
window.FLATTENED['importer.linux_perf.mali_parser'] = true;
window.FLATTENED['importer.linux_perf.power_parser'] = true;
window.FLATTENED['importer.linux_perf.sched_parser'] = true;
window.FLATTENED['importer.linux_perf.workqueue_parser'] = true;
window.FLATTENED['importer.linux_perf.android_parser'] = true;
window.FLATTENED['importer.linux_perf_importer'] = true;
window.FLATTENED['importer.v8.log_reader'] = true;
window.FLATTENED['importer.v8.splaytree'] = true;
window.FLATTENED['importer.v8.codemap'] = true;
window.FLATTENED['importer.v8_log_importer'] = true;
window.FLATTENED['settings'] = true;
window.FLATTENED['timeline_view'] = true;
// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';


/**
 * The global object.
 * @type {!Object}
 * @const
 */
var global = this;


/** Platform, package, object property, and Event support. */
this.base = (function() {

  /**
   * Base path for modules. Used to form URLs for module 'require' requests.
   */
  var moduleBasePath = '.';
  function setModuleBasePath(path) {
    if (path[path.length - 1] == '/')
      path = path.substring(0, path.length - 1);
    moduleBasePath = path;
  }


  function mLog(text, opt_indentLevel) {
    if (true)
      return;

    var spacing = '';
    var indentLevel = opt_indentLevel || 0;
    for (var i = 0; i < indentLevel; i++)
      spacing += ' ';
    console.log(spacing + text);
  }

  /**
   * Builds an object structure for the provided namespace path,
   * ensuring that names that already exist are not overwritten. For
   * example:
   * 'a.b.c' -> a = {};a.b={};a.b.c={};
   * @param {string} name Name of the object that this file defines.
   * @param {*=} opt_object The object to expose at the end of the path.
   * @param {Object=} opt_objectToExportTo The object to add the path to;
   *     default is {@code global}.
   * @private
   */
  function exportPath(name, opt_object, opt_objectToExportTo) {
    var parts = name.split('.');
    var cur = opt_objectToExportTo || global;

    for (var part; parts.length && (part = parts.shift());) {
      if (!parts.length && opt_object !== undefined) {
        // last part and we have an object; use it
        cur[part] = opt_object;
      } else if (part in cur) {
        cur = cur[part];
      } else {
        cur = cur[part] = {};
      }
    }
    return cur;
  };

  var didLoadModules = false;
  var moduleDependencies = {};
  var moduleStylesheets = {};
  var moduleRawScripts = {};

  function addModuleDependency(moduleName, dependentModuleName) {
    if (!moduleDependencies[moduleName])
      moduleDependencies[moduleName] = [];

    var dependentModules = moduleDependencies[moduleName];
    var found = false;
    for (var i = 0; i < dependentModules.length; i++)
      if (dependentModules[i] == dependentModuleName)
        found = true;
    if (!found)
      dependentModules.push(dependentModuleName);
  }

  function addModuleRawScriptDependency(moduleName, rawScriptName) {
    if (!moduleRawScripts[moduleName])
      moduleRawScripts[moduleName] = [];

    var dependentRawScripts = moduleRawScripts[moduleName];
    var found = false;
    for (var i = 0; i < moduleRawScripts.length; i++)
      if (dependentRawScripts[i] == rawScriptName)
        found = true;
    if (!found)
      dependentRawScripts.push(rawScriptName);
  }

  function addModuleStylesheet(moduleName, stylesheetName) {
    if (!moduleStylesheets[moduleName])
      moduleStylesheets[moduleName] = [];

    var stylesheets = moduleStylesheets[moduleName];
    var found = false;
    for (var i = 0; i < stylesheets.length; i++)
      if (stylesheets[i] == stylesheetName)
        found = true;
      if (!found)
        stylesheets.push(stylesheetName);
  }

  function ensureDepsLoaded() {
    if (didLoadModules)
      return;
    didLoadModules = true;

    var req = new XMLHttpRequest();
    var src = moduleBasePath + '/' + 'deps.js';
    req.open('GET', src, false);
    req.send(null);
    if (req.status != 200)
      throw new Error('Could not find ' + src +
                      '. Run calcdeps.py and try again.');

    base.addModuleDependency = addModuleDependency;
    base.addModuleRawScriptDependency = addModuleRawScriptDependency;
    base.addModuleStylesheet = addModuleStylesheet;
    try {
      // By construction, the deps file should call addModuleDependency.
      eval(req.responseText);
    } catch (e) {
      throw new Error('When loading deps, got ' + e.stack ? e.stack : e);
    }
    delete base.addModuleStylesheet;
    delete base.addModuleRawScriptDependency;
    delete base.addModuleDependency;

  }

  var moduleLoadStatus = {};
  var rawScriptLoadStatus = {};
  function require(dependentModuleName, opt_indentLevel) {
    var indentLevel = opt_indentLevel || 0;

    if (window.FLATTENED) {
      if (!window.FLATTENED[dependentModuleName]) {
        throw new Error('Somehow, module ' + dependentModuleName +
                        ' didn\'t get stored in the flattened js file! ' +
                        'You may need to rerun build/calcdeps.py');
      }
      return;
    }
    ensureDepsLoaded();

    mLog('require(' + dependentModuleName + ')', indentLevel);

    if (moduleLoadStatus[dependentModuleName] == 'APPENDED')
      return;
    if (moduleLoadStatus[dependentModuleName] == 'RESOLVING')
      throw new Error('Circular dependency betwen modules. Cannot continue!');
    moduleLoadStatus[dependentModuleName] = 'RESOLVING';

    // Load the module stylesheet first.
    var stylesheets = moduleStylesheets[dependentModuleName] || [];
    for (var i = 0; i < stylesheets.length; i++)
      requireStylesheet(stylesheets[i]);

    // Load the module raw scripts next
    var rawScripts = moduleRawScripts[dependentModuleName] || [];
    for (var i = 0; i < rawScripts.length; i++) {
      var rawScriptName = rawScripts[i];
      if (rawScriptLoadStatus[rawScriptName])
        continue;

      mLog('load(' + rawScriptName + ')', indentLevel);
      var src = moduleBasePath + '/' + rawScriptName;
      var text = '<script type="text/javascript" src="' + src +
        '"></' + 'script>';
      base.doc.write(text);
      rawScriptLoadStatus[rawScriptName] = 'APPENDED';
    }

    // Load the module's dependent scripts after.
    var dependentModules =
        moduleDependencies[dependentModuleName] || [];
    for (var i = 0; i < dependentModules.length; i++)
      require(dependentModules[i], indentLevel + 1);

    mLog('load(' + dependentModuleName + ')', indentLevel);
    // Load the module itself.
    var localPath = dependentModuleName.replace(/\./g, '/') + '.js';
    var src = moduleBasePath + '/' + localPath;
    var text = '<script type="text/javascript" src="' + src +
        '"></' + 'script>';
    base.doc.write(text);
    moduleLoadStatus[dependentModuleName] = 'APPENDED';
  }

  /**
   * Adds a dependency on a raw javascript file, e.g. a third party
   * library.
   * @param {String} rawScriptName The path to the script file, relative to
   * moduleBasePath.
   */
  function requireRawScript(rawScriptPath) {
    if (window.FLATTENED_RAW_SCRIPTS) {
      if (!window.FLATTENED_RAW_SCRIPTS[rawScriptPath]) {
        throw new Error('Somehow, ' + rawScriptPath +
                        ' didn\'t get stored in the flattened js file! ' +
                        'You may need to rerun build/calcdeps.py');
      }
      return;
    }

    if (rawScriptLoadStatus[rawScriptPath])
      return;
    throw new Error(rawScriptPath + ' should already have been loaded.' +
                    ' Did you forget to run calcdeps.py?');
  }

  var stylesheetLoadStatus = {};
  function requireStylesheet(dependentStylesheetName) {
    if (window.FLATTENED)
      return;

    if (stylesheetLoadStatus[dependentStylesheetName])
      return;
    stylesheetLoadStatus[dependentStylesheetName] = true;
    var localPath = dependentStylesheetName.replace(/\./g, '/') + '.css';
    var stylesheetPath = moduleBasePath + '/' + localPath;

    var linkEl = document.createElement('link');
    linkEl.setAttribute('rel', 'stylesheet');
    linkEl.setAttribute('href', stylesheetPath);
    base.doc.head.appendChild(linkEl);
  }

  function exportTo(namespace, fn) {
    var obj = exportPath(namespace);
    try {
      var exports = fn();
    } catch (e) {
      console.log('While running exports for ', name, ':');
      console.log(e.stack || e);
      return;
    }

    for (var propertyName in exports) {
      // Maybe we should check the prototype chain here? The current usage
      // pattern is always using an object literal so we only care about own
      // properties.
      var propertyDescriptor = Object.getOwnPropertyDescriptor(exports,
                                                               propertyName);
      if (propertyDescriptor) {
        Object.defineProperty(obj, propertyName, propertyDescriptor);
        mLog('  +' + propertyName);
      }
    }
  };

  /**
   * Fires a property change event on the target.
   * @param {EventTarget} target The target to dispatch the event on.
   * @param {string} propertyName The name of the property that changed.
   * @param {*} newValue The new value for the property.
   * @param {*} oldValue The old value for the property.
   */
  function dispatchPropertyChange(target, propertyName, newValue, oldValue) {
    var e = new base.Event(propertyName + 'Change');
    e.propertyName = propertyName;
    e.newValue = newValue;
    e.oldValue = oldValue;
    target.dispatchEvent(e);
  }

  /**
   * Converts a camelCase javascript property name to a hyphenated-lower-case
   * attribute name.
   * @param {string} jsName The javascript camelCase property name.
   * @return {string} The equivalent hyphenated-lower-case attribute name.
   */
  function getAttributeName(jsName) {
    return jsName.replace(/([A-Z])/g, '-$1').toLowerCase();
  }

  /**
   * The kind of property to define in {@code defineProperty}.
   * @enum {number}
   * @const
   */
  var PropertyKind = {
    /**
     * Plain old JS property where the backing data is stored as a 'private'
     * field on the object.
     */
    JS: 'js',

    /**
     * The property backing data is stored as an attribute on an element.
     */
    ATTR: 'attr',

    /**
     * The property backing data is stored as an attribute on an element. If the
     * element has the attribute then the value is true.
     */
    BOOL_ATTR: 'boolAttr'
  };

  /**
   * Helper function for defineProperty that returns the getter to use for the
   * property.
   * @param {string} name The name of the property.
   * @param {base.PropertyKind} kind The kind of the property.
   * @return {function():*} The getter for the property.
   */
  function getGetter(name, kind) {
    switch (kind) {
      case PropertyKind.JS:
        var privateName = name + '_';
        return function() {
          return this[privateName];
        };
      case PropertyKind.ATTR:
        var attributeName = getAttributeName(name);
        return function() {
          return this.getAttribute(attributeName);
        };
      case PropertyKind.BOOL_ATTR:
        var attributeName = getAttributeName(name);
        return function() {
          return this.hasAttribute(attributeName);
        };
    }
  }

  /**
   * Helper function for defineProperty that returns the setter of the right
   * kind.
   * @param {string} name The name of the property we are defining the setter
   *     for.
   * @param {base.PropertyKind} kind The kind of property we are getting the
   *     setter for.
   * @param {function(*):void} opt_setHook A function to run after the property
   *     is set, but before the propertyChange event is fired.
   * @return {function(*):void} The function to use as a setter.
   */
  function getSetter(name, kind, opt_setHook) {
    switch (kind) {
      case PropertyKind.JS:
        var privateName = name + '_';
        return function(value) {
          var oldValue = this[privateName];
          if (value !== oldValue) {
            this[privateName] = value;
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };

      case PropertyKind.ATTR:
        var attributeName = getAttributeName(name);
        return function(value) {
          var oldValue = this[attributeName];
          if (value !== oldValue) {
            if (value == undefined)
              this.removeAttribute(attributeName);
            else
              this.setAttribute(attributeName, value);
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };

      case PropertyKind.BOOL_ATTR:
        var attributeName = getAttributeName(name);
        return function(value) {
          var oldValue = this[attributeName];
          if (value !== oldValue) {
            if (value)
              this.setAttribute(attributeName, name);
            else
              this.removeAttribute(attributeName);
            if (opt_setHook)
              opt_setHook.call(this, value, oldValue);
            dispatchPropertyChange(this, name, value, oldValue);
          }
        };
    }
  }

  /**
   * Defines a property on an object. When the setter changes the value a
   * property change event with the type {@code name + 'Change'} is fired.
   * @param {!Object} obj The object to define the property for.
   * @param {string} name The name of the property.
   * @param {base.PropertyKind=} opt_kind What kind of underlying storage to
   * use.
   * @param {function(*):void} opt_setHook A function to run after the
   *     property is set, but before the propertyChange event is fired.
   */
  function defineProperty(obj, name, opt_kind, opt_setHook) {
    if (typeof obj == 'function')
      obj = obj.prototype;

    var kind = opt_kind || PropertyKind.JS;

    if (!obj.__lookupGetter__(name))
      obj.__defineGetter__(name, getGetter(name, kind));

    if (!obj.__lookupSetter__(name))
      obj.__defineSetter__(name, getSetter(name, kind, opt_setHook));
  }

  /**
   * Counter for use with createUid
   */
  var uidCounter = 1;

  /**
   * @return {number} A new unique ID.
   */
  function createUid() {
    return uidCounter++;
  }

  /**
   * Returns a unique ID for the item. This mutates the item so it needs to be
   * an object
   * @param {!Object} item The item to get the unique ID for.
   * @return {number} The unique ID for the item.
   */
  function getUid(item) {
    if (item.hasOwnProperty('uid'))
      return item.uid;
    return item.uid = createUid();
  }

  /**
   * Dispatches a simple event on an event target.
   * @param {!EventTarget} target The event target to dispatch the event on.
   * @param {string} type The type of the event.
   * @param {boolean=} opt_bubbles Whether the event bubbles or not.
   * @param {boolean=} opt_cancelable Whether the default action of the event
   *     can be prevented.
   * @return {boolean} If any of the listeners called {@code preventDefault}
   *     during the dispatch this will return false.
   */
  function dispatchSimpleEvent(target, type, opt_bubbles, opt_cancelable) {
    var e = new base.Event(type, opt_bubbles, opt_cancelable);
    return target.dispatchEvent(e);
  }

  /**
   * Adds a {@code getInstance} static method that always return the same
   * instance object.
   * @param {!Function} ctor The constructor for the class to add the static
   *     method to.
   */
  function addSingletonGetter(ctor) {
    ctor.getInstance = function() {
      return ctor.instance_ || (ctor.instance_ = new ctor());
    };
  }

  /**
   * Creates a new event to be used with base.EventTarget or DOM EventTarget
   * objects.
   * @param {string} type The name of the event.
   * @param {boolean=} opt_bubbles Whether the event bubbles.
   *     Default is false.
   * @param {boolean=} opt_preventable Whether the default action of the event
   *     can be prevented.
   * @constructor
   * @extends {Event}
   */
  function Event(type, opt_bubbles, opt_preventable) {
    var e = base.doc.createEvent('Event');
    e.initEvent(type, !!opt_bubbles, !!opt_preventable);
    e.__proto__ = global.Event.prototype;
    return e;
  };

  /**
   * Initialization which must be deferred until run-time.
   */
  function initialize() {
    // If 'document' isn't defined, then we must be being pre-compiled,
    // so set a trap so that we're initialized on first access at run-time.
    if (!global.document) {
      var originalCr = cr;

      Object.defineProperty(global, 'cr', {
        get: function() {
          Object.defineProperty(global, 'cr', {value: originalCr});
          originalBase.initialize();
          return originalCr;
        },
        configurable: true
      });

      return;
    }

    Event.prototype = {__proto__: global.Event.prototype};

    base.doc = document;

    base.isMac = /Mac/.test(navigator.platform);
    base.isWindows = /Win/.test(navigator.platform);
    base.isChromeOS = /CrOS/.test(navigator.userAgent);
    base.isLinux = /Linux/.test(navigator.userAgent);
    base.isGTK = /GTK/.test(chrome.toolkit);
    base.isViews = /views/.test(chrome.toolkit);

    setModuleBasePath('/src');
  }

  function asArray(arrayish) {
    var values = [];
    for (var i = 0; i < arrayish.length; i++)
      values.push(arrayish[i]);
    return values;
  }

  function concatenateArrays(/*arguments*/) {
    var values = [];
    for (var i = 0; i < arguments.length; i++) {
      if(!(arguments[i] instanceof Array))
        throw new Error('Arguments ' + i + 'is not an array');
      values.push.apply(values, arguments[i]);
    }
    return values;
  }

  function dictionaryKeys(dict) {
    var keys = [];
    for (var key in dict)
      keys.push(key);
    return keys;
  }

  function dictionaryValues(dict) {
    var values = [];
    for (var key in dict)
      values.push(dict[key]);
    return values;
  }

  /**
   * Maps types to a given value.
   * @constructor
   */
  function TypeMap() {
    this.types = [];
    this.values = [];
  }
  TypeMap.prototype = {
    __proto__: Object.prototype,

    add: function(type, value) {
      this.types.push(type);
      this.values.push(value);
    },

    get: function(instance) {
      for (var i = 0; i < this.types.length; i++) {
        if (instance instanceof this.types[i])
          return this.values[i];
      }
      return undefined;
    }
  };

  return {
    set moduleBasePath(path) {
      setModuleBasePath(path);
    },

    get moduleBasePath() {
      return moduleBasePath;
    },

    require: require,
    requireStylesheet: requireStylesheet,
    requireRawScript: requireRawScript,
    exportTo: exportTo,

    addSingletonGetter: addSingletonGetter,
    createUid: createUid,
    defineProperty: defineProperty,
    dispatchPropertyChange: dispatchPropertyChange,
    dispatchSimpleEvent: dispatchSimpleEvent,
    Event: Event,
    getUid: getUid,
    initialize: initialize,
    PropertyKind: PropertyKind,
    asArray: asArray,
    concatenateArrays: concatenateArrays,
    dictionaryKeys: dictionaryKeys,
    dictionaryValues: dictionaryValues,
    TypeMap: TypeMap,
  };
})();


/**
 * TODO(kgr): Move this to another file which is to be loaded last.
 * This will be done as part of future work to make this code pre-compilable.
 */
base.initialize();

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview This contains an implementation of the EventTarget interface
 * as defined by DOM Level 2 Events.
 */
base.exportTo('base', function() {

  /**
   * Creates a new EventTarget. This class implements the DOM level 2
   * EventTarget interface and can be used wherever those are used.
   * @constructor
   */
  function EventTarget() {
  }

  EventTarget.prototype = {

    /**
     * Adds an event listener to the target.
     * @param {string} type The name of the event.
     * @param {!Function|{handleEvent:Function}} handler The handler for the
     *     event. This is called when the event is dispatched.
     */
    addEventListener: function(type, handler) {
      if (!this.listeners_)
        this.listeners_ = Object.create(null);
      if (!(type in this.listeners_)) {
        this.listeners_[type] = [handler];
      } else {
        var handlers = this.listeners_[type];
        if (handlers.indexOf(handler) < 0)
          handlers.push(handler);
      }
    },

    /**
     * Removes an event listener from the target.
     * @param {string} type The name of the event.
     * @param {!Function|{handleEvent:Function}} handler The handler for the
     *     event.
     */
    removeEventListener: function(type, handler) {
      if (!this.listeners_)
        return;
      if (type in this.listeners_) {
        var handlers = this.listeners_[type];
        var index = handlers.indexOf(handler);
        if (index >= 0) {
          // Clean up if this was the last listener.
          if (handlers.length == 1)
            delete this.listeners_[type];
          else
            handlers.splice(index, 1);
        }
      }
    },

    /**
     * Dispatches an event and calls all the listeners that are listening to
     * the type of the event.
     * @param {!cr.event.Event} event The event to dispatch.
     * @return {boolean} Whether the default action was prevented. If someone
     *     calls preventDefault on the event object then this returns false.
     */
    dispatchEvent: function(event) {
      if (!this.listeners_)
        return true;

      // Since we are using DOM Event objects we need to override some of the
      // properties and methods so that we can emulate this correctly.
      var self = this;
      event.__defineGetter__('target', function() {
        return self;
      });
      event.preventDefault = function() {
        this.returnValue = false;
      };

      var type = event.type;
      var prevented = 0;
      if (type in this.listeners_) {
        // Clone to prevent removal during dispatch
        var handlers = this.listeners_[type].concat();
        for (var i = 0, handler; handler = handlers[i]; i++) {
          if (handler.handleEvent)
            prevented |= handler.handleEvent.call(handler, event) === false;
          else
            prevented |= handler.call(this, event) === false;
        }
      }

      return !prevented && event.returnValue;
    }
  };

  // Export
  return {
    EventTarget: EventTarget
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

base.exportTo('tracing', function() {

  /**
   * Uses an embedded iframe to measure provided elements without forcing layout
   * on the main document. You must call attach() on the stick before using it,
   * and call detach() on it when you are done using it.
   * @constructor
   * @extends {Object}
   */
  function MeasuringStick() {
    this.iframe_ = undefined;
  }

  MeasuringStick.prototype = {
    __proto__: Object.prototype,

    /**
     * Measures the provided element without forcing layout on the main
     * document.
     */
    measure: function(element) {
      this.iframe_.contentDocument.body.appendChild(element);
      var style = this.iframe_.contentWindow.getComputedStyle(element);
      var width = parseInt(style.width, 10);
      var height = parseInt(style.height, 10);
      this.iframe_.contentDocument.body.removeChild(element);
      return { width: width, height: height };
    },

    attach: function() {
      var iframe = document.createElement('iframe');
      iframe.style.cssText =
          'width:100%;height:0;border:0;visibility:hidden';
      document.body.appendChild(iframe);
      this.iframe_ = iframe;
      this.iframe_.contentDocument.body.style.cssText =
          'padding:0;margin:0;overflow:hidden';

      var stylesheets = document.querySelectorAll('link[rel=stylesheet]');
      for (var i = 0; i < stylesheets.length; i++) {
        var stylesheet = stylesheets[i];
        var link = this.iframe_.contentDocument.createElement('link');
        link.rel = 'stylesheet';
        link.href = stylesheet.href;
        this.iframe_.contentDocument.head.appendChild(link);
      }
    },

    detach: function() {
      document.body.removeChild(this.iframe_);
      this.iframe_ = undefined;
    }
  };

  return {
    MeasuringStick: MeasuringStick
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Model is a parsed representation of the
 * TraceEvents obtained from base/trace_event in which the begin-end
 * tokens are converted into a hierarchy of processes, threads,
 * subrows, and slices.
 *
 * The building block of the model is a slice. A slice is roughly
 * equivalent to function call executing on a specific thread. As a
 * result, slices may have one or more subslices.
 *
 * A thread contains one or more subrows of slices. Row 0 corresponds to
 * the "root" slices, e.g. the topmost slices. Row 1 contains slices that
 * are nested 1 deep in the stack, and so on. We use these subrows to draw
 * nesting tasks.
 *
 */
base.exportTo('tracing', function() {

  function filterSliceArray(filter, slices) {
    if (filter === undefined)
      return slices;

    var matched = [];
    for (var i = 0; i < slices.length; ++i) {
      if (filter.matchSlice(slices[i]))
        matched.push(slices[i]);
    }
    return matched;
  }

  function filterCounterArray(filter, counters) {
    if (filter === undefined)
      return counters;

    var matched = [];
    for (var i = 0; i < counters.length; ++i) {
      if (filter.matchCounter(counters[i]))
        matched.push(counters[i]);
    }
    return matched;
  }

  /**
   * @constructor The generic base class for filtering a Model based on
   * various rules. The base class returns true for everything.
   */
  function Filter() {
  }

  Filter.prototype = {
    __proto__: Object.prototype,

    matchCounter: function(counter) {
      return true;
    },

    matchCpu: function(cpu) {
      return true;
    },

    matchProcess: function(process) {
      return true;
    },

    matchSlice: function(slice) {
      return true;
    },

    matchThread: function(thread) {
      return true;
    }
  };

  /**
   * @constructor A filter that matches objects by their name.
   * .findAllObjectsMatchingFilter
   */
  function TitleFilter(text) {
    Filter.call(this);
    this.text_ = text;
  }
  TitleFilter.prototype = {
    __proto__: Filter.prototype,

    matchCounter: function(counter) {
      if (this.text_.length == 0)
        return false;
      if (counter.name === undefined)
        return false;
      return counter.name.indexOf(this.text_) != -1;
    },

    matchSlice: function(slice) {
      if (this.text_.length == 0)
        return false;
      if (slice.title === undefined)
        return false;
      return slice.title.indexOf(this.text_) != -1;
    }
  };

  /**
   * @constructor A filter that filters objects by their category.
   * Objects match if they are NOT in the list of categories
   * @param {Array<string>} opt_categories Categories to blacklist.
   */
  function CategoryFilter(opt_categories) {
    Filter.call(this);
    this.categories_ = {};
    var cats = opt_categories || [];
    for (var i = 0; i < cats.length; i++)
      this.addCategory(cats[i]);
  }
  CategoryFilter.prototype = {
    __proto__: Filter.prototype,

    addCategory: function(cat) {
      this.categories_[cat] = true;
    },

    matchCounter: function(counter) {
      if (!counter.category)
        return true;
      return !this.categories_[counter.category];
    },

    matchSlice: function(slice) {
      if (!slice.category)
        return true;
      return !this.categories_[slice.category];
    }
  };

  return {
    filterCounterArray: filterCounterArray,
    filterSliceArray: filterSliceArray,
    Filter: Filter,
    TitleFilter: TitleFilter,
    CategoryFilter: CategoryFilter
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Model is a parsed representation of the
 * TraceEvents obtained from base/trace_event in which the begin-end
 * tokens are converted into a hierarchy of processes, threads,
 * subrows, and slices.
 *
 * The building block of the model is a slice. A slice is roughly
 * equivalent to function call executing on a specific thread. As a
 * result, slices may have one or more subslices.
 *
 * A thread contains one or more subrows of slices. Row 0 corresponds to
 * the "root" slices, e.g. the topmost slices. Row 1 contains slices that
 * are nested 1 deep in the stack, and so on. We use these subrows to draw
 * nesting tasks.
 *
 */
'use strict';
base.exportTo('base', function() {

  function Range() {
    this.isEmpty_ = true;
    this.min_ = undefined;
    this.max_ = undefined;
  };

  Range.prototype = {
    __proto__: Object.prototype,

    reset: function() {
      this.isEmpty_ = true;
      this.min_ = undefined;
      this.max_ = undefined;
    },

    get isEmpty() {
      return this.isEmpty_;
    },

    addRange: function(range) {
      if (range.isEmpty)
        return;
      this.addValue(range.min);
      this.addValue(range.max);
    },

    addValue: function(value) {
      if (this.isEmpty_) {
        this.max_ = value;
        this.min_ = value;
        this.isEmpty_ = false;
        return;
      }
      this.max_ = Math.max(this.max_, value);
      this.min_ = Math.min(this.min_, value);
    },

    get min() {
      if (this.isEmpty_)
        return undefined;
      return this.min_;
    },

    get max() {
      if (this.isEmpty_)
        return undefined;
      return this.max_;
    },
  };

  return {
    Range: Range
  };

});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Code for the viewport.
 */
base.require('range');
base.require('event_target');
base.exportTo('tracing', function() {

  function SelectionSliceHit(track, slice) {
    this.track = track;
    this.slice = slice;
  }
  SelectionSliceHit.prototype = {
    get selected() {
      return this.slice.selected;
    },
    set selected(v) {
      this.slice.selected = v;
    }
  };

  function SelectionCounterSampleHit(track, counter, sampleIndex) {
    this.track = track;
    this.counter = counter;
    this.sampleIndex = sampleIndex;
  }
  SelectionCounterSampleHit.prototype = {
    get selected() {
      return this.track.selectedSamples[this.sampleIndex] == true;
    },
    set selected(v) {
      if (v)
        this.track.selectedSamples[this.sampleIndex] = true;
      else
        this.track.selectedSamples[this.sampleIndex] = false;
      this.track.invalidate();
    }
  };


  /**
   * Represents a selection within a  and its associated set of tracks.
   * @constructor
   */
  function Selection() {
    this.bounds_dirty_ = true;
    this.bounds_ = new base.Range();
    this.length_ = 0;
  }
  Selection.prototype = {
    __proto__: Object.prototype,

    get bounds() {
      if (this.bounds_dirty_) {
        this.bounds_.reset();
        for (var i = 0; i < this.length_; i++) {
          var hit = this[i];
          if (hit.slice) {
            this.bounds_.addValue(hit.slice.start);
            this.bounds_.addValue(hit.slice.end);
          }
        }
        this.bounds_dirty_ = false;
      }
      return this.bounds_;
    },

    get duration() {
      if (this.bounds_.isEmpty)
        return 0;
      return this.bounds_.max - this.bounds_.min;
    },

    get length() {
      return this.length_;
    },

    clear: function() {
      for (var i = 0; i < this.length_; ++i)
        delete this[i];
      this.length_ = 0;
      this.bounds_dirty_ = true;
    },

    pushHit: function(hit) {
      this.push_(hit);
    },

    push_: function(hit) {
      this[this.length_++] = hit;
      this.bounds_dirty_ = true;
      return hit;
    },

    addSlice: function(track, slice) {
      return this.push_(new SelectionSliceHit(track, slice));
    },

    addCounterSample: function(track, counter, sampleIndex) {
      return this.push_(
          new SelectionCounterSampleHit(
          track, counter, sampleIndex));
    },

    subSelection: function(index, count) {
      count = count || 1;

      var selection = new Selection();
      selection.bounds_dirty_ = true;
      if (index < 0 || index + count > this.length_)
        throw new Error('Index out of bounds');

      for (var i = index; i < index + count; i++)
        selection.push_(this[i]);

      return selection;
    },

    getCounterSampleHitsAsSelection: function() {
      var selection = new Selection();
      for (var i = 0; i < this.length_; i++)
        if (this[i] instanceof SelectionCounterSampleHit)
          selection.push_(this[i]);
      return selection;
    },

    getSliceHitsAsSelection: function() {
      var selection = new Selection();
      for (var i = 0; i < this.length_; i++)
        if (this[i] instanceof SelectionSliceHit)
          selection.push_(this[i]);
      return selection;
    },

    getNumSliceHits: function() {
      var numHits = 0;
      for (var i = 0; i < this.length_; i++)
        if (this[i] instanceof SelectionSliceHit)
          numHits++;
      return numHits;
    },

    getNumCounterHits: function() {
      var numHits = 0;
      for (var i = 0; i < this.length_; i++)
        if (this[i] instanceof SelectionCounterSampleHit)
          numHits++;
      return numHits;
    },

    map: function(fn) {
      for (var i = 0; i < this.length_; i++)
        fn(this[i]);
    },

    /**
     * Helper for selection previous or next.
     * @param {boolean} forwardp If true, select one forward (next).
     *   Else, select previous.
     * @return {boolean} true if current selection changed.
     */
    getShiftedSelection: function(offset) {
      var newSelection = new Selection();
      for (var i = 0; i < this.length_; i++) {
        var hit = this[i];
        hit.track.addItemNearToProvidedHitToSelection(
            hit, offset, newSelection);
      }

      if (newSelection.length == 0)
        return undefined;
      return newSelection;
    }
  };

  return {
    SelectionSliceHit: SelectionSliceHit,
    SelectionCounterSampleHit: SelectionCounterSampleHit,
    Selection: Selection
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Code for the viewport.
 */
base.require('event_target');

base.exportTo('tracing', function() {

  /**
   * The TimelineViewport manages the transform used for navigating
   * within the timeline. It is a simple transform:
   *   x' = (x+pan) * scale
   *
   * The timeline code tries to avoid directly accessing this transform,
   * instead using this class to do conversion between world and viewspace,
   * as well as the math for centering the viewport in various interesting
   * ways.
   *
   * @constructor
   * @extends {base.EventTarget}
   */
  function TimelineViewport(parentEl) {
    this.parentEl_ = parentEl;
    this.scaleX_ = 1;
    this.panX_ = 0;
    this.gridTimebase_ = 0;
    this.gridStep_ = 1000 / 60;
    this.gridEnabled_ = false;
    this.hasCalledSetupFunction_ = false;

    this.onResizeBoundToThis_ = this.onResize_.bind(this);

    // The following code uses an interval to detect when the parent element
    // is attached to the document. That is a trigger to run the setup function
    // and install a resize listener.
    this.checkForAttachInterval_ = setInterval(
        this.checkForAttach_.bind(this), 250);

    this.markers = [];
  }

  TimelineViewport.prototype = {
    __proto__: base.EventTarget.prototype,

    drawUnderContent: function(ctx, viewLWorld, viewRWorld, canvasH) {
    },

    drawOverContent: function(ctx, viewLWorld, viewRWorld, canvasH) {
      if (this.gridEnabled) {
        var x = this.gridTimebase;

        ctx.beginPath();
        while (x < viewRWorld) {
          if (x >= viewLWorld) {
            // Do conversion to viewspace here rather than on
            // x to avoid precision issues.
            var vx = this.xWorldToView(x);
            ctx.moveTo(vx, 0);
            ctx.lineTo(vx, canvasH);
          }
          x += this.gridStep;
        }
        ctx.strokeStyle = 'rgba(255,0,0,0.25)';
        ctx.stroke();
      }

      for (var i = 0; i < this.markers.length; ++i) {
        this.markers[i].drawLine(ctx, viewLWorld, viewRWorld, canvasH, this);
      }
    },

    /**
     * Allows initialization of the viewport when the viewport's parent element
     * has been attached to the document and given a size.
     * @param {Function} fn Function to call when the viewport can be safely
     * initialized.
     */
    setWhenPossible: function(fn) {
      this.pendingSetFunction_ = fn;
    },

    /**
     * @return {boolean} Whether the current timeline is attached to the
     * document.
     */
    get isAttachedToDocument_() {
      var cur = this.parentEl_;
      while (cur.parentNode)
        cur = cur.parentNode;
      return cur == this.parentEl_.ownerDocument;
    },

    onResize_: function() {
      this.dispatchChangeEvent();
    },

    /**
     * Checks whether the parentNode is attached to the document.
     * When it is, it installs the iframe-based resize detection hook
     * and then runs the pendingSetFunction_, if present.
     */
    checkForAttach_: function() {
      if (!this.isAttachedToDocument_ || this.clientWidth == 0)
        return;

      if (!this.iframe_) {
        this.iframe_ = document.createElement('iframe');
        this.iframe_.style.cssText =
            'position:absolute;width:100%;height:0;border:0;visibility:hidden;';
        this.parentEl_.appendChild(this.iframe_);

        this.iframe_.contentWindow.addEventListener('resize',
                                                    this.onResizeBoundToThis_);
      }

      var curSize = this.clientWidth + 'x' + this.clientHeight;
      if (this.pendingSetFunction_) {
        this.lastSize_ = curSize;
        try {
          this.pendingSetFunction_();
        } catch (ex) {
          console.log('While running setWhenPossible:', ex);
        }
        this.pendingSetFunction_ = undefined;
      }

      window.clearInterval(this.checkForAttachInterval_);
      this.checkForAttachInterval_ = undefined;
    },

    /**
     * Fires the change event on this viewport. Used to notify listeners
     * to redraw when the underlying model has been mutated.
     */
    dispatchChangeEvent: function() {
      base.dispatchSimpleEvent(this, 'change');
    },

    dispatchMarkersChangeEvent_: function() {
      base.dispatchSimpleEvent(this, 'markersChange');
    },

    detach: function() {
      if (this.checkForAttachInterval_) {
        window.clearInterval(this.checkForAttachInterval_);
        this.checkForAttachInterval_ = undefined;
      }
      if (this.iframe_) {
        this.iframe_.removeEventListener('resize', this.onResizeBoundToThis_);
        this.parentEl_.removeChild(this.iframe_);
      }
    },

    get scaleX() {
      return this.scaleX_;
    },
    set scaleX(s) {
      var changed = this.scaleX_ != s;
      if (changed) {
        this.scaleX_ = s;
        this.dispatchChangeEvent();
      }
    },

    get panX() {
      return this.panX_;
    },
    set panX(p) {
      var changed = this.panX_ != p;
      if (changed) {
        this.panX_ = p;
        this.dispatchChangeEvent();
      }
    },

    setPanAndScale: function(p, s) {
      var changed = this.scaleX_ != s || this.panX_ != p;
      if (changed) {
        this.scaleX_ = s;
        this.panX_ = p;
        this.dispatchChangeEvent();
      }
    },

    xWorldToView: function(x) {
      return (x + this.panX_) * this.scaleX_;
    },

    xWorldVectorToView: function(x) {
      return x * this.scaleX_;
    },

    xViewToWorld: function(x) {
      return (x / this.scaleX_) - this.panX_;
    },

    xViewVectorToWorld: function(x) {
      return x / this.scaleX_;
    },

    xPanWorldPosToViewPos: function(worldX, viewX, viewWidth) {
      if (typeof viewX == 'string') {
        if (viewX == 'left') {
          viewX = 0;
        } else if (viewX == 'center') {
          viewX = viewWidth / 2;
        } else if (viewX == 'right') {
          viewX = viewWidth - 1;
        } else {
          throw new Error('unrecognized string for viewPos. left|center|right');
        }
      }
      this.panX = (viewX / this.scaleX_) - worldX;
    },

    xPanWorldBoundsIntoView: function(worldMin, worldMax, viewWidth) {
      if (this.xWorldToView(worldMin) < 0)
        this.xPanWorldPosToViewPos(worldMin, 'left', viewWidth);
      else if (this.xWorldToView(worldMax) > viewWidth)
        this.xPanWorldPosToViewPos(worldMax, 'right', viewWidth);
    },

    xSetWorldBounds: function(worldMin, worldMax, viewWidth) {
      var worldWidth = worldMax - worldMin;
      var scaleX = viewWidth / worldWidth;
      var panX = -worldMin;
      this.setPanAndScale(panX, scaleX);
    },

    get gridEnabled() {
      return this.gridEnabled_;
    },

    set gridEnabled(enabled) {
      if (this.gridEnabled_ == enabled)
        return;
      this.gridEnabled_ = enabled && true;
      this.dispatchChangeEvent();
    },

    get gridTimebase() {
      return this.gridTimebase_;
    },

    set gridTimebase(timebase) {
      if (this.gridTimebase_ == timebase)
        return;
      this.gridTimebase_ = timebase;
      base.dispatchSimpleEvent(this, 'change');
    },

    get gridStep() {
      return this.gridStep_;
    },

    applyTransformToCanvas: function(ctx) {
      ctx.transform(this.scaleX_, 0, 0, 1, this.panX_ * this.scaleX_, 0);
    },

    addMarker: function(positionWorld) {
      var marker = new ViewportMarker(this, positionWorld);
      this.markers.push(marker);
      this.dispatchChangeEvent();
      this.dispatchMarkersChangeEvent_();
      return marker;
    },

    removeMarker: function(marker) {
      for (var i = 0; i < this.markers.length; ++i) {
        if (this.markers[i] === marker) {
          this.markers.splice(i, 1);
          this.dispatchChangeEvent();
          this.dispatchMarkersChangeEvent_();
          return true;
        }
      }
    },

    findMarkerNear: function(positionWorld, nearnessInViewPixels) {
      // Converts pixels into distance in world.
      var nearnessThresholdWorld = this.xViewVectorToWorld(
          nearnessInViewPixels);
      for (var i = 0; i < this.markers.length; ++i) {
        if (Math.abs(this.markers[i].positionWorld - positionWorld) <=
            nearnessThresholdWorld) {
          var marker = this.markers[i];
          return marker;
        }
      }
      return undefined;
    }
  };

  /**
   * Represents a marked position in the world, at a viewport level.
   * @constructor
   */
  function ViewportMarker(vp, positionWorld) {
    this.viewport_ = vp;
    this.positionWorld_ = positionWorld;
    this.selected_ = false;
  }

  ViewportMarker.prototype = {
    get positionWorld() {
      return this.positionWorld_;
    },

    set positionWorld(positionWorld) {
      this.positionWorld_ = positionWorld;
      this.viewport_.dispatchChangeEvent();
    },

    set selected(selected) {
      this.selected_ = selected;
      this.viewport_.dispatchChangeEvent();
    },

    get selected() {
      return this.selected_;
    },

    get color() {
      if (this.selected)
        return 'rgb(255,0,0)';
      return 'rgb(0,0,0)';
    },

    drawTriangle_: function(ctx, viewLWorld, viewRWorld,
                            canvasH, rulerHeight, vp) {
      ctx.beginPath();
      var ts = this.positionWorld_;
      if (ts >= viewLWorld && ts < viewRWorld) {
        var viewX = vp.xWorldToView(ts);
        ctx.moveTo(viewX, rulerHeight);
        ctx.lineTo(viewX - 3, rulerHeight / 2);
        ctx.lineTo(viewX + 3, rulerHeight / 2);
        ctx.lineTo(viewX, rulerHeight);
        ctx.closePath();
        ctx.fillStyle = this.color;
        ctx.fill();
        if (rulerHeight != canvasH) {
          ctx.beginPath();
          ctx.moveTo(viewX, rulerHeight);
          ctx.lineTo(viewX, canvasH);
          ctx.closePath();
          ctx.strokeStyle = this.color;
          ctx.stroke();
        }
      }
    },

    drawLine: function(ctx, viewLWorld, viewRWorld, canvasH, vp) {
      ctx.beginPath();
      var ts = this.positionWorld_;
      if (ts >= viewLWorld && ts < viewRWorld) {
        var viewX = vp.xWorldToView(ts);
        ctx.moveTo(viewX, 0);
        ctx.lineTo(viewX, canvasH);
      }
      ctx.strokeStyle = this.color;
      ctx.stroke();
    }
  };

  return {
    TimelineViewport: TimelineViewport,
    ViewportMarker: ViewportMarker
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

base.exportTo('tracing.ui', function() {

  /**
   * Decorates elements as an instance of a class.
   * @param {string|!Element} source The way to find the element(s) to decorate.
   *     If this is a string then {@code querySeletorAll} is used to find the
   *     elements to decorate.
   * @param {!Function} constr The constructor to decorate with. The constr
   *     needs to have a {@code decorate} function.
   */
  function decorate(source, constr) {
    var elements;
    if (typeof source == 'string')
      elements = base.doc.querySelectorAll(source);
    else
      elements = [source];

    for (var i = 0, el; el = elements[i]; i++) {
      if (!(el instanceof constr))
        constr.decorate(el);
    }
  }

  /**
   * Helper function for creating new element for define.
   */
  function createElementHelper(tagName, opt_bag) {
    // Allow passing in ownerDocument to create in a different document.
    var doc;
    if (opt_bag && opt_bag.ownerDocument)
      doc = opt_bag.ownerDocument;
    else
      doc = base.doc;
    return doc.createElement(tagName);
  }

  /**
   * Creates the constructor for a UI element class.
   *
   * Usage:
   * <pre>
   * var List = tracing.ui.define('list');
   * List.prototype = {
   *   __proto__: HTMLUListElement.prototype,
   *   decorate: function() {
   *     ...
   *   },
   *   ...
   * };
   * </pre>
   *
   * @param {string|Function} tagNameOrFunction The tagName or
   *     function to use for newly created elements. If this is a function it
   *     needs to return a new element when called.
   * @return {function(Object=):Element} The constructor function which takes
   *     an optional property bag. The function also has a static
   *     {@code decorate} method added to it.
   */
  function define(tagNameOrFunction) {
    var createFunction, tagName;
    if (typeof tagNameOrFunction == 'function') {
      createFunction = tagNameOrFunction;
      tagName = '';
    } else {
      createFunction = createElementHelper;
      tagName = tagNameOrFunction;
    }

    /**
     * Creates a new UI element constructor.
     * @param {Object=} opt_propertyBag Optional bag of properties to set on the
     *     object after created. The property {@code ownerDocument} is special
     *     cased and it allows you to create the element in a different
     *     document than the default.
     * @constructor
     */
    function f(opt_propertyBag) {
      var el = createFunction(tagName, opt_propertyBag);
      f.decorate(el);
      for (var propertyName in opt_propertyBag) {
        el[propertyName] = opt_propertyBag[propertyName];
      }
      return el;
    }

    /**
     * Decorates an element as a UI element class.
     * @param {!Element} el The element to decorate.
     */
    f.decorate = function(el) {
      el.__proto__ = f.prototype;
      el.decorate();
    };

    return f;
  }

  /**
   * Input elements do not grow and shrink with their content. This is a simple
   * (and not very efficient) way of handling shrinking to content with support
   * for min width and limited by the width of the parent element.
   * @param {HTMLElement} el The element to limit the width for.
   * @param {number} parentEl The parent element that should limit the size.
   * @param {number} min The minimum width.
   */
  function limitInputWidth(el, parentEl, min) {
    // Needs a size larger than borders
    el.style.width = '10px';
    var doc = el.ownerDocument;
    var win = doc.defaultView;
    var computedStyle = win.getComputedStyle(el);
    var parentComputedStyle = win.getComputedStyle(parentEl);
    var rtl = computedStyle.direction == 'rtl';

    // To get the max width we get the width of the treeItem minus the position
    // of the input.
    var inputRect = el.getBoundingClientRect();  // box-sizing
    var parentRect = parentEl.getBoundingClientRect();
    var startPos = rtl ? parentRect.right - inputRect.right :
        inputRect.left - parentRect.left;

    // Add up border and padding of the input.
    var inner = parseInt(computedStyle.borderLeftWidth, 10) +
        parseInt(computedStyle.paddingLeft, 10) +
        parseInt(computedStyle.paddingRight, 10) +
        parseInt(computedStyle.borderRightWidth, 10);

    // We also need to subtract the padding of parent to prevent it to overflow.
    var parentPadding = rtl ? parseInt(parentComputedStyle.paddingLeft, 10) :
        parseInt(parentComputedStyle.paddingRight, 10);

    var max = parentEl.clientWidth - startPos - inner - parentPadding;

    function limit() {
      if (el.scrollWidth > max) {
        el.style.width = max + 'px';
      } else {
        el.style.width = 0;
        var sw = el.scrollWidth;
        if (sw < min) {
          el.style.width = min + 'px';
        } else {
          el.style.width = sw + 'px';
        }
      }
    }

    el.addEventListener('input', limit);
    limit();
  }

  /**
   * Takes a number and spits out a value CSS will be happy with. To avoid
   * subpixel layout issues, the value is rounded to the nearest integral value.
   * @param {number} pixels The number of pixels.
   * @return {string} e.g. '16px'.
   */
  function toCssPx(pixels) {
    if (!window.isFinite(pixels))
      console.error('Pixel value is not a number: ' + pixels);
    return Math.round(pixels) + 'px';
  }

  return {
    decorate: decorate,
    define: define,
    limitInputWidth: limitInputWidth,
    toCssPx: toCssPx
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


/**
 * @fileoverview Renders an array of slices into the provided div,
 * using a child canvas element. Uses a FastRectRenderer to draw only
 * the visible slices.
 */
base.requireStylesheet('tracks.track');
base.require('ui');
base.exportTo('tracing.tracks', function() {

  /**
   * The base class for all tracks.
   * @constructor
   */
  var Track = tracing.ui.define('div');
  Track.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate: function() {
    },

    get visible() {
      return this.style.display !== 'none';
    },

    set visible(v) {
      this.style.display = (v ? '' : 'none');
    },

    get numVisibleTracks() {
      return (this.visible ? 1 : 0);
    },

    addControlButtonElements_: function(canCollapse) {
      var closeEl = document.createElement('div');
      closeEl.classList.add('track-button');
      closeEl.classList.add('track-close-button');
      closeEl.textContent = String.fromCharCode(215); // &times;
      var that = this;
      closeEl.addEventListener('click', function() {
        that.style.display = 'None';
      });
      this.appendChild(closeEl);

      var collapseEl = document.createElement('div');
      collapseEl.classList.add('track-button');
      collapseEl.classList.add('track-collapse-button');
      var minus = '\u2212'; // minus sign;
      var plus = '\u002b'; // plus sign;
      collapseEl.textContent = minus;
      var collapsed = false;
      collapseEl.addEventListener('click', function() {
        collapsed = !collapsed;
        this.collapsedDidChange(collapsed);
        collapseEl.textContent = collapsed ? plus : minus;
      });
      this.appendChild(collapseEl);
      if (!canCollapse)
        collapseEl.style.display = 'None';
    }
  };

  return {
    Track: Track
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

base.require('tracks.track');
base.require('filter');
base.require('ui');
base.exportTo('tracing.tracks', function() {

  /**
   * A generic track that contains other tracks as its children.
   * @constructor
   */
  var ContainerTrack = tracing.ui.define(tracing.tracks.Track);
  ContainerTrack.prototype = {
    __proto__: tracing.tracks.Track.prototype,

    decorate: function() {
      this.categoryFilter_ = new tracing.Filter();
      this.headingWidth_ = undefined;
      this.tracks_ = [];
    },

    detach: function() {
      this.detachAllChildren();
    },

    detachAllChildren: function() {
      for (var i = 0; i < this.tracks_.length; i++)
        this.tracks_[i].detach();
      this.tracks_ = [];
      this.textContent = '';
    },

    get viewport() {
      return this.viewport_;
    },

    set viewport(v) {
      this.viewport_ = v;
      for (var i = 0; i < this.tracks_.length; i++)
        this.tracks_[i].viewport = v;
    },

    get firstCanvas() {
      for (var i = 0; i < this.tracks_.length; i++)
        if (this.tracks_[i].visible)
          return this.tracks_[i].firstCanvas;
      return undefined;
    },

    // The number of tracks actually displayed.
    get numVisibleTracks() {
      if (!this.visible)
        return 0;
      return this.numVisibleChildTracks;
    },

    // The number of tracks that would be displayed if this track were visible.
    get numVisibleChildTracks() {
      var sum = 0;
      for (var i = 0; i < this.tracks_.length; ++i) {
        sum += this.tracks_[i].numVisibleTracks;
      }
      return sum;
    },

    get headingWidth() {
      return this.headingWidth_;
    },

    set headingWidth(w) {
      this.headingWidth_ = w;
      for (var i = 0; i < this.tracks_.length; ++i) {
        this.tracks_[i].headingWidth = w;
      }
    },

    get categoryFilter() {
      return this.categoryFilter_;
    },

    set categoryFilter(v) {
      this.categoryFilter_ = v;
      for (var i = 0; i < this.tracks_.length; ++i) {
        this.tracks_[i].categoryFilter = v;
      }
      this.applyCategoryFilter_();
      this.updateFirstVisibleChildCSS();
    },

    applyCategoryFilter_: function() {
    },

    addTrack_: function(track) {
      track.headingWidth = this.headingWidth_;
      track.viewport = this.viewport_;
      track.categoryFilter = this.categoryFilter;

      this.tracks_.push(track);
      this.appendChild(track);
      return track;
    },

    updateFirstVisibleChildCSS: function() {
      var isFirst = true;
      for (var i = 0; i < this.tracks_.length; ++i) {
        var track = this.tracks_[i];
        if (isFirst && track.visible) {
          track.classList.add('first-visible-child');
          isFirst = false;
        } else {
          track.classList.remove('first-visible-child');
        }
      }
    },

    /**
     * Adds items intersecting a point to a selection.
     * @param {number} vX X location to search at, in viewspace.
     * @param {number} vY Y location to search at, in viewspace.
     * @param {Selection} selection Selection to which to add hits.
     * @return {boolean} true if a slice was found, otherwise false.
     */
    addIntersectingItemsToSelection: function(vX, vY, selection) {
      for (var i = 0; i < this.tracks_.length; i++) {
        var trackClientRect = this.tracks_[i].getBoundingClientRect();
        if (vY >= trackClientRect.top && vY < trackClientRect.bottom)
          this.tracks_[i].addIntersectingItemsToSelection(vX, vY, selection);
      }
      return false;
    },

    /**
     * Adds items intersecting the given range to a selection.
     * @param {number} loVX Lower X bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVX Upper X bound of the interval to search, in
     *     viewspace.
     * @param {number} loY Lower Y bound of the interval to search, in
     *     viewspace space.
     * @param {number} hiY Upper Y bound of the interval to search, in
     *     viewspace space.
     * @param {Selection} selection Selection to which to add hits.
     */
    addIntersectingItemsInRangeToSelection: function(
        loVX, hiVX, loY, hiY, selection) {
      for (var i = 0; i < this.tracks_.length; i++) {
        var trackClientRect = this.tracks_[i].getBoundingClientRect();
        var a = Math.max(loY, trackClientRect.top);
        var b = Math.min(hiY, trackClientRect.bottom);
        if (a <= b)
          this.tracks_[i].addIntersectingItemsInRangeToSelection(
              loVX, hiVX, loY, hiY, selection);
      }
    },

    addAllObjectsMatchingFilterToSelection: function(filter, selection) {
      for (var i = 0; i < this.tracks_.length; i++)
        this.tracks_[i].addAllObjectsMatchingFilterToSelection(
            filter, selection);
    }
  };

  return {
    ContainerTrack: ContainerTrack
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


/**
 * @fileoverview Provides a mechanism for drawing massive numbers of
 * colored rectangles into a canvas in an efficient manner, provided
 * they are drawn left to right with fixed y and height throughout.
 *
 * The basic idea used here is to fuse subpixel rectangles together so that
 * we never issue a canvas fillRect for them. It turns out Javascript can
 * do this quite efficiently, compared to asking Canvas2D to do the same.
 *
 * A few extra things are done by this class in the name of speed:
 * - Viewport culling: off-viewport rectangles are discarded.
 *
 * - The actual discarding operation is done in world space,
 *   e.g. pre-transform.
 *
 * - Rather than expending compute cycles trying to figure out an average
 *   color for fused rectangles from css strings, you instead draw using
 *   palletized colors. The fused rect is the max pallete index encountered.
 *
 * Make sure to flush the trackRenderer before finishing drawing in order
 * to commit any queued drawing operations.
 */
base.exportTo('tracing', function() {

  /**
   * Creates a fast rect renderer with a specific set of culling rules
   * and color pallette.
   * @param {GraphicsContext2D} ctx Canvas2D drawing context.
   * @param {number} minRectSize Only rectangles with width < minRectSize are
   *    considered for merging.
   * @param {number} maxMergeDist Controls how many successive small rectangles
   *    can be merged together before issuing a rectangle.
   * @param {Array} pallette The color pallete for drawing. Pallette slots
   *    should map to valid Canvas fillStyle strings.
   *
   * @constructor
   */
  function FastRectRenderer(ctx, minRectSize, maxMergeDist, pallette) {
    this.ctx_ = ctx;
    this.minRectSize_ = minRectSize;
    this.maxMergeDist_ = maxMergeDist;
    this.pallette_ = pallette;
  }

  FastRectRenderer.prototype = {
    y_: 0,
    h_: 0,
    merging_: false,
    mergeStartX_: 0,
    mergeCurRight_: 0,

    /**
     * Changes the y position and height for subsequent fillRect
     * calls. x and width are specifieid on the fillRect calls.
     */
    setYandH: function(y, h) {
      this.flush();
      this.y_ = y;
      this.h_ = h;
    },

    /**
     * Fills rectangle at the specified location, if visible. If the
     * rectangle is subpixel, it will be merged with adjacent rectangles.
     * The drawing operation may not take effect until flush is called.
     * @param {number} colorId The color of this rectangle, as an index
     *     in the renderer's color pallete.
     */
    fillRect: function(x, w, colorId) {
      var r = x + w;
      if (w < this.minRectSize_) {
        if (r - this.mergeStartX_ > this.maxMergeDist_)
          this.flush();
        if (!this.merging_) {
          this.merging_ = true;
          this.mergeStartX_ = x;
          this.mergeCurRight_ = r;
          this.mergedColorId = colorId;
        } else {
          this.mergeCurRight_ = r;
          this.mergedColorId = Math.max(this.mergedColorId, colorId);
        }
      } else {
        if (this.merging_)
          this.flush();
        this.ctx_.fillStyle = this.pallette_[colorId];
        this.ctx_.fillRect(x, this.y_, w, this.h_);
      }
    },

    /**
     * Commits any pending fillRect operations to the underlying graphics
     * context.
     */
    flush: function() {
      if (this.merging_) {
        this.ctx_.fillStyle = this.pallette_[this.mergedColorId];
        this.ctx_.fillRect(this.mergeStartX_, this.y_,
                           this.mergeCurRight_ - this.mergeStartX_, this.h_);
        this.merging_ = false;
      }
    }
  };

  return {
    FastRectRenderer: FastRectRenderer
  };

});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Provides color scheme related functions.
 */
base.exportTo('tracing', function() {

  // The color palette is split in half, with the upper
  // half of the palette being the "highlighted" verison
  // of the base color. So, color 7's highlighted form is
  // 7 + (palette.length / 2).
  //
  // These bright versions of colors are automatically generated
  // from the base colors.
  //
  // Within the color palette, there are "regular" colors,
  // which can be used for random color selection, and
  // reserved colors, which are used when specific colors
  // need to be used, e.g. where red is desired.
  var paletteBase = [
    {r: 138, g: 113, b: 152},
    {r: 175, g: 112, b: 133},
    {r: 127, g: 135, b: 225},
    {r: 93, g: 81, b: 137},
    {r: 116, g: 143, b: 119},
    {r: 178, g: 214, b: 122},
    {r: 87, g: 109, b: 147},
    {r: 119, g: 155, b: 95},
    {r: 114, g: 180, b: 160},
    {r: 132, g: 85, b: 103},
    {r: 157, g: 210, b: 150},
    {r: 148, g: 94, b: 86},
    {r: 164, g: 108, b: 138},
    {r: 139, g: 191, b: 150},
    {r: 110, g: 99, b: 145},
    {r: 80, g: 129, b: 109},
    {r: 125, g: 140, b: 149},
    {r: 93, g: 124, b: 132},
    {r: 140, g: 85, b: 140},
    {r: 104, g: 163, b: 162},
    {r: 132, g: 141, b: 178},
    {r: 131, g: 105, b: 147},
    {r: 135, g: 183, b: 98},
    {r: 152, g: 134, b: 177},
    {r: 141, g: 188, b: 141},
    {r: 133, g: 160, b: 210},
    {r: 126, g: 186, b: 148},
    {r: 112, g: 198, b: 205},
    {r: 180, g: 122, b: 195},
    {r: 203, g: 144, b: 152},
    // Reserved Entires
    {r: 182, g: 125, b: 143},
    {r: 126, g: 200, b: 148},
    {r: 133, g: 160, b: 210},
    {r: 240, g: 240, b: 240}];

  // Make sure this number tracks the number of reserved entries in the
  // palette.
  var numReservedColorIds = 4;

  function brighten(c) {
    var k;
    if (c.r >= 240 && c.g >= 240 && c.b >= 240)
      k = -0.20;
    else
      k = 0.45;

    return {r: Math.min(255, c.r + Math.floor(c.r * k)),
      g: Math.min(255, c.g + Math.floor(c.g * k)),
      b: Math.min(255, c.b + Math.floor(c.b * k))};
  }
  function colorToString(c) {
    return 'rgb(' + c.r + ',' + c.g + ',' + c.b + ')';
  }

  /**
   * The number of color IDs that getStringColorId can choose from.
   */
  var numRegularColorIds = paletteBase.length - numReservedColorIds;
  var highlightIdBoost = paletteBase.length;

  var palette = paletteBase.concat(paletteBase.map(brighten)).
      map(colorToString);
  /**
   * Computes a simplistic hashcode of the provide name. Used to chose colors
   * for slices.
   * @param {string} name The string to hash.
   */
  function getStringHash(name) {
    var hash = 0;
    for (var i = 0; i < name.length; ++i)
      hash = (hash + 37 * hash + 11 * name.charCodeAt(i)) % 0xFFFFFFFF;
    return hash;
  }

  /**
   * Gets the color palette.
   */
  function getColorPalette() {
    return palette;
  }

  /**
   * @return {Number} The value to add to a color ID to get its highlighted
   * colro ID. E.g. 7 + getPaletteHighlightIdBoost() yields a brightened from
   * of 7's base color.
   */
  function getColorPaletteHighlightIdBoost() {
    return highlightIdBoost;
  }

  /**
   * @param {String} name The color name.
   * @return {Number} The color ID for the given color name.
   */
  function getColorIdByName(name) {
    if (name == 'iowait')
      return numRegularColorIds;
    if (name == 'running')
      return numRegularColorIds + 1;
    if (name == 'runnable')
      return numRegularColorIds + 2;
    if (name == 'sleeping')
      return numRegularColorIds + 3;
    throw new Error('Unrecognized color ') + name;
  }

  // Previously computed string color IDs. They are based on a stable hash, so
  // it is safe to save them throughout the program time.
  var stringColorIdCache = {};

  /**
   * @return {Number} A color ID that is stably associated to the provided via
   * the getStringHash method. The color ID will be chosen from the regular
   * ID space only, e.g. no reserved ID will be used.
   */
  function getStringColorId(string) {
    if (stringColorIdCache[string] === undefined) {
      var hash = getStringHash(string);
      stringColorIdCache[string] = hash % numRegularColorIds;
    }
    return stringColorIdCache[string];
  }

  return {
    getColorPalette: getColorPalette,
    getColorPaletteHighlightIdBoost: getColorPaletteHighlightIdBoost,
    getColorIdByName: getColorIdByName,
    getStringHash: getStringHash,
    getStringColorId: getStringColorId
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

base.requireStylesheet('tracks.canvas_based_track');
base.require('tracks.track');
base.require('fast_rect_renderer');
base.require('color_scheme');
base.require('ui');

base.exportTo('tracing.tracks', function() {

  /**
   * A canvas-based track constructed. Provides the basic heading and
   * invalidation-managment infrastructure. Subclasses must implement drawing
   * and picking code.
   * @constructor
   * @extends {HTMLDivElement}
   */
  var CanvasBasedTrack =
      tracing.ui.define(tracing.tracks.Track);

  CanvasBasedTrack.prototype = {
    __proto__: tracing.tracks.Track.prototype,

    decorate: function() {
      this.className = 'canvas-based-track';
      this.slices_ = null;

      this.headingDiv_ = document.createElement('div');
      this.headingDiv_.className = 'canvas-based-track-title';
      this.appendChild(this.headingDiv_);

      this.canvasContainer_ = document.createElement('div');
      this.canvasContainer_.className =
          'canvas-based-track-canvas-container';
      this.appendChild(this.canvasContainer_);
      this.canvas_ = document.createElement('canvas');
      this.canvas_.className = 'canvas-based-track-canvas';
      this.canvasContainer_.appendChild(this.canvas_);

      this.ctx_ = this.canvas_.getContext('2d');
    },

    detach: function() {
      if (this.viewport_) {
        this.viewport_.removeEventListener('change',
                                           this.viewportChangeBoundToThis_);
        this.viewport_.removeEventListener('markersChange',
            this.viewportMarkersChangeBoundToThis_);
      }
    },

    set headingWidth(width) {
      this.headingDiv_.style.width = width;
    },

    get heading() {
      return this.headingDiv_.textContent;
    },

    set heading(text) {
      this.headingDiv_.textContent = text;
    },

    set tooltip(text) {
      this.headingDiv_.title = text;
    },

    get viewport() {
      return this.viewport_;
    },

    set viewport(v) {
      this.viewport_ = v;
      if (this.viewport_) {
        this.viewport_.removeEventListener('change',
                                           this.viewportChangeBoundToThis_);
        this.viewport_.removeEventListener('markersChange',
            this.viewportMarkersChangeBoundToThis_);
      }
      this.viewport_ = v;
      if (this.viewport_) {
        this.viewportChangeBoundToThis_ = this.viewportChange_.bind(this);
        this.viewport_.addEventListener('change',
                                        this.viewportChangeBoundToThis_);
        this.viewportMarkersChangeBoundToThis_ =
            this.viewportMarkersChange_.bind(this);
        this.viewport_.addEventListener('markersChange',
                                        this.viewportMarkersChangeBoundToThis_);
        if (this.isAttachedToDocument_)
          this.updateCanvasSizeIfNeeded_();
      }
      this.invalidate();
    },

    viewportChange_: function() {
      this.invalidate();
    },

    viewportMarkersChange_: function() {
      if (this.viewport_.markers.length < 2)
        this.classList.remove('ruler-track-with-distance-measurements');
      else
        this.classList.add('ruler-track-with-distance-measurements');
    },

    invalidate: function() {
      if (this.rafPending_)
        return;
      webkitRequestAnimationFrame(function() {
        this.rafPending_ = false;
        if (!this.viewport_)
          return;
        this.updateCanvasSizeIfNeeded_();
        this.redraw();
      }.bind(this), this);
      this.rafPending_ = true;
    },

    /**
     * @return {boolean} Whether the current timeline is attached to the
     * document.
     */
    get isAttachedToDocument_() {
      var cur = this.parentNode;
      if (!cur)
        return;
      while (cur.parentNode)
        cur = cur.parentNode;
      return cur == this.ownerDocument;
    },


    updateCanvasSizeIfNeeded_: function() {
      var style = window.getComputedStyle(this.canvasContainer_);
      var innerWidth = parseInt(style.width) -
          parseInt(style.paddingLeft) - parseInt(style.paddingRight) -
          parseInt(style.borderLeftWidth) - parseInt(style.borderRightWidth);
      var innerHeight = parseInt(style.height) -
          parseInt(style.paddingTop) - parseInt(style.paddingBottom) -
          parseInt(style.borderTopWidth) - parseInt(style.borderBottomWidth);
      var pixelRatio = window.devicePixelRatio || 1;
      if (this.canvas_.width != innerWidth) {
        this.canvas_.width = innerWidth * pixelRatio;
        this.canvas_.style.width = innerWidth + 'px';
      }
      if (this.canvas_.height != innerHeight) {
        this.canvas_.height = innerHeight * pixelRatio;
        this.canvas_.style.height = innerHeight + 'px';
      }
    },
    get firstCanvas() {
      return this.canvas_;
    }
  };

  return {
    CanvasBasedTrack: CanvasBasedTrack
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


/**
 * @fileoverview Helper functions for doing intersections and iteration
 * over sorted arrays and intervals.
 *
 */
base.exportTo('tracing', function() {
  /**
   * Finds the first index in the array whose value is >= loVal.
   *
   * The key for the search is defined by the mapFn. This array must
   * be prearranged such that ary.map(mapFn) would also be sorted in
   * ascending order.
   *
   * @param {Array} ary An array of arbitrary objects.
   * @param {function():*} mapFn Callback that produces a key value
   *     from an element in ary.
   * @param {number} loVal Value for which to search.
   * @return {Number} Offset o into ary where all ary[i] for i <= o
   *     are < loVal, or ary.length if loVal is greater than all elements in
   *     the array.
   */
  function findLowIndexInSortedArray(ary, mapFn, loVal) {
    if (ary.length == 0)
      return 1;

    var low = 0;
    var high = ary.length - 1;
    var i, comparison;
    var hitPos = -1;
    while (low <= high) {
      i = Math.floor((low + high) / 2);
      comparison = mapFn(ary[i]) - loVal;
      if (comparison < 0) {
        low = i + 1; continue;
      } else if (comparison > 0) {
        high = i - 1; continue;
      } else {
        hitPos = i;
        high = i - 1;
      }
    }
    // return where we hit, or failing that the low pos
    return hitPos != -1 ? hitPos : low;
  }

  /**
   * Finds an index in an array of intervals that either
   * intersects the provided loVal, or if no intersection is found,
   * the index of the first interval whose start is > loVal.
   *
   * The array of intervals is defined implicitly via two mapping functions
   * over the provided ary. mapLoFn determines the lower value of the interval,
   * mapWidthFn the width. Intersection is lower-inclusive, e.g. [lo,lo+w).
   *
   * The array of intervals formed by this mapping must be non-overlapping and
   * sorted in ascending order by loVal.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   *     nonoverlapping ranges [x,y) using the mapLoFn and mapWidth.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   *     interval represented by an  element in the array.
   * @param {function():*} mapLoFn Callback that produces the width for the
   *     interval represented by an  element in the array.
   * @param {number} loVal The low value for the search.
   * @return {Number} An index in the array that intersects or is first-above
   *     loVal, -1 if none found and loVal is below than all the intervals,
   *     ary.length if loVal is greater than all the intervals.
   */
  function findLowIndexInSortedIntervals(ary, mapLoFn, mapWidthFn, loVal) {
    var first = findLowIndexInSortedArray(ary, mapLoFn, loVal);
    if (first == 0) {
      if (loVal >= mapLoFn(ary[0]) &&
          loVal < mapLoFn(ary[0] + mapWidthFn(ary[0]))) {
        return 0;
      } else {
        return -1;
      }
    } else if (first <= ary.length &&
               loVal >= mapLoFn(ary[first - 1]) &&
               loVal < mapLoFn(ary[first - 1]) + mapWidthFn(ary[first - 1])) {
      return first - 1;
    } else {
      return ary.length;
    }
  }

  /**
   * Calls cb for all intervals in the implicit array of intervals
   * defnied by ary, mapLoFn and mapHiFn that intersect the range
   * [loVal,hiVal)
   *
   * This function uses the same scheme as findLowIndexInSortedArray
   * to define the intervals. The same restrictions on sortedness and
   * non-overlappingness apply.
   *
   * @param {Array} ary An array of objects that can be converted into sorted
   * nonoverlapping ranges [x,y) using the mapLoFn and mapWidth.
   * @param {function():*} mapLoFn Callback that produces the low value for the
   * interval represented by an element in the array.
   * @param {function():*} mapLoFn Callback that produces the width for the
   * interval represented by an element in the array.
   * @param {number} The low value for the search, inclusive.
   * @param {number} loVal The high value for the search, non inclusive.
   * @param {function():*} cb The function to run for intersecting intervals.
   */
  function iterateOverIntersectingIntervals(ary, mapLoFn, mapWidthFn, loVal,
                                            hiVal, cb) {
    if (ary.length == 0)
      return;

    if (loVal > hiVal) return;

    var i = findLowIndexInSortedArray(ary, mapLoFn, loVal);
    if (i == -1) {
      return;
    }
    if (i > 0) {
      var hi = mapLoFn(ary[i - 1]) + mapWidthFn(ary[i - 1]);
      if (hi >= loVal) {
        cb(ary[i - 1]);
      }
    }
    if (i == ary.length) {
      return;
    }

    for (var n = ary.length; i < n; i++) {
      var lo = mapLoFn(ary[i]);
      if (lo >= hiVal)
        break;
      cb(ary[i]);
    }
  }

  /**
   * Non iterative version of iterateOverIntersectingIntervals.
   *
   * @return {Array} Array of elements in ary that intersect loVal, hiVal.
   */
  function getIntersectingIntervals(ary, mapLoFn, mapWidthFn, loVal, hiVal) {
    var tmp = [];
    iterateOverIntersectingIntervals(ary, mapLoFn, mapWidthFn, loVal, hiVal,
                                     function(d) {
                                       tmp.push(d);
                                     });
    return tmp;
  }

  return {
    findLowIndexInSortedArray: findLowIndexInSortedArray,
    findLowIndexInSortedIntervals: findLowIndexInSortedIntervals,
    iterateOverIntersectingIntervals: iterateOverIntersectingIntervals,
    getIntersectingIntervals: getIntersectingIntervals
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

base.requireStylesheet('tracks.slice_track');

base.require('tracks.canvas_based_track');
base.require('sorted_array_utils');
base.require('fast_rect_renderer');
base.require('color_scheme');
base.require('ui');

base.exportTo('tracing.tracks', function() {

  var palette = tracing.getColorPalette();

  /**
   * A track that displays an array of Slice objects.
   * @constructor
   * @extends {CanvasBasedTrack}
   */

  var SliceTrack = tracing.ui.define(tracing.tracks.CanvasBasedTrack);

  SliceTrack.prototype = {

    __proto__: tracing.tracks.CanvasBasedTrack.prototype,

    /**
     * Should we elide text on trace labels?
     * Without eliding, text that is too wide isn't drawn at all.
     * Disable if you feel this causes a performance problem.
     * This is a default value that can be overridden in tracks for testing.
     * @const
     */
    SHOULD_ELIDE_TEXT: true,

    decorate: function() {
      this.classList.add('slice-track');
      this.elidedTitleCache = new ElidedTitleCache();
      this.asyncStyle_ = false;
    },

    /**
     * Called by all the addToSelection functions on the created selection
     * hit objects. Override this function on parent classes to add
     * context-specific information to the hit.
     */
    decorateHit: function(hit) {
    },

    get asyncStyle() {
      return this.asyncStyle_;
    },

    set asyncStyle(v) {
      this.asyncStyle_ = !!v;
      this.invalidate();
    },

    get slices() {
      return this.slices_;
    },

    set slices(slices) {
      this.slices_ = slices || [];
      if (!slices)
        this.visible = false;
      this.invalidate();
    },

    get height() {
      return window.getComputedStyle(this).height;
    },

    set height(height) {
      this.style.height = height;
      this.invalidate();
    },

    labelWidth: function(title) {
      return quickMeasureText(this.ctx_, title) + 2;
    },

    labelWidthWorld: function(title, pixWidth) {
      return this.labelWidth(title) * pixWidth;
    },

    redraw: function() {
      var ctx = this.ctx_;
      var canvasW = this.canvas_.width;
      var canvasH = this.canvas_.height;

      ctx.clearRect(0, 0, canvasW, canvasH);

      // Culling parameters.
      var vp = this.viewport_;
      var pixWidth = vp.xViewVectorToWorld(1);
      var viewLWorld = vp.xViewToWorld(0);
      var viewRWorld = vp.xViewToWorld(canvasW);

      // Give the viewport a chance to draw onto this canvas.
      vp.drawUnderContent(ctx, viewLWorld, viewRWorld, canvasH);

      // Begin rendering in world space.
      ctx.save();
      vp.applyTransformToCanvas(ctx);

      // Slices.
      if (this.asyncStyle_)
        ctx.globalAlpha = 0.25;
      var tr = new tracing.FastRectRenderer(ctx, 2 * pixWidth, 2 * pixWidth,
                                            palette);
      tr.setYandH(0, canvasH);
      var slices = this.slices_;
      var lowSlice = tracing.findLowIndexInSortedArray(slices,
                                                       function(slice) {
                                                         return slice.start +
                                                                slice.duration;
                                                       },
                                                       viewLWorld);
      for (var i = lowSlice; i < slices.length; ++i) {
        var slice = slices[i];
        var x = slice.start;
        if (x > viewRWorld) {
          break;
        }
        // Less than 0.001 causes short events to disappear when zoomed in.
        var w = Math.max(slice.duration, 0.001);
        var colorId = slice.selected ?
            slice.colorId + highlightIdBoost :
            slice.colorId;

        if (w < pixWidth)
          w = pixWidth;
        if (slice.duration > 0) {
          tr.fillRect(x, w, colorId);
        } else {
          // Instant: draw a triangle.  If zoomed too far, collapse
          // into the FastRectRenderer.
          if (pixWidth > 0.001) {
            tr.fillRect(x, pixWidth, colorId);
          } else {
            ctx.fillStyle = palette[colorId];
            ctx.beginPath();
            ctx.moveTo(x - (4 * pixWidth), canvasH);
            ctx.lineTo(x, 0);
            ctx.lineTo(x + (4 * pixWidth), canvasH);
            ctx.closePath();
            ctx.fill();
          }
        }
      }
      tr.flush();
      ctx.restore();

      // Labels.
      var pixelRatio = window.devicePixelRatio || 1;
      if (canvasH > 8) {
        ctx.textAlign = 'center';
        ctx.textBaseline = 'top';
        ctx.font = (10 * pixelRatio) + 'px sans-serif';
        ctx.strokeStyle = 'rgb(0,0,0)';
        ctx.fillStyle = 'rgb(0,0,0)';
        // Don't render text until until it is 20px wide
        var quickDiscardThresshold = pixWidth * 20;
        var shouldElide = this.SHOULD_ELIDE_TEXT;
        for (var i = lowSlice; i < slices.length; ++i) {
          var slice = slices[i];
          if (slice.start > viewRWorld) {
            break;
          }
          if (slice.duration > quickDiscardThresshold) {
            var title = slice.title;
            if (slice.didNotFinish) {
              title += ' (Did Not Finish)';
            }
            var drawnTitle = title;
            var drawnWidth = this.labelWidth(drawnTitle);
            if (shouldElide &&
                this.labelWidthWorld(drawnTitle, pixWidth) > slice.duration) {
              var elidedValues = this.elidedTitleCache.get(
                  this, pixWidth,
                  drawnTitle, drawnWidth,
                  slice.duration);
              drawnTitle = elidedValues.string;
              drawnWidth = elidedValues.width;
            }
            if (drawnWidth * pixWidth < slice.duration) {
              var cX = vp.xWorldToView(slice.start + 0.5 * slice.duration);
              ctx.fillText(drawnTitle, cX, 2.5 * pixelRatio, drawnWidth);
            }
          }
        }
      }

      // Give the viewport a chance to draw over this canvas.
      vp.drawOverContent(ctx, viewLWorld, viewRWorld, canvasH);
    },

    /**
     * Finds slices intersecting the given interval.
     * @param {number} vX X location to search at, in viewspace.
     * @param {number} vY Y location to search at, in viewspace.
     * @param {Selection} selection Selection to which to add hits.
     * @return {boolean} true if a slice was found, otherwise false.
     */
    addIntersectingItemsToSelection: function(vX, vY, selection) {
      var clientRect = this.getBoundingClientRect();
      if (vY < clientRect.top || vY >= clientRect.bottom)
        return false;
      var pixelRatio = window.devicePixelRatio || 1;
      var wX = this.viewport_.xViewVectorToWorld(vX * devicePixelRatio);
      var x = tracing.findLowIndexInSortedIntervals(this.slices_,
          function(x) { return x.start; },
          function(x) { return x.duration; },
          wX);
      if (x >= 0 && x < this.slices_.length) {
        var hit = selection.addSlice(this, this.slices_[x]);
        this.decorateHit(hit);
        return true;
      }
      return false;
    },

    /**
     * Adds items intersecting the given range to a selection.
     * @param {number} loVX Lower X bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVX Upper X bound of the interval to search, in
     *     viewspace.
     * @param {number} loVY Lower Y bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVY Upper Y bound of the interval to search, in
     *     viewspace.
     * @param {Selection} selection Selection to which to add hits.
     */
    addIntersectingItemsInRangeToSelection: function(
        loVX, hiVX, loVY, hiVY, selection) {

      var pixelRatio = window.devicePixelRatio || 1;
      var loWX = this.viewport_.xViewToWorld(loVX * pixelRatio);
      var hiWX = this.viewport_.xViewToWorld(hiVX * pixelRatio);

      var clientRect = this.getBoundingClientRect();
      var a = Math.max(loVY, clientRect.top);
      var b = Math.min(hiVY, clientRect.bottom);
      if (a > b)
        return;

      var that = this;
      function onPickHit(slice) {
        var hit = selection.addSlice(that, slice);
        that.decorateHit(hit);
      }
      tracing.iterateOverIntersectingIntervals(this.slices_,
          function(x) { return x.start; },
          function(x) { return x.duration; },
          loWX, hiWX,
          onPickHit);
    },

    /**
     * Find the index for the given slice.
     * @return {index} Index of the given slice, or undefined.
     * @private
     */
    indexOfSlice_: function(slice) {
      var index = tracing.findLowIndexInSortedArray(this.slices_,
          function(x) { return x.start; },
          slice.start);
      while (index < this.slices_.length &&
          slice.start == this.slices_[index].start &&
          slice.colorId != this.slices_[index].colorId) {
        index++;
      }
      return index < this.slices_.length ? index : undefined;
    },

    /**
     * Add the item to the left or right of the provided hit, if any, to the
     * selection.
     * @param {slice} The current slice.
     * @param {Number} offset Number of slices away from the hit to look.
     * @param {Selection} selection The selection to add a hit to,
     * if found.
     * @return {boolean} Whether a hit was found.
     * @private
     */
    addItemNearToProvidedHitToSelection: function(hit, offset, selection) {
      if (!hit.slice)
        return false;

      var index = this.indexOfSlice_(hit.slice);
      if (index === undefined)
        return false;

      var newIndex = index + offset;
      if (newIndex < 0 || newIndex >= this.slices_.length)
        return false;

      var hit = selection.addSlice(this, this.slices_[newIndex]);
      this.decorateHit(hit);
      return true;
    },

    addAllObjectsMatchingFilterToSelection: function(filter, selection) {
      for (var i = 0; i < this.slices_.length; ++i) {
        if (filter.matchSlice(this.slices_[i])) {
          var hit = selection.addSlice(this, this.slices_[i]);
          this.decorateHit(hit);
        }
      }
    }
  };

  var highlightIdBoost = tracing.getColorPaletteHighlightIdBoost();

  // TODO(jrg): possibly obsoleted with the elided string cache.
  // Consider removing.
  var textWidthMap = { };
  function quickMeasureText(ctx, text) {
    var w = textWidthMap[text];
    if (!w) {
      w = ctx.measureText(text).width;
      textWidthMap[text] = w;
    }
    return w;
  }

  /**
   * Cache for elided strings.
   * Moved from the ElidedTitleCache protoype to a "global" for speed
   * (variable reference is 100x faster).
   *   key: String we wish to elide.
   *   value: Another dict whose key is width
   *     and value is an ElidedStringWidthPair.
   */
  var elidedTitleCacheDict = {};

  /**
   * A cache for elided strings.
   * @constructor
   */
  function ElidedTitleCache() {
  }

  ElidedTitleCache.prototype = {
    /**
     * Return elided text.
     * @param {track} A slice track or other object that defines
     *                functions labelWidth() and labelWidthWorld().
     * @param {pixWidth} Pixel width.
     * @param {title} Original title text.
     * @param {width} Drawn width in world coords.
     * @param {sliceDuration} Where the title must fit (in world coords).
     * @return {ElidedStringWidthPair} Elided string and width.
     */
    get: function(track, pixWidth, title, width, sliceDuration) {
      var elidedDict = elidedTitleCacheDict[title];
      if (!elidedDict) {
        elidedDict = {};
        elidedTitleCacheDict[title] = elidedDict;
      }
      var elidedDictForPixWidth = elidedDict[pixWidth];
      if (!elidedDictForPixWidth) {
        elidedDict[pixWidth] = {};
        elidedDictForPixWidth = elidedDict[pixWidth];
      }
      var stringWidthPair = elidedDictForPixWidth[sliceDuration];
      if (stringWidthPair === undefined) {
        var newtitle = title;
        var elided = false;
        while (track.labelWidthWorld(newtitle, pixWidth) > sliceDuration) {
          newtitle = newtitle.substring(0, newtitle.length * 0.75);
          elided = true;
        }
        if (elided && newtitle.length > 3)
          newtitle = newtitle.substring(0, newtitle.length - 3) + '...';
        stringWidthPair = new ElidedStringWidthPair(
            newtitle,
            track.labelWidth(newtitle));
        elidedDictForPixWidth[sliceDuration] = stringWidthPair;
      }
      return stringWidthPair;
    }
  };

  /**
   * A pair representing an elided string and world-coordinate width
   * to draw it.
   * @constructor
   */
  function ElidedStringWidthPair(string, width) {
    this.string = string;
    this.width = width;
  }

  return {
    SliceTrack: SliceTrack
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Model is a parsed representation of the
 * TraceEvents obtained from base/trace_event in which the begin-end
 * tokens are converted into a hierarchy of processes, threads,
 * subrows, and slices.
 *
 * The building block of the model is a slice. A slice is roughly
 * equivalent to function call executing on a specific thread. As a
 * result, slices may have one or more subslices.
 *
 * A thread contains one or more subrows of slices. Row 0 corresponds to
 * the "root" slices, e.g. the topmost slices. Row 1 contains slices that
 * are nested 1 deep in the stack, and so on. We use these subrows to draw
 * nesting tasks.
 *
 */
'use strict';
base.exportTo('tracing', function() {

  var nextGUID = 1;
  var GUID = {
    allocate: function() {
      return nextGUID++;
    }
  };

  return {
    GUID: GUID
  };

});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Provides the Slice class.
 */
base.exportTo('tracing.model', function() {

  /**
   * A Slice represents an interval of time plus parameters associated
   * with that interval.
   *
   * NOTE: The Sample class implements the same interface as
   * Slice. These must be kept in sync.
   *
   * All time units are stored in milliseconds.
   * @constructor
   */
  function Slice(category, title, colorId, start, args, opt_duration) {
    this.category = category || '';
    this.title = title;
    this.start = start;
    this.colorId = colorId;
    this.args = args;
    this.didNotFinish = false;
    if (opt_duration !== undefined)
      this.duration = opt_duration;
  }

  Slice.prototype = {
    selected: false,

    duration: undefined,

    get end() {
      return this.start + this.duration;
    }
  };

  return {
    Slice: Slice
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Provides the SliceGroup class.
 */
base.require('range');
base.require('model.slice');
base.require('color_scheme');
base.require('filter');

base.exportTo('tracing.model', function() {
  var Slice = tracing.model.Slice;

  /**
   * A group of Slices, plus code to create them from B/E events, as
   * well as arrange them into subRows.
   *
   * Do not mutate the slices array directly. Modify it only by
   * SliceGroup mutation methods.
   *
   * @constructor
   * @param {function(new:Slice, category, title, colorId, start, args)}
   *     opt_sliceConstructor The constructor to use when creating slices.
   */
  function SliceGroup(opt_sliceConstructor) {
    var sliceConstructor = opt_sliceConstructor || Slice;
    this.sliceConstructor = sliceConstructor;

    this.openPartialSlices_ = [];

    this.slices = [];
    this.bounds = new base.Range();
  }

  SliceGroup.prototype = {
    __proto__: Object.prototype,

    /**
     * Helper function that pushes the provided slice onto the slices array.
     * @param {Slice} slice The slice to be added to the slices array.
     */
    pushSlice: function(slice) {
      this.slices.push(slice);
      return slice;
    },

    /**
     * Helper function that pushes the provided slice onto the slices array.
     * @param {Array.<Slice>} slices An array of slices to be added.
     */
    pushSlices: function(slices) {
      this.slices.push.apply(this.slices, slices);
    },

    /**
     * Opens a new slice in the group's slices.
     *
     * Calls to beginSlice and
     * endSlice must be made with non-monotonically-decreasing timestamps.
     *
     * @param {String} title Title of the slice to add.
     * @param {Number} ts The timetsamp of the slice, in milliseconds.
     * @param {Object.<string, Object>} opt_args Arguments associated with
     * the slice.
     */
    beginSlice: function(category, title, ts, opt_args) {
      if (this.openPartialSlices_.length) {
        var prevSlice = this.openPartialSlices_[
            this.openPartialSlices_.length - 1];
        if (ts < prevSlice.start)
          throw new Error('Slices must be added in increasing timestamp order');
      }

      var colorId = tracing.getStringColorId(title);
      var slice = new this.sliceConstructor(category, title, colorId, ts,
                                            opt_args ? opt_args : {});
      this.openPartialSlices_.push(slice);
      return slice;
    },

    isTimestampValidForBeginOrEnd: function(ts) {
      if (!this.openPartialSlices_.length)
        return true;
      var top = this.openPartialSlices_[this.openPartialSlices_.length - 1];
      return ts >= top.start;
    },

    /**
     * @return {Number} The number of beginSlices for which an endSlice has not
     * been issued.
     */
    get openSliceCount() {
      return this.openPartialSlices_.length;
    },

    /**
     * Ends the last begun slice in this group and pushes it onto the slice
     * array.
     *
     * @param {Number} ts Timestamp when the slice ended.
     * @return {Slice} slice.
     */
    endSlice: function(ts) {
      if (!this.openSliceCount)
        throw new Error('endSlice called without an open slice');
      var slice = this.openPartialSlices_[this.openSliceCount - 1];
      this.openPartialSlices_.splice(this.openSliceCount - 1, 1);
      if (ts < slice.start)
        throw new Error('Slice ' + slice.name +
                        ' end time is before its start.');

      slice.duration = ts - slice.start;
      this.pushSlice(slice);

      return slice;
    },

    /**
     * Closes any open slices.
     * @param {Number} opt_maxTimestamp The end time to use for the closed
     * slices. If not provided,
     * the max timestamp for this slice is provided.
     */
    autoCloseOpenSlices: function(opt_maxTimestamp) {
      if (!opt_maxTimestamp) {
        this.updateBounds();
        opt_maxTimestamp = this.bounds.max;
      }
      while (this.openSliceCount > 0) {
        var slice = this.endSlice(opt_maxTimestamp);
        slice.didNotFinish = true;
      }
    },

    /**
     * Shifts all the timestamps inside this group forward by the amount
     * specified.
     */
    shiftTimestampsForward: function(amount) {
      for (var sI = 0; sI < this.slices.length; sI++) {
        var slice = this.slices[sI];
        slice.start = (slice.start + amount);
      }
      for (var sI = 0; sI < this.openPartialSlices_.length; sI++) {
        var slice = this.openPartialSlices_[i];
        slice.start = (slice.start + amount);
      }
    },

    /**
     * Updates the bounds for this group based on the slices it contains.
     */
    updateBounds: function() {
      this.bounds.reset();
      for (var i = 0; i < this.slices.length; i++) {
        this.bounds.addValue(this.slices[i].start);
        this.bounds.addValue(this.slices[i].end);
      }

      if (this.openPartialSlices_.length) {
        this.bounds.addValue(this.openPartialSlices_[0].start);
        this.bounds.addValue(
            this.openPartialSlices_[this.openPartialSlices_.length - 1].start);
      }
    }
  };

  return {
    SliceGroup: SliceGroup
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Provides the AsyncSliceGroup class.
 */
base.require('range');
base.require('model.slice');
base.exportTo('tracing.model', function() {

  var Slice = tracing.model.Slice;

  /**
   * A AsyncSlice represents an interval of time during which an
   * asynchronous operation is in progress. An AsyncSlice consumes no CPU time
   * itself and so is only associated with Threads at its start and end point.
   *
   * @constructor
   */
  function AsyncSlice(category, title, colorId, start, args) {
    Slice.call(this, category, title, colorId, start, args);
  };

  AsyncSlice.prototype = {
    __proto__: Slice.prototype,

    toJSON: function() {
      var obj = new Object();
      var keys = Object.keys(this);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (typeof this[key] == 'function')
          continue;
        if (key == 'startThread' || key == 'endThread') {
          obj[key] = this[key].guid;
          continue;
        }
        obj[key] = this[key];
      }
      return obj;
    },

    id: undefined,

    startThread: undefined,

    endThread: undefined,

    subSlices: undefined
  };

  /**
   * A group of AsyncSlices.
   * @constructor
   */
  function AsyncSliceGroup() {
    this.slices = [];
    this.bounds = new base.Range();
  }

  AsyncSliceGroup.prototype = {
    __proto__: Object.prototype,

    /**
     * Helper function that pushes the provided slice onto the slices array.
     */
    push: function(slice) {
      this.slices.push(slice);
    },

    /**
     * @return {Number} The number of slices in this group.
     */
    get length() {
      return this.slices.length;
    },

    /**
     * Shifts all the timestamps inside this group forward by the amount
     * specified.
     */
    shiftTimestampsForward: function(amount) {
      for (var sI = 0; sI < this.slices.length; sI++) {
        var slice = this.slices[sI];
        slice.start = (slice.start + amount);
        for (var sJ = 0; sJ < slice.subSlices.length; sJ++)
          slice.subSlices[sJ].start += amount;
      }
    },

    /**
     * Updates the bounds for this group based on the slices it contains.
     */
    updateBounds: function() {
      this.bounds.reset();
      for (var i = 0; i < this.slices.length; i++) {
        this.bounds.addValue(this.slices[i].start);
        this.bounds.addValue(this.slices[i].end);
      }
    },

    /**
     * Breaks up this group into slices based on start thread.
     *
     * @return {Array} An array of AsyncSliceGroups where each group has
     * slices that started on the same thread.
     */
    computeSubGroups: function() {
      var subGroupsByGUID = {};
      for (var i = 0; i < this.slices.length; ++i) {
        var slice = this.slices[i];
        var sliceGUID = slice.startThread.guid;
        if (!subGroupsByGUID[sliceGUID])
          subGroupsByGUID[sliceGUID] = new AsyncSliceGroup();
        subGroupsByGUID[sliceGUID].slices.push(slice);
      }
      var groups = [];
      for (var guid in subGroupsByGUID) {
        var group = subGroupsByGUID[guid];
        group.updateBounds();
        groups.push(group);
      }
      return groups;
    }
  };

  return {
    AsyncSlice: AsyncSlice,
    AsyncSliceGroup: AsyncSliceGroup
  };
});

// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Provides the Sample class.
 */
base.exportTo('tracing.model', function() {

  /**
   * A Sample represents a sample taken at an instant in time
   * plus parameters associated with that sample.
   *
   * NOTE: The Sample class implements the same interface as
   * Slice. These must be kept in sync.
   *
   * All time units are stored in milliseconds.
   * @constructor
   */
  function Sample(category, title, colorId, ts, args) {
    this.category = category || '';
    this.title = title;
    this.colorId = colorId;
    this.start = ts;
    this.args = args;
  }

  Sample.prototype = {
    selected: false,

    duration: 0,

    get end() {
      return this.start;
    }
  };

  return {
    Sample: Sample
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Provides the Thread class.
 */
base.require('range');
base.require('guid');
base.require('model.slice');
base.require('model.slice_group');
base.require('model.async_slice_group');
base.require('model.sample');
base.exportTo('tracing.model', function() {

  var Slice = tracing.model.Slice;
  var SliceGroup = tracing.model.SliceGroup;
  var AsyncSlice = tracing.model.AsyncSlice;
  var AsyncSliceGroup = tracing.model.AsyncSliceGroup;

  /**
   * A ThreadSlice represents an interval of time on a thread resource
   * with associated nestinged slice information.
   *
   * ThreadSlices are typically associated with a specific trace event pair on a
   * specific thread.
   * For example,
   *   TRACE_EVENT_BEGIN1("x","myArg", 7) at time=0.1ms
   *   TRACE_EVENT_END0()                 at time=0.3ms
   * This results in a single slice from 0.1 with duration 0.2 on a
   * specific thread.
   *
   * @constructor
   */
  function ThreadSlice(cat, title, colorId, start, args, opt_duration) {
    Slice.call(this, cat, title, colorId, start, args, opt_duration);
    // Do not modify this directly.
    // subSlices is configured by SliceGroup.rebuildSubRows_.
    this.subSlices = [];
  }

  ThreadSlice.prototype = {
    __proto__: Slice.prototype
  };

  /**
   * A Thread stores all the trace events collected for a particular
   * thread. We organize the synchronous slices on a thread by "subrows," where
   * subrow 0 has all the root slices, subrow 1 those nested 1 deep, and so on.
   * The asynchronous slices are stored in an AsyncSliceGroup object.
   *
   * The slices stored on a Thread should be instances of
   * ThreadSlice.
   *
   * @constructor
   */
  function Thread(parent, tid) {
    SliceGroup.call(this, ThreadSlice);
    this.guid_ = tracing.GUID.allocate();
    if (!parent)
      throw new Error('Parent must be provided.');
    this.parent = parent;
    this.tid = tid;
    this.cpuSlices = undefined;
    this.samples_ = [];
    this.asyncSlices = new AsyncSliceGroup();
    this.bounds = new base.Range();
  }

  Thread.prototype = {

    __proto__: SliceGroup.prototype,

    /*
     * @return {Number} A globally unique identifier for this counter.
     */
    get guid() {
      return this.guid_;
    },

    compareTo: function(that) {
      return Thread.compare(this, that);
    },

    toJSON: function() {
      var obj = new Object();
      var keys = Object.keys(this);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (typeof this[key] == 'function')
          continue;
        if (key == 'parent') {
          obj[key] = this[key].guid;
          continue;
        }
        obj[key] = this[key];
      }
      return obj;
    },

    /**
     * Adds a new sample in the thread's samples.
     *
     * Calls to addSample must be made with non-monotonically-decreasing
     * timestamps.
     *
     * @param {String} category Category of the sample to add.
     * @param {String} title Title of the sample to add.
     * @param {Number} ts The timetsamp of the sample, in milliseconds.
     * @param {Object.<string, Object>} opt_args Arguments associated with
     * the sample.
     */
    addSample: function(category, title, ts, opt_args) {
      if (this.samples_.length) {
        var lastSample = this.samples_[this.samples_.length - 1];
        if (ts < lastSample.start) {
          throw new
            Error('Samples must be added in increasing timestamp order.');
        }
      }
      var colorId = tracing.getStringColorId(title);
      var sample = new tracing.model.Sample(category, title, colorId, ts,
                                            opt_args ? opt_args : {});
      this.samples_.push(sample);
      return sample;
    },

    /**
     * Returns the array of samples added to this thread. If no samples
     * have been added, an empty array is returned.
     *
     * @return {Array<Sample>} array of samples.
     */
    get samples() {
      return this.samples_;
    },

    /**
     * Name of the thread, if present.
     */
    name: undefined,

    /**
     * Shifts all the timestamps inside this thread forward by the amount
     * specified.
     */
    shiftTimestampsForward: function(amount) {
      SliceGroup.prototype.shiftTimestampsForward.call(this, amount);

      if (this.cpuSlices) {
        for (var i = 0; i < this.cpuSlices.length; i++) {
          var slice = this.cpuSlices[i];
          slice.start += amount;
        }
      }

      if (this.samples_.length) {
        for (var i = 0; i < this.samples_.length; i++) {
          var sample = this.samples_[i];
          sample.start += amount;
        }
      }

      this.asyncSlices.shiftTimestampsForward(amount);
    },

    /**
     * Determins whether this thread is empty. If true, it usually implies
     * that it should be pruned from the model.
     */
    get isEmpty() {
      if (this.slices.length)
        return false;
      if (this.openSliceCount)
        return false;
      if (this.cpuSlices && this.cpuSlices.length)
        return false;
      if (this.asyncSlices.length)
        return false;
      if (this.samples_.length)
        return false;
      return true;
    },

    /**
     * Updates the bounds based on the
     * current objects associated with the thread.
     */
    updateBounds: function() {
      SliceGroup.prototype.updateBounds.call(this);

      this.asyncSlices.updateBounds();
      this.bounds.addRange(this.asyncSlices.bounds);

      if (this.cpuSlices && this.cpuSlices.length) {
        this.bounds.addValue(this.cpuSlices[0].start);
        this.bounds.addValue(
          this.cpuSlices[this.cpuSlices.length - 1].end);
      }
      if (this.samples_.length) {
        this.bounds.addValue(this.samples_[0].start);
        this.bounds.addValue(
          this.samples_[this.samples_.length - 1].end);
      }
    },

    addCategoriesToDict: function(categoriesDict) {
      for (var i = 0; i < this.slices.length; i++)
        categoriesDict[this.slices[i].category] = true;
      for (var i = 0; i < this.asyncSlices.length; i++)
        categoriesDict[this.asyncSlices.slices[i].category] = true;
      for (var i = 0; i < this.samples_.length; i++)
        categoriesDict[this.samples_[i].category] = true;
    },

    /**
     * @return {String} A user-friendly name for this thread.
     */
    get userFriendlyName() {
      var tname = this.name || this.tid;
      return this.parent.userFriendlyName + ': ' + tname;
    },

    /**
     * @return {String} User friendly details about this thread.
     */
    get userFriendlyDetails() {
      return this.parent.userFriendlyDetails +
          ', tid: ' + this.tid +
          (this.name ? ', name: ' + this.name : '');
    }
  };

  /**
   * Comparison between threads that orders first by parent.compareTo,
   * then by names, then by tid.
   */
  Thread.compare = function(x, y) {
    var tmp = x.parent.compareTo(y.parent);
    if (tmp != 0)
      return tmp;

    if (x.name && y.name) {
      var tmp = x.name.localeCompare(y.name);
      if (tmp == 0)
        return x.tid - y.tid;
      return tmp;
    } else if (x.name) {
      return -1;
    } else if (y.name) {
      return 1;
    } else {
      return x.tid - y.tid;
    }
  };

  return {
    ThreadSlice: ThreadSlice,
    Thread: Thread
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

base.require('guid');
base.require('range');

/**
 * @fileoverview Provides the Counter class.
 */
base.exportTo('tracing.model', function() {

  /**
   * Stores all the samples for a given counter.
   * @constructor
   */
  function Counter(parent, id, category, name) {
    this.guid_ = tracing.GUID.allocate();

    this.parent = parent;
    this.id = id;
    this.category = category || '';
    this.name = name;
    this.seriesNames = [];
    this.seriesColors = [];
    this.timestamps = [];
    this.samples = [];
    this.bounds = new base.Range();
  }

  Counter.prototype = {
    __proto__: Object.prototype,

    /*
     * @return {Number} A globally unique identifier for this counter.
     */
    get guid() {
      return this.guid_;
    },

    toJSON: function() {
      var obj = new Object();
      var keys = Object.keys(this);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (typeof this[key] == 'function')
          continue;
        if (key == 'parent') {
          obj[key] = this[key].guid;
          continue;
        }
        obj[key] = this[key];
      }
      return obj;
    },

    get numSeries() {
      return this.seriesNames.length;
    },

    get numSamples() {
      return this.timestamps.length;
    },

    getSampleValue: function(index, seriesIndex) {
      return this.samples[index * this.numSeries + seriesIndex];
    },

    /**
     * Obtains min, max, avg, values, start, and end for different series for
     * a given counter
     *     getSampleStatistics([0,1])
     * The statistics objects that this returns are an array of objects, one
     * object for each series for the counter in the form:
     * {min: minVal, max: maxVal, avg: avgVal, start: startVal, end: endVal}
     *
     * @param {Array.<Number>} Indices to summarize.
     * @return {Object} An array of statistics. Each element in the array
     * has data for one of the series in the selected counter.
     */
    getSampleStatistics: function(sampleIndices) {
      sampleIndices.sort();
      var sampleIndex = this.sampleIndex;
      var numSeries = this.numSeries;
      var numSamples = this.numSamples;

      var ret = [];

      for (var i = 0; i < numSeries; ++i) {
        var sum = 0;
        var min = Number.MAX_VALUE;
        var max = -Number.MAX_VALUE;
        for (var j = 0; j < sampleIndices.length; j++) {
          var x = sampleIndices[j];
          sum += this.getSampleValue(x, i);
          min = Math.min(this.getSampleValue(x, i), min);
          max = Math.max(this.getSampleValue(x, i), max);
        }
        var avg = sum / sampleIndices.length;
        var start = this.getSampleValue(sampleIndices[0], i);
        var end = this.getSampleValue(
            sampleIndices[sampleIndices.length - 1], i);

        ret.push({min: min,
          max: max,
          avg: avg,
          start: start,
          end: end});
      }
      return ret;
    },

    /**
     * Shifts all the timestamps inside this counter forward by the amount
     * specified.
     */
    shiftTimestampsForward: function(amount) {
      for (var sI = 0; sI < this.timestamps.length; sI++)
        this.timestamps[sI] = (this.timestamps[sI] + amount);
    },

    /**
     * Updates the bounds for this counter based on the samples it contains.
     */
    updateBounds: function() {
      if (this.seriesNames.length != this.seriesColors.length)
        throw new Error('seriesNames.length must match seriesColors.length');
      if (this.numSeries * this.numSamples != this.samples.length)
        throw new Error('samples.length must be a multiple of numSamples.');

      this.totals = [];
      this.maxTotal = 0;
      this.bounds.reset();
      if (this.samples.length == 0)
        return;

      this.bounds.addValue(this.timestamps[0]);
      this.bounds.addValue(this.timestamps[this.timestamps.length - 1]);

      var numSeries = this.numSeries;
      var maxTotal = -Infinity;
      for (var i = 0; i < this.timestamps.length; i++) {
        var total = 0;
        for (var j = 0; j < numSeries; j++) {
          total += this.samples[i * numSeries + j];
          this.totals.push(total);
        }
        if (total > maxTotal)
          maxTotal = total;
      }
      this.maxTotal = maxTotal;
    }

  };

  /**
   * Comparison between counters that orders by parent.compareTo, then name.
   */
  Counter.compare = function(x, y) {
    var tmp = x.parent.compareTo(y);
    if (tmp != 0)
      return tmp;
    var tmp = x.name.localeCompare(y.name);
    if (tmp == 0)
      return x.tid - y.tid;
    return tmp;
  };

  return {
    Counter: Counter
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Provides the ProcessBase class.
 */
base.require('range');
base.require('guid');
base.require('model.thread');
base.require('model.counter');
base.exportTo('tracing.model', function() {

  var Thread = tracing.model.Thread;
  var Counter = tracing.model.Counter;

  /**
   * The ProcessBase is an partial base class, upon which Kernel
   * and Process are built.
   *
   * @constructor
   */
  function ProcessBase() {
    this.guid_ = tracing.GUID.allocate();
    this.threads = {};
    this.counters = {};
    this.bounds = new base.Range();
  };

  ProcessBase.prototype = {
    /*
     * @return {Number} A globally unique identifier for this counter.
     */
    get guid() {
      return this.guid_;
    },

    /**
     * Gets the number of threads in this process.
     */
    get numThreads() {
      var n = 0;
      for (var p in this.threads) {
        n++;
      }
      return n;
    },

    /**
     * Shifts all the timestamps inside this process forward by the amount
     * specified.
     */
    shiftTimestampsForward: function(amount) {
      for (var tid in this.threads)
        this.threads[tid].shiftTimestampsForward(amount);
      for (var id in this.counters)
        this.counters[id].shiftTimestampsForward(amount);
    },

    /**
     * Closes any open slices.
     */
    autoCloseOpenSlices: function(opt_maxTimestamp) {
      for (var tid in this.threads) {
        var thread = this.threads[tid];
        thread.autoCloseOpenSlices(opt_maxTimestamp);
      }
    },

    updateBounds: function() {
      this.bounds.reset();
      for (var tid in this.threads) {
        this.threads[tid].updateBounds();
        this.bounds.addRange(this.threads[tid].bounds);
      }
      for (var id in this.counters) {
        this.counters[id].updateBounds();
        this.bounds.addRange(this.counters[id].bounds);
      }
    },

    addCategoriesToDict: function(categoriesDict) {
      for (var tid in this.threads)
        this.threads[tid].addCategoriesToDict(categoriesDict);
      for (var id in this.counters)
        categoriesDict[this.counters[id].category] = true;
    },

    /**
     * @param {String} The name of the thread to find.
     * @return {Array} An array of all the matched threads.
     */
    findAllThreadsNamed: function(name) {
      var namedThreads = [];
      for (var tid in this.threads) {
        var thread = this.threads[tid];
        if (thread.name == name)
          namedThreads.push(thread);
      }
      return namedThreads;
    },

    /**
     * Removes threads from the process that are fully empty.
     */
    pruneEmptyContainers: function() {
      var threadsToKeep = {};
      for (var tid in this.threads) {
        var thread = this.threads[tid];
        if (!thread.isEmpty)
          threadsToKeep[tid] = thread;
      }
      this.threads = threadsToKeep;
    },

    /**
     * @return {TimlineThread} The thread identified by tid on this process,
     * creating it if it doesn't exist.
     */
    getOrCreateThread: function(tid) {
      if (!this.threads[tid])
        this.threads[tid] = new Thread(this, tid);
      return this.threads[tid];
    },

    /**
     * @return {TimlineCounter} The counter on this process named 'name',
     * creating it if it doesn't exist.
     */
    getOrCreateCounter: function(cat, name) {
      var id = cat + '.' + name;
      if (!this.counters[id])
        this.counters[id] = new Counter(this, id, cat, name);
      return this.counters[id];
    }
  };

  return {
    ProcessBase: ProcessBase
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Provides the Process class.
 */
base.require('model.process_base');
base.exportTo('tracing.model', function() {

  /**
   * The Process represents a single userland process in the
   * trace.
   * @constructor
   */
  function Process(pid) {
    tracing.model.ProcessBase.call(this);
    this.pid = pid;
  };

  /**
   * Comparison between processes that orders by pid.
   */
  Process.compare = function(x, y) {
    return x.pid - y.pid;
  };

  Process.prototype = {
    __proto__: tracing.model.ProcessBase.prototype,

    compareTo: function(that) {
      return Process.compare(this, that);
    },

    get userFriendlyName() {
      return this.pid;
    },

    get userFriendlyDetails() {
      return 'pid: ' + this.pid;
    },
  };

  return {
    Process: Process
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Provides the Process class.
 */
base.require('model.process_base');

base.exportTo('tracing.model', function() {

  /**
   * The Kernel represents kernel-level objects in the
   * model.
   * @constructor
   */
  function Kernel() {
    tracing.model.ProcessBase.call(this);
  };

  /**
   * Comparison between kernels is pretty meaningless.
   */
  Kernel.compare = function(x, y) {
    return 0;
  };

  Kernel.prototype = {
    __proto__: tracing.model.ProcessBase.prototype,

    compareTo: function(that) {
      return Kernel.compare(this, that);
    },

    get userFriendlyName() {
      return 'kernel';
    },

    get userFriendlyDetails() {
      return 'kernel';
    }
  };

  return {
    Kernel: Kernel
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Provides the Cpu class.
 */
base.require('range');
base.require('model.slice');
base.require('model.counter');
base.exportTo('tracing.model', function() {

  var Counter = tracing.model.Counter;

  /**
   * The Cpu represents a Cpu from the kernel's point of view.
   * @constructor
   */
  function Cpu(number) {
    this.cpuNumber = number;
    this.slices = [];
    this.counters = {};
    this.bounds = new base.Range();
  };

  Cpu.prototype = {
    /**
     * @return {TimlineCounter} The counter on this process named 'name',
     * creating it if it doesn't exist.
     */
    getOrCreateCounter: function(cat, name) {
      var id;
      if (cat.length)
        id = cat + '.' + name;
      else
        id = name;
      if (!this.counters[id])
        this.counters[id] = new Counter(this, id, cat, name);
      return this.counters[id];
    },

    /**
     * Shifts all the timestamps inside this CPU forward by the amount
     * specified.
     */
    shiftTimestampsForward: function(amount) {
      for (var sI = 0; sI < this.slices.length; sI++)
        this.slices[sI].start = (this.slices[sI].start + amount);
      for (var id in this.counters)
        this.counters[id].shiftTimestampsForward(amount);
    },

    /**
     * Updates the range based on the current slices attached to the cpu.
     */
    updateBounds: function() {
      this.bounds.reset();
      if (this.slices.length) {
        this.bounds.addValue(this.slices[0].start);
        this.bounds.addValue(this.slices[this.slices.length - 1].end);
      }
      for (var id in this.counters) {
        this.counters[id].updateBounds();
        this.bounds.addRange(this.counters[id].bounds);
      }
    },

    addCategoriesToDict: function(categoriesDict) {
      for (var i = 0; i < this.slices.length; i++)
        categoriesDict[this.slices[i].category] = true;
      for (var id in this.counters)
        categoriesDict[this.counters[id].category] = true;
    },

  };

  /**
   * Comparison between processes that orders by cpuNumber.
   */
  Cpu.compare = function(x, y) {
    return x.cpuNumber - y.cpuNumber;
  };


  return {
    Cpu: Cpu
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Model is a parsed representation of the
 * TraceEvents obtained from base/trace_event in which the begin-end
 * tokens are converted into a hierarchy of processes, threads,
 * subrows, and slices.
 *
 * The building block of the model is a slice. A slice is roughly
 * equivalent to function call executing on a specific thread. As a
 * result, slices may have one or more subslices.
 *
 * A thread contains one or more subrows of slices. Row 0 corresponds to
 * the "root" slices, e.g. the topmost slices. Row 1 contains slices that
 * are nested 1 deep in the stack, and so on. We use these subrows to draw
 * nesting tasks.
 *
 */
base.require('range');
base.require('event_target');
base.require('model.process');
base.require('model.kernel');
base.require('model.cpu');
base.require('filter');

base.exportTo('tracing', function() {

  var Process = tracing.model.Process;
  var Kernel = tracing.model.Kernel;
  var Cpu = tracing.model.Cpu;

  /**
   * Builds a model from an array of TraceEvent objects.
   * @param {Object=} opt_eventData Data from a single trace to be imported into
   *     the new model. See Model.importTraces for details on how to
   *     import multiple traces at once.
   * @param {bool=} opt_shiftWorldToZero Whether to shift the world to zero.
   * Defaults to true.
   * @constructor
   */
  function Model(opt_eventData, opt_shiftWorldToZero) {
    this.kernel = new Kernel();
    this.cpus = {};
    this.processes = {};
    this.importErrors = [];
    this.metadata = [];
    this.categories = [];
    this.bounds = new base.Range();

    if (opt_eventData)
      this.importTraces([opt_eventData], opt_shiftWorldToZero);
  }

  var importerConstructors = [];

  /**
   * Registers an importer. All registered importers are considered
   * when processing an import request.
   *
   * @param {Function} importerConstructor The importer's constructor function.
   */
  Model.registerImporter = function(importerConstructor) {
    importerConstructors.push(importerConstructor);
  };

  Model.prototype = {
    __proto__: base.EventTarget.prototype,

    get numProcesses() {
      var n = 0;
      for (var p in this.processes)
        n++;
      return n;
    },

    /**
     * @return {Cpu} Gets a specific Cpu or creates one if
     * it does not exist.
     */
    getOrCreateCpu: function(cpuNumber) {
      if (!this.cpus[cpuNumber])
        this.cpus[cpuNumber] = new Cpu(cpuNumber);
      return this.cpus[cpuNumber];
    },

    /**
     * @return {Process} Gets a TimlineProcess for a specified pid or
     * creates one if it does not exist.
     */
    getOrCreateProcess: function(pid) {
      if (!this.processes[pid])
        this.processes[pid] = new Process(pid);
      return this.processes[pid];
    },

    /**
     * Generates the set of categories from the slices and counters.
     */
    updateCategories_: function() {
      var categoriesDict = {};
      this.kernel.addCategoriesToDict(categoriesDict);
      for (var pid in this.processes)
        this.processes[pid].addCategoriesToDict(categoriesDict);
      for (var cpuNumber in this.cpus)
        this.cpus[cpuNumber].addCategoriesToDict(categoriesDict);

      this.categories = [];
      for (var category in categoriesDict)
        if (category != '')
          this.categories.push(category);
    },

    updateBounds: function() {
      this.bounds.reset();

      this.kernel.updateBounds();
      this.bounds.addRange(this.kernel.bounds);

      for (var pid in this.processes) {
        this.processes[pid].updateBounds();
        this.bounds.addRange(this.processes[pid].bounds);
      }

      for (var cpuNumber in this.cpus) {
        this.cpus[cpuNumber].updateBounds();
        this.bounds.addRange(this.cpus[cpuNumber].bounds);
      }
    },

    shiftWorldToZero: function() {
      if (this.bounds.isEmpty)
        return;
      var timeBase = this.bounds.min;
      this.kernel.shiftTimestampsForward(-timeBase);
      for (var pid in this.processes)
        this.processes[pid].shiftTimestampsForward(-timeBase);
      for (var cpuNumber in this.cpus)
        this.cpus[cpuNumber].shiftTimestampsForward(-timeBase);
      this.updateBounds();
    },

    getAllThreads: function() {
      var threads = [];
      for (var tid in this.kernel.threads) {
        threads.push(process.threads[tid]);
      }
      for (var pid in this.processes) {
        var process = this.processes[pid];
        for (var tid in process.threads) {
          threads.push(process.threads[tid]);
        }
      }
      return threads;
    },

    /**
     * @return {Array} An array of all cpus in the model.
     */
    getAllCpus: function() {
      var cpus = [];
      for (var cpu in this.cpus)
        cpus.push(this.cpus[cpu]);
      return cpus;
    },

    /**
     * @return {Array} An array of all processes in the model.
     */
    getAllProcesses: function() {
      var processes = [];
      for (var pid in this.processes)
        processes.push(this.processes[pid]);
      return processes;
    },

    /**
     * @return {Array} An array of all the counters in the model.
     */
    getAllCounters: function() {
      var counters = [];
      for (var pid in this.processes) {
        var process = this.processes[pid];
        for (var tid in process.counters) {
          counters.push(process.counters[tid]);
        }
      }
      for (var cpuNumber in this.cpus) {
        var cpu = this.cpus[cpuNumber];
        for (var counterName in cpu.counters)
          counters.push(cpu.counters[counterName]);
      }
      return counters;
    },

    /**
     * @param {String} The name of the thread to find.
     * @return {Array} An array of all the matched threads.
     */
    findAllThreadsNamed: function(name) {
      var namedThreads = [];
      namedThreads.push.apply(
        namedThreads,
        this.kernel.findAllThreadsNamed(name));
      for (var pid in this.processes) {
        namedThreads.push.apply(
          namedThreads,
          this.processes[pid].findAllThreadsNamed(name));
      }
      return namedThreads;
    },

    createImporter_: function(eventData) {
      var importerConstructor;
      for (var i = 0; i < importerConstructors.length; ++i) {
        if (importerConstructors[i].canImport(eventData)) {
          importerConstructor = importerConstructors[i];
          break;
        }
      }
      if (!importerConstructor)
        throw new Error(
            'Could not find an importer for the provided eventData.');

      var importer = new importerConstructor(
          this, eventData);
      return importer;
    },

    /**
     * Imports the provided traces into the model. The eventData type
     * is undefined and will be passed to all the  importers registered
     * via Model.registerImporter. The first importer that returns true
     * for canImport(events) will be used to import the events.
     *
     * The primary trace is provided via the eventData variable. If multiple
     * traces are to be imported, specify the first one as events, and the
     * remainder in the opt_additionalEventData array.
     *
     * @param {Array} traces An array of eventData to be imported. Each
     * eventData should correspond to a single trace file and will be handled by
     * a separate importer.
     * @param {bool=} opt_shiftWorldToZero Whether to shift the world to zero.
     * Defaults to true.
     */
    importTraces: function(traces,
                           opt_shiftWorldToZero) {
      if (opt_shiftWorldToZero === undefined)
        opt_shiftWorldToZero = true;

      // Figure out which importers to use.
      var importers = [];
      for (var i = 0; i < traces.length; ++i)
        importers.push(this.createImporter_(traces[i]));

      // Sort them on priority. This ensures importing happens in a predictable
      // order, e.g. linux_perf_importer before trace_event_importer.
      importers.sort(function(x, y) {
        return x.importPriority - y.importPriority;
      });

      // Run the import.
      for (var i = 0; i < importers.length; i++)
        importers[i].importEvents(i > 0);

      // Autoclose open slices.
      this.updateBounds();
      this.kernel.autoCloseOpenSlices(this.bounds.max);
      for (var pid in this.processes) {
        this.processes[pid].autoCloseOpenSlices(this.bounds.max);
      }

      // Finalize import.
      for (var i = 0; i < importers.length; i++)
        importers[i].finalizeImport();

      // Prune empty containers.
      this.kernel.pruneEmptyContainers();
      for (var pid in this.processes) {
        this.processes[pid].pruneEmptyContainers();
      }

      this.updateBounds();

      this.updateCategories_();

      if (opt_shiftWorldToZero)
        this.shiftWorldToZero();
    }
  };

  /**
   * Importer for empty strings and arrays.
   * @constructor
   */
  function ModelEmptyImporter(events) {
    this.importPriority = 0;
  };

  ModelEmptyImporter.canImport = function(eventData) {
    if (eventData instanceof Array && eventData.length == 0)
      return true;
    if (typeof(eventData) === 'string' || eventData instanceof String) {
      return eventData.length == 0;
    }
    return false;
  };

  ModelEmptyImporter.prototype = {
    __proto__: Object.prototype,

    importEvents: function() {
    },
    finalizeImport: function() {
    }
  };

  Model.registerImporter(ModelEmptyImporter);

  return {
    Model: Model
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

base.require('tracks.container_track');
base.require('tracks.slice_track');
base.require('filter');
base.require('model');
base.require('ui');
base.exportTo('tracing.tracks', function() {

  /**
   * Visualizes a Cpu using a series of of SliceTracks.
   * @constructor
   */
  var CpuTrack =
      tracing.ui.define(tracing.tracks.ContainerTrack);
  CpuTrack.prototype = {
    __proto__: tracing.tracks.ContainerTrack.prototype,

    decorate: function() {
      this.classList.add('cpu-track');
    },

    get cpu() {
      return this.cpu_;
    },

    set cpu(cpu) {
      this.cpu_ = cpu;
      this.updateChildTracks_();
    },

    get tooltip() {
      return this.tooltip_;
    },

    set tooltip(value) {
      this.tooltip_ = value;
      this.updateChildTracks_();
    },

    get heading() {
      return this.heading_;
    },

    set heading(h) {
      this.heading_ = h;
      this.updateChildTracks_();
    },

    applyCategoryFilter_: function() {
      if (this.categoryFilter.matchCpu(this.cpu_))
        this.updateChildTracks_();
      else
        this.visible = false;
    },

    updateChildTracks_: function() {
      this.detach();
      if (this.cpu_) {
        var slices = tracing.filterSliceArray(this.categoryFilter_,
                                              this.cpu_.slices);
        if (slices.length) {
          var track = new tracing.tracks.SliceTrack();
          track.slices = slices;
          track.heading = this.heading_;
          track.tooltip = this.tooltip_;
          this.addTrack_(track);
        }

        for (var counterName in this.cpu_.counters) {
          var counter = this.cpu_.counters[counterName];
          track = new tracing.tracks.CounterTrack();
          track.heading = 'CPU ' + this.cpu_.cpuNumber + ' ' +
              counter.name + ':';
          track.counter = counter;
          this.addTrack_(track);
        }
      }
      this.addControlButtonElements_(false);
    }
  };

  return {
    CpuTrack: CpuTrack
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

base.requireStylesheet('tracks.counter_track');

base.require('tracks.canvas_based_track');
base.require('color_scheme');
base.require('ui');

base.exportTo('tracing.tracks', function() {

  var palette = tracing.getColorPalette();

  /**
   * A track that displays a Counter object.
   * @constructor
   * @extends {CanvasBasedTrack}
   */

  var CounterTrack =
      tracing.ui.define(tracing.tracks.CanvasBasedTrack);

  CounterTrack.prototype = {

    __proto__: tracing.tracks.CanvasBasedTrack.prototype,

    decorate: function() {
      this.classList.add('counter-track');
      this.addControlButtonElements_(false);
      this.selectedSamples_ = {};
      this.categoryFilter_ = new tracing.Filter();
    },

    /**
     * Called by all the addToSelection functions on the created selection
     * hit objects. Override this function on parent classes to add
     * context-specific information to the hit.
     */
    decorateHit: function(hit) {
    },

    get counter() {
      return this.counter_;
    },

    set counter(counter) {
      this.counter_ = counter;
      this.invalidate();
      this.updateVisibility_();
    },

    set categoryFilter(v) {
      this.categoryFilter_ = v;
      this.updateVisibility_();
    },

    /**
     * @return {Object} A sparse, mutable map from sample index to bool. Samples
     * indices the map that are true are drawn as selected. Callers that mutate
     * the map must manually call invalidate on the track to trigger a redraw.
     */
    get selectedSamples() {
      return this.selectedSamples_;
    },

    updateVisibility_: function() {
      this.visible = (this.counter_ &&
                      this.categoryFilter_.matchCounter(this.counter_));
    },

    redraw: function() {
      var ctr = this.counter_;
      var ctx = this.ctx_;
      var canvasW = this.canvas_.width;
      var canvasH = this.canvas_.height;

      ctx.clearRect(0, 0, canvasW, canvasH);

      // Culling parametrs.
      var vp = this.viewport_;
      var pixWidth = vp.xViewVectorToWorld(1);
      var viewLWorld = vp.xViewToWorld(0);
      var viewRWorld = vp.xViewToWorld(canvasW);

      // Give the viewport a chance to draw onto this canvas.
      vp.drawUnderContent(ctx, viewLWorld, viewRWorld, canvasH);

      // Drop sampels that are less than skipDistancePix apart.
      var skipDistancePix = 1;
      var skipDistanceWorld = vp.xViewVectorToWorld(skipDistancePix);

      // Begin rendering in world space.
      ctx.save();
      vp.applyTransformToCanvas(ctx);

      // Figure out where drawing should begin.
      var numSeries = ctr.numSeries;
      var numSamples = ctr.numSamples;
      var startIndex = tracing.findLowIndexInSortedArray(ctr.timestamps,
                                                         function(x) {
                                                           return x;
                                                         },
                                                         viewLWorld);
      startIndex = startIndex - 1 > 0 ? startIndex - 1 : 0;

      // Draw indices one by one until we fall off the viewRWorld.
      var yScale = canvasH / ctr.maxTotal;
      for (var seriesIndex = ctr.numSeries - 1;
           seriesIndex >= 0; seriesIndex--) {
        var colorId = ctr.seriesColors[seriesIndex];
        ctx.fillStyle = palette[colorId];
        ctx.beginPath();

        // Set iLast and xLast such that the first sample we draw is the
        // startIndex sample.
        var iLast = startIndex - 1;
        var xLast = iLast >= 0 ? ctr.timestamps[iLast] - skipDistanceWorld : -1;
        var yLastView = canvasH;

        // Iterate over samples from iLast onward until we either fall off the
        // viewRWorld or we run out of samples. To avoid drawing too much, after
        // drawing a sample at xLast, skip subsequent samples that are less than
        // skipDistanceWorld from xLast.
        var hasMoved = false;
        while (true) {
          var i = iLast + 1;
          if (i >= numSamples) {
            ctx.lineTo(xLast, yLastView);
            ctx.lineTo(xLast + 8 * pixWidth, yLastView);
            ctx.lineTo(xLast + 8 * pixWidth, canvasH);
            break;
          }

          var x = ctr.timestamps[i];

          var y = ctr.totals[i * numSeries + seriesIndex];
          var yView = canvasH - (yScale * y);

          if (x > viewRWorld) {
            ctx.lineTo(x, yLastView);
            ctx.lineTo(x, canvasH);
            break;
          }

          if (x - xLast < skipDistanceWorld) {
            iLast = i;
            continue;
          }

          if (!hasMoved) {
            ctx.moveTo(viewLWorld, canvasH);
            hasMoved = true;
          }
          ctx.lineTo(x, yLastView);
          ctx.lineTo(x, yView);
          iLast = i;
          xLast = x;
          yLastView = yView;
        }
        ctx.closePath();
        ctx.fill();
      }
      ctx.fillStyle = 'rgba(255, 0, 0, 1)';
      for (var i in this.selectedSamples_) {
        if (!this.selectedSamples_[i])
          continue;

        var x = ctr.timestamps[i];
        for (var seriesIndex = ctr.numSeries - 1;
             seriesIndex >= 0; seriesIndex--) {
          var y = ctr.totals[i * numSeries + seriesIndex];
          var yView = canvasH - (yScale * y);
          ctx.fillRect(x - pixWidth, yView - 1, 3 * pixWidth, 3);
        }
      }
      ctx.restore();

      // Give the viewport a chance to draw over this canvas.
      vp.drawOverContent(ctx, viewLWorld, viewRWorld, canvasH);
    },

    /**
     * Adds items intersecting a point to a selection.
     * @param {number} vX X location to search at, in viewspace.
     * @param {number} vY Y location to search at, in viewspace.
     * @param {Selection} selection Selection to which to add hits.
     * @return {boolean} true if a slice was found, otherwise false.
     */
    addIntersectingItemsToSelection: function(vX, vY, selection) {
      var clientRect = this.getBoundingClientRect();
      if (vY < clientRect.top || vY >= clientRect.bottom)
        return false;

      var pixelRatio = window.devicePixelRatio || 1;
      var wX = this.viewport_.xViewVectorToWorld(vX * devicePixelRatio);

      var ctr = this.counter_;
      if (vX < this.counter_.timestamps[0])
        return false;
      var i = tracing.findLowIndexInSortedArray(ctr.timestamps,
                                                function(x) { return x; },
                                                wX);
      if (i < 0 || i >= ctr.timestamps.length)
        return false;

      // Sample i is going to either be exactly at wX or slightly above it,
      // E.g. asking for 7.5 in [7,8] gives i=1. So bump i back by 1 if needed.
      if (i > 0 && wX > this.counter_.timestamps[i - 1])
        i--;

      // Some preliminaries.
      var canvasH = this.getBoundingClientRect().height;
      var yScale = canvasH / ctr.maxTotal;

      /*
      // Figure out which sample we hit
      var seriesIndexHit;
      for (var seriesIndex = 0; seriesIndex < ctr.numSeries; seriesIndex++) {
        var y = ctr.totals[i * ctr.numSeries + seriesIndex];
        var yView = canvasH - (yScale * y) + clientRect.top;
        if (wY >= yView) {
          seriesIndexHit = seriesIndex;
          break;
        }
      }
      if (seriesIndexHit === undefined)
        return false;
      */
      var hit = selection.addCounterSample(this, this.counter, i);
      this.decorateHit(hit);
      return true;
    },

    /**
     * Adds items intersecting the given range to a selection.
     * @param {number} loVX Lower X bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVX Upper X bound of the interval to search, in
     *     viewspace.
     * @param {number} loVY Lower Y bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVY Upper Y bound of the interval to search, in
     *     viewspace.
     * @param {Selection} selection Selection to which to add hits.
     */
    addIntersectingItemsInRangeToSelection: function(
        loVX, hiVX, loVY, hiVY, selection) {

      var clientRect = this.getBoundingClientRect();
      var a = Math.max(loVY, clientRect.top);
      var b = Math.min(hiVY, clientRect.bottom);
      if (a > b)
        return;

      var ctr = this.counter_;

      var pixelRatio = window.devicePixelRatio || 1;
      var loWX = this.viewport_.xViewToWorld(loVX * pixelRatio);
      var hiWX = this.viewport_.xViewToWorld(hiVX * pixelRatio);

      var iLo = tracing.findLowIndexInSortedArray(ctr.timestamps,
                                                  function(x) { return x; },
                                                  loWX);
      var iHi = tracing.findLowIndexInSortedArray(ctr.timestamps,
                                                  function(x) { return x; },
                                                  hiWX);

      // Sample i is going to either be exactly at wX or slightly above it,
      // E.g. asking for 7.5 in [7,8] gives i=1. So bump i back by 1 if needed.
      if (iLo > 0 && loWX > ctr.timestamps[iLo - 1])
        iLo--;
      if (iHi > 0 && hiWX > ctr.timestamps[iHi - 1])
        iHi--;

      // Iterate over every sample intersecting..
      for (var i = iLo; i <= iHi; i++) {
        if (i >= ctr.timestamps.length)
          continue;

        // TODO(nduca): Pick the seriesIndexHit based on the loY - hiY values.
        var hit = selection.addCounterSample(this, this.counter, i);
        this.decorateHit(hit);
      }
    },

    addAllObjectsMatchingFilterToSelection: function(filter, selection) {
    }
  };

  return {
    CounterTrack: CounterTrack
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

base.require('tracks.container_track');
base.require('sorted_array_utils');
base.require('ui');

base.exportTo('tracing.tracks', function() {

  /**
   * A track that displays a SliceGroup.
   * @constructor
   * @extends {ContainerTrack}
   */

  var SliceGroupTrack = tracing.ui.define(tracing.tracks.ContainerTrack);

  SliceGroupTrack.prototype = {

    __proto__: tracing.tracks.ContainerTrack.prototype,

    decorate: function() {
      this.classList.add('slice-group-track');
    },

    get group() {
      return this.group_;
    },

    set group(g) {
      this.group_ = g;
      this.updateChildTracks_();
    },

    set heading(h) {
      if (this.tracks_.length)
        this.tracks_[0].heading = h;
    },

    set tooltip(t) {
      if (this.tracks_.length)
        this.tracks_[0].tooltip = t;
    },

    set decorateHit(f) {
      this.decorateHit_ = f;
      this.updateChildTracks_();
    },

    applyCategoryFilter_: function() {
      this.updateChildTracks_();
    },

    addSliceTrack_: function(slices) {
      var track = new tracing.tracks.SliceTrack();
      track.slices = slices;
      track.decorateHit = this.decorateHit_;
      this.addTrack_(track);
      return track;
    },

    updateChildTracks_: function() {
      if (!this.group_) {
        this.visible = false;
        return;
      }

      var slices = tracing.filterSliceArray(this.categoryFilter,
                                            this.group_.slices);
      if (!slices.length) {
        this.visible = false;
        return;
      }
      this.visible = true;

      if (this.areArrayContentsSame_(this.filteredSlices_, slices))
        return;

      this.filteredSlices_ = slices;
      this.detach();
      this.subRows_ = this.buildSubRows_(slices);
      for (var srI = 0; srI < this.subRows_.length; srI++) {
        if (this.subRows_[srI].length) {
          this.addSliceTrack_(this.subRows_[srI]);
        }
      }
    },

    /**
     * Breaks up the list of slices into N rows, each of which is a list of
     * slices that are non overlapping.
     */
    buildSubRows_: function(slices) {
      // This function works by walking through slices by start time.
      //
      // The basic idea here is to insert each slice as deep into the subrow
      // list as it can go such that every subSlice is fully contained by its
      // parent slice.
      //
      // Visually, if we start with this:
      //  0:  [    a       ]
      //  1:    [  b  ]
      //  2:    [c][d]
      //
      // To place this slice:
      //               [e]
      // We first check row 2's last item, [d]. [e] wont fit into [d] (they dont
      // even intersect). So we go to row 1. That gives us [b], and [d] wont fit
      // into that either. So, we go to row 0 and its last slice, [a]. That can
      // completely contain [e], so that means we should add [e] as a subchild
      // of [a]. That puts it on row 1, yielding:
      //  0:  [    a       ]
      //  1:    [  b  ][e]
      //  2:    [c][d]
      //
      // If we then get this slice:
      //                      [f]
      // We do the same deepest-to-shallowest walk of the subrows trying to fit
      // it. This time, it doesn't fit in any open slice. So, we simply append
      // it to row 0:
      //  0:  [    a       ]  [f]
      //  1:    [  b  ][e]
      //  2:    [c][d]
      if (!slices.length)
        return [];

      var ops = [];
      for (var i = 0; i < slices.length; i++) {
        if (slices[i].subSlices)
          slices[i].subSlices.splice(0,
                                     slices[i].subSlices.length);
        ops.push(i);
      }

      ops.sort(function(ix, iy) {
        var x = slices[ix];
        var y = slices[iy];
        if (x.start != y.start)
          return x.start - y.start;

        // Elements get inserted into the slices array in order of when the
        // slices end.  Because slices must be properly nested, we break
        // start-time ties by assuming that the elements appearing earlier in
        // the slices array (and thus ending earlier) start later.
        return iy - ix;
      });

      var subRows = [[]];
      this.badSlices_ = [];  // TODO(simonjam): Connect this again.

      for (var i = 0; i < ops.length; i++) {
        var op = ops[i];
        var slice = slices[op];

        // Try to fit the slice into the existing subrows.
        var inserted = false;
        for (var j = subRows.length - 1; j >= 0; j--) {
          if (subRows[j].length == 0)
            continue;

          var insertedSlice = subRows[j][subRows[j].length - 1];
          if (slice.start < insertedSlice.start) {
            this.badSlices_.push(slice);
            inserted = true;
          }
          if (slice.start >= insertedSlice.start &&
              slice.end <= insertedSlice.end) {
            // Insert it into subRow j + 1.
            while (subRows.length <= j + 1)
              subRows.push([]);
            subRows[j + 1].push(slice);
            if (insertedSlice.subSlices)
              insertedSlice.subSlices.push(slice);
            inserted = true;
            break;
          }
        }
        if (inserted)
          continue;

        // Append it to subRow[0] as a root.
        subRows[0].push(slice);
      }

      return subRows;
    },

    areArrayContentsSame_: function(a, b) {
      if (!a || !b)
        return false;
      if (!a.length || !b.length)
        return false;
      if (a.length != b.length)
        return false;
      for (var i = 0; i < a.length; ++i) {
        if (a[i] != b[i])
          return false;
      }
      return true;
    }
  };

  return {
    SliceGroupTrack: SliceGroupTrack
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

base.require('tracks.slice_group_track');
base.require('ui');
base.exportTo('tracing.tracks', function() {

  /**
   * A track that displays a AsyncSliceGroup.
   * @constructor
   * @extends {SliceGroup}
   */

  var AsyncSliceGroupTrack = tracing.ui.define(
      tracing.tracks.SliceGroupTrack);

  AsyncSliceGroupTrack.prototype = {

    __proto__: tracing.tracks.SliceGroupTrack.prototype,

    decorate: function() {
      this.classList.add('async-slice-group-track');
    },

    addSliceTrack_: function(slices) {
      var track =
          tracing.tracks.SliceGroupTrack.prototype.addSliceTrack_.call(
              this, slices);
      track.asyncStyle = true;
      return track;
    },

    /**
     * Breaks up the list of slices into N rows, each of which is a list of
     * slices that are non overlapping.
     *
     * It uses a very simple approach: walk through the slices in sorted order
     * by start time. For each slice, try to fit it in an existing subRow. If it
     * doesn't fit in any subrow, make another subRow.
     */
    buildSubRows_: function() {
      var slices = tracing.filterSliceArray(this.categoryFilter,
                                            this.group_.slices);
      slices.sort(function(x, y) {
        return x.start - y.start;
      });

      var subRows = [];
      for (var i = 0; i < slices.length; i++) {
        var slice = slices[i];

        var found = false;
        for (var j = 0; j < subRows.length; j++) {
          var subRow = subRows[j];
          var lastSliceInSubRow = subRow[subRow.length - 1];
          if (slice.start >= lastSliceInSubRow.end) {
            found = true;
            // Instead of plotting one big slice for the entire
            // AsyncEvent, we plot each of the subSlices.
            if (slice.subSlices === undefined || slice.subSlices.length < 1)
              throw new Error('AsyncEvent missing subSlices: ') +
                  slice.name;
            for (var k = 0; k < slice.subSlices.length; k++)
              subRow.push(slice.subSlices[k]);
            break;
          }
        }
        if (!found) {
          var subRow = [];
          if (slice.subSlices !== undefined) {
            for (var k = 0; k < slice.subSlices.length; k++)
              subRow.push(slice.subSlices[k]);
            subRows.push(subRow);
          }
        }
      }
      return subRows;
    }
  };

  return {
    AsyncSliceGroupTrack: AsyncSliceGroupTrack
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

base.requireStylesheet('tracks.thread_track');

base.require('tracks.container_track');
base.require('tracks.slice_track');
base.require('tracks.slice_group_track');
base.require('tracks.async_slice_group_track');
base.require('filter');
base.require('ui');

base.exportTo('tracing.tracks', function() {

  /**
   * Visualizes a Thread using a series of of SliceTracks.
   * @constructor
   */
  var ThreadTrack = tracing.ui.define(tracing.tracks.ContainerTrack);
  ThreadTrack.prototype = {
    __proto__: tracing.tracks.ContainerTrack.prototype,

    decorate: function() {
      this.classList.add('thread-track');
      this.categoryFilter_ = new tracing.Filter();
    },

    get thread() {
      return this.thread_;
    },

    set thread(thread) {
      this.thread_ = thread;
      this.updateChildTracks_();
    },

    get tooltip() {
      return this.tooltip_;
    },

    set tooltip(value) {
      this.tooltip_ = value;
      this.updateChildTracks_();
    },

    get heading() {
      return this.heading_;
    },

    set heading(h) {
      this.heading_ = h;
      this.updateChildTracks_();
    },

    applyCategoryFilter_: function() {
      this.updateVisibility_();
    },

    updateChildTracks_: function() {
      this.detach();
      if (this.thread_) {
        var cpuTrack = new tracing.tracks.SliceTrack();
        cpuTrack.heading = '';
        cpuTrack.slices = this.thread_.cpuSlices;
        cpuTrack.height = '4px';
        cpuTrack.decorateHit = function(hit) {
          hit.thread = this.thread_;
        }
        this.addTrack_(cpuTrack);

        var asyncTrack = new tracing.tracks.AsyncSliceGroupTrack();
        asyncTrack.categoryFilter = this.categoryFilter;
        asyncTrack.decorateHit = function(hit) {
          // TODO(simonjam): figure out how to associate subSlice hits back
          // to their parent slice.
        }
        asyncTrack.group = this.thread_.asyncSlices;
        this.addTrack_(asyncTrack);

        var track = new tracing.tracks.SliceGroupTrack();
        track.decorateHit = function(hit) {
          hit.thread = this.thread_;
        }
        track.group = this.thread_;
        this.addTrack_(track);

        if (this.thread_.samples.length) {
          var samplesTrack = new tracing.tracks.SliceTrack();
          samplesTrack.group = this.thread_;
          samplesTrack.slices = this.thread_.samples;
          samplesTrack.decorateHit = function(hit) {
            // TODO(johnmccutchan): Figure out what else should be associated
            // with the hit.
            hit.thread = this.thread_;
          }
          this.addTrack_(samplesTrack);
        }

        this.updateVisibility_();
      }
      this.addControlButtonElements_(this.tracks_.length >= 4);
    },

    updateVisibility_: function() {
      if (!this.categoryFilter.matchThread(this.thread)) {
        this.visible = false;
        return;
      }
      var shouldBeVisible = false;
      for (var i = 0; i < this.tracks_.length; ++i) {
        var track = this.tracks_[i];
        if (track.visible) {
          shouldBeVisible = true;
          if (i >= 1) {
            track.heading = this.heading_;
            track.tooltip = this.tooltip_;
            break;
          }
        }
      }
      this.visible = shouldBeVisible;
    },

    collapsedDidChange: function(collapsed) {
      if (collapsed) {
        var h = parseInt(this.tracks_[0].height);
        for (var i = 0; i < this.tracks_.length; ++i) {
          if (h > 2) {
            this.tracks_[i].height = Math.floor(h) + 'px';
          } else {
            this.tracks_[i].style.display = 'none';
          }
          h = h * 0.5;
        }
      } else {
        for (var i = 0; i < this.tracks_.length; ++i) {
          this.tracks_[i].height = this.tracks_[0].height;
          this.tracks_[i].style.display = '';
        }
      }
    }
  };

  return {
    ThreadTrack: ThreadTrack
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

base.require('tracks.container_track');
base.require('tracks.counter_track');
base.require('tracks.thread_track');
base.require('filter');
base.require('ui');

base.exportTo('tracing.tracks', function() {

  /**
   * Visualizes a Process by building ThreadTracks and CounterTracks.
   * @constructor
   */
  var ProcessTrack =
      tracing.ui.define(tracing.tracks.ContainerTrack);

  ProcessTrack.prototype = {

    __proto__: tracing.tracks.ContainerTrack.prototype,

    decorate: function() {
      this.classList.add('process-track');
      this.categoryFilter_ = new tracing.Filter();
    },

    get process() {
      return this.process_;
    },

    set process(process) {
      this.process_ = process;
      this.updateChildTracks_();
    },

    applyCategoryFilter_: function() {
      this.visible = (this.categoryFilter.matchProcess(this.process) &&
                      !!this.numVisibleChildTracks);
    },

    updateChildTracks_: function() {
      this.detach();
      if (this.process_) {
        // Add counter tracks for this process.
        var counters = [];
        for (var tid in this.process.counters) {
          counters.push(this.process.counters[tid]);
        }
        counters.sort(tracing.model.Counter.compare);

        // Create the counters for this process.
        counters.forEach(function(counter) {
          var track = new tracing.tracks.CounterTrack();
          track.heading = counter.name + ':';
          track.counter = counter;
          this.addTrack_(track);
        }.bind(this));

        // Get a sorted list of threads.
        var threads = [];
        for (var tid in this.process.threads)
          threads.push(this.process.threads[tid]);
        threads.sort(tracing.model.Thread.compare);

        // Create the threads.
        threads.forEach(function(thread) {
          var track = new tracing.tracks.ThreadTrack();
          track.heading = thread.userFriendlyName + ':';
          track.tooltip = thread.userFriendlyDetails;
          track.thread = thread;
          this.addTrack_(track);
        }.bind(this));
      }
    }
  };

  return {
    ProcessTrack: ProcessTrack
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

base.requireStylesheet('tracks.model_track');
base.require('tracks.container_track');
base.require('tracks.cpu_track');
base.require('tracks.process_track');
base.require('ui');

base.exportTo('tracing.tracks', function() {

  /**
   * Visualizes a Model by building ProcessTracks and
   * CpuTracks.
   * @constructor
   */
  var ModelTrack = tracing.ui.define(tracing.tracks.ContainerTrack);

  ModelTrack.prototype = {

    __proto__: tracing.tracks.ContainerTrack.prototype,

    decorate: function() {
      this.classList.add('model-track');
      this.measuringStick_ = new tracing.MeasuringStick();
      this.measuringStick_.attach();
    },

    detach: function() {
      tracing.tracks.ContainerTrack.prototype.detach.call(this);
      this.measuringStick_.detach();
    },

    get model() {
      return this.model_;
    },

    set model(model) {
      this.model_ = model;
      this.updateHeadingWidth_();
      this.updateChildTracks_();
    },

    updateHeadingWidth_: function() {
      // Figure out all the headings.
      var allHeadings = [];
      this.model.getAllThreads().forEach(function(t) {
        allHeadings.push(t.userFriendlyName);
      });
      this.model.getAllCounters().forEach(function(c) {
        allHeadings.push(c.name);
      });
      this.model.getAllCpus().forEach(function(c) {
        allHeadings.push('CPU ' + c.cpuNumber);
      });

      // Figure out the maximum heading size.
      var maxHeadingWidth = 0;
      var headingEl = document.createElement('div');
      headingEl.style.position = 'fixed';
      headingEl.className = 'canvas-based-track-title';
      for (var i = 0; i < allHeadings.length; i++) {
        var text = allHeadings[i];
        headingEl.textContent = text + ':__';
        var w = this.measuringStick_.measure(headingEl).width;
        // Limit heading width to 300px.
        if (w > 300)
          w = 300;
        if (w > maxHeadingWidth)
          maxHeadingWidth = w;
      }
      this.headingWidth = maxHeadingWidth + 'px';
    },

    updateChildTracks_: function() {
      this.detachAllChildren();
      if (this.model_) {
        var cpus = this.model_.getAllCpus();
        cpus.sort(tracing.model.Cpu.compare);

        for (var i = 0; i < cpus.length; ++i) {
          var cpu = cpus[i];
          var track = new tracing.tracks.CpuTrack();
          track.heading = 'CPU ' + cpu.cpuNumber + ':';
          track.cpu = cpu;
          this.addTrack_(track);
        }

        // Get a sorted list of processes.
        var processes = this.model_.getAllProcesses();
        processes.sort(tracing.model.Process.compare);

        for (var i = 0; i < processes.length; ++i) {
          var process = processes[i];
          var track = new tracing.tracks.ProcessTrack();
          track.process = process;
          this.addTrack_(track);
        }
      }
    }
  };

  return {
    ModelTrack: ModelTrack
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

base.requireStylesheet('tracks.ruler_track');

base.require('tracks.track');
base.require('tracks.canvas_based_track');
base.require('ui');

base.exportTo('tracing.tracks', function() {

  /**
   * A track that displays the ruler.
   * @constructor
   * @extends {CanvasBasedTrack}
   */

  var RulerTrack = tracing.ui.define(tracing.tracks.CanvasBasedTrack);

  var logOf10 = Math.log(10);
  function log10(x) {
    return Math.log(x) / logOf10;
  }

  RulerTrack.prototype = {

    __proto__: tracing.tracks.CanvasBasedTrack.prototype,

    decorate: function() {
      this.classList.add('ruler-track');
      this.strings_secs_ = [];
      this.strings_msecs_ = [];
      this.addEventListener('mousedown', this.onMouseDown);
    },

    onMouseDown: function(e) {
      if (e.button != 0)
        return;
      this.placeAndBeginDraggingMarker(e.clientX);
    },


    placeAndBeginDraggingMarker: function(clientX) {
      var pixelRatio = window.devicePixelRatio || 1;
      var viewX = (clientX - this.canvasContainer_.offsetLeft) * pixelRatio;
      var worldX = this.viewport_.xViewToWorld(viewX);
      var marker = this.viewport_.findMarkerNear(worldX, 6);
      var createdMarker = false;
      var movedMarker = false;
      if (!marker) {
        marker = this.viewport_.addMarker(worldX);
        createdMarker = true;
      }
      marker.selected = true;

      var that = this;
      var onMouseMove = function(e) {
        var viewX = (e.clientX - that.canvasContainer_.offsetLeft) * pixelRatio;
        var worldX = that.viewport_.xViewToWorld(viewX);
        marker.positionWorld = worldX;
        movedMarker = true;
      };

      var onMouseUp = function(e) {
        marker.selected = false;
        if (!movedMarker && !createdMarker)
          that.viewport_.removeMarker(marker);
        document.removeEventListener('mouseup', onMouseUp);
        document.removeEventListener('mousemove', onMouseMove);
      };

      document.addEventListener('mouseup', onMouseUp);
      document.addEventListener('mousemove', onMouseMove);
    },

    drawLine_: function(ctx, x1, y1, x2, y2, color) {
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.closePath();
      ctx.strokeStyle = color;
      ctx.stroke();
    },

    drawArrow_: function(ctx, x1, y1, x2, y2, arrowWidth, color) {

      this.drawLine_(ctx, x1, y1, x2, y2, color);

      var dx = x2 - x1;
      var dy = y2 - y1;
      var len = Math.sqrt(dx * dx + dy * dy);
      var perc = (len - 10) / len;
      var bx = x1 + perc * dx;
      var by = y1 + perc * dy;
      var ux = dx / len;
      var uy = dy / len;
      var ax = uy * arrowWidth;
      var ay = -ux * arrowWidth;

      ctx.beginPath();
      ctx.fillStyle = color;
      ctx.moveTo(bx + ax, by + ay);
      ctx.lineTo(x2, y2);
      ctx.lineTo(bx - ax, by - ay);
      ctx.lineTo(bx + ax, by + ay);
      ctx.closePath();
      ctx.fill();
    },

    redraw: function() {
      var ctx = this.ctx_;
      var canvasW = this.canvas_.width;
      var canvasH = this.canvas_.height;

      ctx.clearRect(0, 0, canvasW, canvasH);

      // Culling parametrs.
      var vp = this.viewport_;
      var pixWidth = vp.xViewVectorToWorld(1);
      var viewLWorld = vp.xViewToWorld(0);
      var viewRWorld = vp.xViewToWorld(canvasW);

      var measurements = this.classList.contains(
          'ruler-track-with-distance-measurements');

      var rulerHeight = measurements ? canvasH / 2 : canvasH;

      for (var i = 0; i < vp.markers.length; ++i) {
        vp.markers[i].drawTriangle_(ctx, viewLWorld, viewRWorld,
                                    canvasH, rulerHeight, vp);
      }

      var pixelRatio = window.devicePixelRatio || 1;
      var idealMajorMarkDistancePix = 150 * pixelRatio;
      var idealMajorMarkDistanceWorld =
          vp.xViewVectorToWorld(idealMajorMarkDistancePix);

      var majorMarkDistanceWorld;
      var unit;
      var unitDivisor;
      var tickLabels;

      // The conservative guess is the nearest enclosing 0.1, 1, 10, 100, etc.
      var conservativeGuess =
          Math.pow(10, Math.ceil(log10(idealMajorMarkDistanceWorld)));

      // Once we have a conservative guess, consider things that evenly add up
      // to the conservative guess, e.g. 0.5, 0.2, 0.1 Pick the one that still
      // exceeds the ideal mark distance.
      var divisors = [10, 5, 2, 1];
      for (var i = 0; i < divisors.length; ++i) {
        var tightenedGuess = conservativeGuess / divisors[i];
        if (vp.xWorldVectorToView(tightenedGuess) < idealMajorMarkDistancePix)
          continue;
        majorMarkDistanceWorld = conservativeGuess / divisors[i - 1];
        break;
      }
      var tickLabels = undefined;
      if (majorMarkDistanceWorld < 100) {
        unit = 'ms';
        unitDivisor = 1;
        tickLabels = this.strings_msecs_;
      } else {
        unit = 's';
        unitDivisor = 1000;
        tickLabels = this.strings_secs_;
      }

      var numTicksPerMajor = 5;
      var minorMarkDistanceWorld = majorMarkDistanceWorld / numTicksPerMajor;
      var minorMarkDistancePx = vp.xWorldVectorToView(minorMarkDistanceWorld);

      var firstMajorMark =
          Math.floor(viewLWorld / majorMarkDistanceWorld) *
              majorMarkDistanceWorld;

      var minorTickH = Math.floor(canvasH * 0.25);

      ctx.fillStyle = 'rgb(0, 0, 0)';
      ctx.strokeStyle = 'rgb(0, 0, 0)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'top';

      var pixelRatio = window.devicePixelRatio || 1;
      ctx.font = (9 * pixelRatio) + 'px sans-serif';

      // Each iteration of this loop draws one major mark
      // and numTicksPerMajor minor ticks.
      //
      // Rendering can't be done in world space because canvas transforms
      // affect line width. So, do the conversions manually.
      for (var curX = firstMajorMark;
           curX < viewRWorld;
           curX += majorMarkDistanceWorld) {

        var curXView = Math.floor(vp.xWorldToView(curX));

        var unitValue = curX / unitDivisor;
        var roundedUnitValue = Math.floor(unitValue * 100000) / 100000;

        if (!tickLabels[roundedUnitValue])
          tickLabels[roundedUnitValue] = roundedUnitValue + ' ' + unit;
        ctx.fillText(tickLabels[roundedUnitValue],
                     curXView + 2 * pixelRatio, 0);
        ctx.beginPath();

        // Major mark
        ctx.moveTo(curXView, 0);
        ctx.lineTo(curXView, rulerHeight);

        // Minor marks
        for (var i = 1; i < numTicksPerMajor; ++i) {
          var xView = Math.floor(curXView + minorMarkDistancePx * i);
          ctx.moveTo(xView, rulerHeight - minorTickH);
          ctx.lineTo(xView, rulerHeight);
        }

        ctx.stroke();
      }

      // Give distance between directly adjacent markers.
      if (measurements) {

        // Divide canvas horizontally between ruler and measurements.
        ctx.moveTo(0, rulerHeight);
        ctx.lineTo(canvasW, rulerHeight);
        ctx.stroke();

        // Obtain a sorted array of markers
        var sortedMarkers = vp.markers.slice();
        sortedMarkers.sort(function(a, b) {
          return a.positionWorld_ - b.positionWorld_;
        });

        // Distance Variables.
        var displayDistance;
        var unitDivisor;
        var displayTextColor = 'rgb(0,0,0)';
        var measurementsPosY = rulerHeight + 2;

        // Arrow Variables.
        var arrowSpacing = 10;
        var arrowColor = 'rgb(128,121,121)';
        var arrowPosY = measurementsPosY + 4;
        var arrowWidthView = 3;
        var spaceForArrowsView = 2 * (arrowWidthView + arrowSpacing);

        for (i = 0; i < sortedMarkers.length - 1; i++) {
          var rightMarker = sortedMarkers[i + 1];
          var leftMarker = sortedMarkers[i];
          var distanceBetweenMarkers =
              rightMarker.positionWorld - leftMarker.positionWorld;
          var distanceBetweenMarkersView =
              vp.xWorldVectorToView(distanceBetweenMarkers);

          var positionInMiddleOfMarkers = leftMarker.positionWorld +
                                              distanceBetweenMarkers / 2;
          var positionInMiddleOfMarkersView =
              vp.xWorldToView(positionInMiddleOfMarkers);

          // Determine units.
          if (distanceBetweenMarkers < 100) {
            unit = 'ms';
            unitDivisor = 1;
          } else {
            unit = 's';
            unitDivisor = 1000;
          }
          // Calculate display value to print.
          displayDistance = distanceBetweenMarkers / unitDivisor;
          var roundedDisplayDistance =
              Math.abs((Math.floor(displayDistance * 1000) / 1000));
          var textToDraw = roundedDisplayDistance + ' ' + unit;
          var textWidthView = ctx.measureText(textToDraw).width;
          var textWidthWorld = vp.xViewVectorToWorld(textWidthView);
          var spaceForArrowsAndTextView = textWidthView +
                                          spaceForArrowsView + arrowSpacing;

          // Set text positions.
          var textLeft = leftMarker.positionWorld +
              (distanceBetweenMarkers / 2) - (textWidthWorld / 2);
          var textRight = textLeft + textWidthWorld;
          var textPosY = measurementsPosY;
          var textLeftView = vp.xWorldToView(textLeft);
          var textRightView = vp.xWorldToView(textRight);
          var leftMarkerView = vp.xWorldToView(leftMarker.positionWorld);
          var rightMarkerView = vp.xWorldToView(rightMarker.positionWorld);
          var textDrawn = false;

          if (spaceForArrowsAndTextView <= distanceBetweenMarkersView) {
            // Print the display distance text.
            ctx.fillStyle = displayTextColor;
            ctx.fillText(textToDraw, textLeftView, textPosY);
            textDrawn = true;
          }

          if (spaceForArrowsView <= distanceBetweenMarkersView) {
            var leftArrowStart;
            var rightArrowStart;
            if (textDrawn) {
              leftArrowStart = textLeftView - arrowSpacing;
              rightArrowStart = textRightView + arrowSpacing;
            } else {
              leftArrowStart = positionInMiddleOfMarkersView;
              rightArrowStart = positionInMiddleOfMarkersView;
            }
            // Draw left arrow.
            this.drawArrow_(ctx, leftArrowStart, arrowPosY,
                leftMarkerView, arrowPosY, arrowWidthView, arrowColor);
            // Draw right arrow.
            this.drawArrow_(ctx, rightArrowStart, arrowPosY,
                rightMarkerView, arrowPosY, arrowWidthView, arrowColor);
          }
        }
      }
    },

    /**
     * Adds items intersecting a point to a selection.
     * @param {number} vX X location to search at, in viewspace.
     * @param {number} vY Y location to search at, in viewspace.
     * @param {Selection} selection Selection to which to add hits.
     * @return {boolean} true if a slice was found, otherwise false.
     */
    addIntersectingItemsToSelection: function(vX, vY, selection) {
      // Does nothing. There's nothing interesting to pick on the ruler
      // track.
    },

    /**
     * Adds items intersecting the given range to a selection.
     * @param {number} loVX Lower X bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVX Upper X bound of the interval to search, in
     *     viewspace.
     * @param {number} loVY Lower Y bound of the interval to search, in
     *     viewspace.
     * @param {number} hiVY Upper Y bound of the interval to search, in
     *     viewspace.
     * @param {Selection} selection Selection to which to add hits.
     */
    addIntersectingItemsInRangeToSelection: function(
        loVX, hiVX, loY, hiY, selection) {
      // Does nothing. There's nothing interesting to pick on the ruler
      // track.
    },

    addAllObjectsMatchingFilterToSelection: function(filter, selection) {
    }
  };

  return {
    RulerTrack: RulerTrack
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Interactive visualizaiton of Model objects
 * based loosely on gantt charts. Each thread in the Model is given a
 * set of Tracks, one per subrow in the thread. The TimelineTrackView class
 * acts as a controller, creating the individual tracks, while Tracks
 * do actual drawing.
 *
 * Visually, the TimelineTrackView produces (prettier) visualizations like the
 * following:
 *    Thread1:  AAAAAAAAAA         AAAAA
 *                  BBBB              BB
 *    Thread2:     CCCCCC                 CCCCC
 *
 */
base.requireStylesheet('timeline_track_view');
base.require('event_target');
base.require('measuring_stick');
base.require('filter');
base.require('selection');
base.require('timeline_viewport');
base.require('tracks.model_track');
base.require('tracks.ruler_track');
base.require('ui');

base.exportTo('tracing', function() {

  var Selection = tracing.Selection;
  var Viewport = tracing.TimelineViewport;

  function intersectRect_(r1, r2) {
    var results = new Object;
    if (r2.left > r1.right || r2.right < r1.left ||
         r2.top > r1.bottom || r2.bottom < r1.top) {
      return false;
    }
    results.left = Math.max(r1.left, r2.left);
    results.top = Math.max(r1.top, r2.top);
    results.right = Math.min(r1.right, r2.right);
    results.bottom = Math.min(r1.bottom, r2.bottom);
    results.width = (results.right - results.left);
    results.height = (results.bottom - results.top);
    return results;
  }

  /**
   * Renders a Model into a div element, making one
   * Track for each subrow in each thread of the model, managing
   * overall track layout, and handling user interaction with the
   * viewport.
   *
   * @constructor
   * @extends {HTMLDivElement}
   */
  var TimelineTrackView = tracing.ui.define('div');

  TimelineTrackView.prototype = {
    __proto__: HTMLDivElement.prototype,

    model_: null,

    decorate: function() {
      this.classList.add('timeline-track-view');

      this.categoryFilter_ = new tracing.CategoryFilter();

      this.viewport_ = new Viewport(this);

      // Add the viewport track.
      this.rulerTrack_ = new tracing.tracks.RulerTrack();
      this.rulerTrack_.viewport = this.viewport_;
      this.appendChild(this.rulerTrack_);

      this.modelTrackContainer_ = document.createElement('div');
      this.modelTrackContainer_.className = 'model-track-container';
      this.appendChild(this.modelTrackContainer_);

      this.modelTrack_ = new tracing.tracks.ModelTrack();
      this.modelTrackContainer_.appendChild(this.modelTrack_);

      this.dragBox_ = this.ownerDocument.createElement('div');
      this.dragBox_.className = 'drag-box';
      this.appendChild(this.dragBox_);
      this.hideDragBox_();

      this.bindEventListener_(document, 'keypress', this.onKeypress_, this);
      this.bindEventListener_(document, 'keydown', this.onKeydown_, this);
      this.bindEventListener_(document, 'keyup', this.onKeyup_, this);
      this.bindEventListener_(document, 'mousemove', this.onMouseMove_, this);
      this.bindEventListener_(document, 'mouseup', this.onMouseUp_, this);

      this.addEventListener('mousewheel', this.onMouseWheel_);
      this.addEventListener('mousedown', this.onMouseDown_);
      this.addEventListener('dblclick', this.onDblClick_);

      this.lastMouseViewPos_ = {x: 0, y: 0};
      this.maxHeadingWidth_ = 0;

      this.selection_ = new Selection();
    },

    /**
     * Wraps the standard addEventListener but automatically binds the provided
     * func to the provided target, tracking the resulting closure. When detach
     * is called, these listeners will be automatically removed.
     */
    bindEventListener_: function(object, event, func, target) {
      if (!this.boundListeners_)
        this.boundListeners_ = [];
      var boundFunc = func.bind(target);
      this.boundListeners_.push({object: object,
        event: event,
        boundFunc: boundFunc});
      object.addEventListener(event, boundFunc);
    },

    detach: function() {
      this.modelTrack_.detach();

      for (var i = 0; i < this.boundListeners_.length; i++) {
        var binding = this.boundListeners_[i];
        binding.object.removeEventListener(binding.event, binding.boundFunc);
      }
      this.boundListeners_ = undefined;
      this.viewport_.detach();
    },

    get viewport() {
      return this.viewport_;
    },

    get categoryFilter() {
      return this.categoryFilter_;
    },

    set categoryFilter(filter) {
      this.categoryFilter_ = filter;
      this.modelTrack_.categoryFilter = filter;
    },

    get model() {
      return this.model_;
    },

    set model(model) {
      if (!model)
        throw new Error('Model cannot be null');

      var modelInstanceChanged = this.model_ != model;
      this.model_ = model;
      this.modelTrack_.model = model;
      this.modelTrack_.viewport = this.viewport_;
      this.modelTrack_.categoryFilter = this.categoryFilter;
      this.rulerTrack_.headingWidth = this.modelTrack_.headingWidth;

      // Set up a reasonable viewport.
      if (modelInstanceChanged)
        this.viewport_.setWhenPossible(this.setInitialViewport_.bind(this));
    },

    get numVisibleTracks() {
      return this.modelTrack_.numVisibleTracks;
    },

    setInitialViewport_: function() {
      var w = this.firstCanvas.width;
      var boost =
          (this.model_.bounds.max - this.model_.bounds.min) * 0.15;
      this.viewport_.xSetWorldBounds(this.model_.bounds.min - boost,
                                    this.model_.bounds.max + boost,
                                    w);
    },

    /**
     * @param {Filter} filter The filter to use for finding matches.
     * @param {Selection} selection The selection to add matches to.
     * @return {Array} An array of objects that match the provided
     * TitleFilter.
     */
    addAllObjectsMatchingFilterToSelection: function(filter, selection) {
      this.modelTrack_.addAllObjectsMatchingFilterToSelection(filter,
                                                              selection);
    },

    /**
     * @return {Element} The element whose focused state determines
     * whether to respond to keyboard inputs.
     * Defaults to the parent element.
     */
    get focusElement() {
      if (this.focusElement_)
        return this.focusElement_;
      return this.parentElement;
    },

    /**
     * Sets the element whose focus state will determine whether
     * to respond to keybaord input.
     */
    set focusElement(value) {
      this.focusElement_ = value;
    },

    get listenToKeys_() {
      if (!this.viewport_.isAttachedToDocument_)
        return false;
      if (this.activeElement instanceof tracing.FindControl)
        return false;
      if (!this.focusElement_)
        return true;
      if (this.focusElement.tabIndex >= 0)
        return document.activeElement == this.focusElement;
      return true;
    },

    onKeypress_: function(e) {
      var vp = this.viewport_;
      if (!this.firstCanvas)
        return;
      if (!this.listenToKeys_)
        return;
      if (document.activeElement.nodeName == 'INPUT')
        return;
      var viewWidth = this.firstCanvas.clientWidth;
      var curMouseV, curCenterW;
      switch (e.keyCode) {
        case 119:  // w
        case 44:   // ,
          this.zoomBy_(1.5);
          break;
        case 115:  // s
        case 111:  // o
          this.zoomBy_(1 / 1.5);
          break;
        case 103:  // g
          this.onGridToggle_(true);
          break;
        case 71:  // G
          this.onGridToggle_(false);
          break;
        case 87:  // W
        case 60:  // <
          this.zoomBy_(10);
          break;
        case 83:  // S
        case 79:  // O
          this.zoomBy_(1 / 10);
          break;
        case 97:  // a
          vp.panX += vp.xViewVectorToWorld(viewWidth * 0.1);
          break;
        case 100:  // d
        case 101:  // e
          vp.panX -= vp.xViewVectorToWorld(viewWidth * 0.1);
          break;
        case 65:  // A
          vp.panX += vp.xViewVectorToWorld(viewWidth * 0.5);
          break;
        case 68:  // D
          vp.panX -= vp.xViewVectorToWorld(viewWidth * 0.5);
          break;
        case 48:  // 0
        case 122: // z
          this.setInitialViewport_();
          break;
        case 102:  // f
          this.zoomToSelection_();
          break;
      }
    },

    onMouseWheel_: function(e) {
      if (e.altKey) {
        var delta = e.wheelDeltaY / 120;
        var zoomScale = Math.pow(1.5, delta);
        this.zoomBy_(zoomScale);
        e.preventDefault();
      }
    },

    // Not all keys send a keypress.
    onKeydown_: function(e) {
      if (!this.listenToKeys_)
        return;
      var sel;
      var vp = this.viewport_;
      var viewWidth = this.firstCanvas.clientWidth;
      switch (e.keyCode) {
        case 37:   // left arrow
          sel = this.selection.getShiftedSelection(-1);
          if (sel) {
            this.setSelectionAndMakeVisible(sel);
            e.preventDefault();
          } else {
            if (!this.firstCanvas)
              return;
            vp.panX += vp.xViewVectorToWorld(viewWidth * 0.1);
          }
          break;
        case 39:   // right arrow
          sel = this.selection.getShiftedSelection(1);
          if (sel) {
            this.setSelectionAndMakeVisible(sel);
            e.preventDefault();
          } else {
            if (!this.firstCanvas)
              return;
            vp.panX -= vp.xViewVectorToWorld(viewWidth * 0.1);
          }
          break;
        case 9:    // TAB
          if (this.focusElement.tabIndex == -1) {
            if (e.shiftKey)
              this.selectPrevious_(e);
            else
              this.selectNext_(e);
            e.preventDefault();
          }
          break;
      }
      if (e.shiftKey && this.dragBeginEvent_) {
          var vertical = e.shiftKey;
          if (this.dragBeginEvent_) {
            this.setDragBoxPosition_(this.dragBoxXStart_, this.dragBoxYStart_,
                               this.dragBoxXEnd_, this.dragBoxYEnd_, vertical);
          }
      }
    },

    onKeyup_: function(e) {
      if (!this.listenToKeys_)
        return;
      if (!e.shiftKey) {
        if (this.dragBeginEvent_) {
          var vertical = e.shiftKey;
          this.setDragBoxPosition_(this.dragBoxXStart_, this.dragBoxYStart_,
                                this.dragBoxXEnd_, this.dragBoxYEnd_, vertical);
          }
      }
    },

    /**
     * Zoom in or out on the timeline by the given scale factor.
     * @param {integer} scale The scale factor to apply.  If <1, zooms out.
     */
    zoomBy_: function(scale) {
      if (!this.firstCanvas)
        return;
      var vp = this.viewport_;
      var viewWidth = this.firstCanvas.clientWidth;
      var pixelRatio = window.devicePixelRatio || 1;
      var curMouseV = this.lastMouseViewPos_.x * pixelRatio;
      var curCenterW = vp.xViewToWorld(curMouseV);
      vp.scaleX = vp.scaleX * scale;
      vp.xPanWorldPosToViewPos(curCenterW, curMouseV, viewWidth);
    },

    /**
     * Zoom into the current selection.
     */
    zoomToSelection_: function() {
      if (!this.selection)
        return;
      var bounds = this.selection.bounds;
      var worldCenter = bounds.min + (bounds.max - bounds.min) * 0.5;
      var worldBounds = (bounds.max - bounds.min) * 0.5;
      var boost = worldBounds * 0.15;
      this.viewport_.xSetWorldBounds(worldCenter - worldBounds - boost,
                                    worldCenter + worldBounds + boost,
                                    this.firstCanvas.width);
    },

    get keyHelp() {
      var mod = navigator.platform.indexOf('Mac') == 0 ? 'cmd' : 'ctrl';
      var help = 'Qwerty Controls\n' +
          ' w/s           : Zoom in/out    (with shift: go faster)\n' +
          ' a/d           : Pan left/right\n\n' +
          'Dvorak Controls\n' +
          ' ,/o           : Zoom in/out     (with shift: go faster)\n' +
          ' a/e           : Pan left/right\n\n' +
          'Mouse Controls\n' +
          ' drag          : Select slices   (with ' + mod +
                                                        ': zoom to slices)\n' +
          ' drag + shift  : Select all slices vertically\n\n';

      if (this.focusElement.tabIndex) {
        help +=
          ' <-            : Select previous event on current timeline\n' +
          ' ->            : Select next event on current timeline\n';
      } else {
        help += 'General Navigation\n' +
          ' g/General     : Shows grid at the start/end of the selected' +
                                                                  ' task\n' +
          ' <-,^TAB       : Select previous event on current timeline\n' +
          ' ->, TAB       : Select next event on current timeline\n';
      }
      help +=
          '\n' +
          'Alt + Scroll to zoom in/out\n' +
          'Dbl-click to zoom in; Shift dbl-click to zoom out\n' +
          'f to zoom into selection\n' +
          'z to reset zoom and pan to initial view\n';
      return help;
    },

    get selection() {
      return this.selection_;
    },

    set selection(selection) {
      if (!(selection instanceof Selection))
        throw new Error('Expected Selection');

      // Clear old selection.
      var i;
      for (i = 0; i < this.selection_.length; i++)
        this.selection_[i].selected = false;

      this.selection_ = selection;

      base.dispatchSimpleEvent(this, 'selectionChange');
      for (i = 0; i < this.selection_.length; i++)
        this.selection_[i].selected = true;
      this.viewport_.dispatchChangeEvent(); // Triggers a redraw.
    },

    setSelectionAndMakeVisible: function(selection, zoomAllowed) {
      if (!(selection instanceof Selection))
        throw new Error('Expected Selection');
      this.selection = selection;
      var bounds = this.selection.bounds;
      var size = this.viewport_.xWorldVectorToView(bounds.max - bounds.min);
      if (zoomAllowed && size < 50) {
        var worldCenter = bounds.min + (bounds.max - bounds.min) * 0.5;
        var worldBounds = (bounds.max - bounds.min) * 5;
        this.viewport_.xSetWorldBounds(worldCenter - worldBounds * 0.5,
                                      worldCenter + worldBounds * 0.5,
                                      this.firstCanvas.width);
        return;
      }

      this.viewport_.xPanWorldBoundsIntoView(bounds.min, bounds.max,
                                            this.firstCanvas.width);
    },

    get firstCanvas() {
      if (this.rulerTrack_)
        return this.rulerTrack_.firstCanvas;
      if (this.modelTrack_)
        return this.modelTrack_.firstCanvas;
      return undefined;
    },

    hideDragBox_: function() {
      this.dragBox_.style.left = '-1000px';
      this.dragBox_.style.top = '-1000px';
      this.dragBox_.style.width = 0;
      this.dragBox_.style.height = 0;
    },

    setDragBoxPosition_: function(xStart, yStart, xEnd, yEnd, vertical) {
      var loY;
      var hiY;
      var loX = Math.min(xStart, xEnd);
      var hiX = Math.max(xStart, xEnd);
      var modelTrackRect = this.modelTrack_.getBoundingClientRect();

      if (vertical) {
        loY = modelTrackRect.top;
        hiY = modelTrackRect.bottom;
      } else {
        loY = Math.min(yStart, yEnd);
        hiY = Math.max(yStart, yEnd);
      }

      var dragRect = {left: loX, top: loY, width: hiX - loX, height: hiY - loY};
      dragRect.right = dragRect.left + dragRect.width;
      dragRect.bottom = dragRect.top + dragRect.height;
      var modelTrackContainerRect =
                              this.modelTrackContainer_.getBoundingClientRect();
      var clipRect = {
        left: modelTrackContainerRect.left,
        top: modelTrackContainerRect.top,
        right: modelTrackContainerRect.right,
        bottom: modelTrackContainerRect.bottom,
      };
      var trackTitleWidth = parseInt(this.modelTrack_.headingWidth);
      clipRect.left = clipRect.left + trackTitleWidth;

      var finalDragBox = intersectRect_(clipRect, dragRect);

      this.dragBox_.style.left = finalDragBox.left + 'px';
      this.dragBox_.style.width = finalDragBox.width + 'px';
      this.dragBox_.style.top = finalDragBox.top + 'px';
      this.dragBox_.style.height = finalDragBox.height + 'px';

      var pixelRatio = window.devicePixelRatio || 1;
      var canv = this.firstCanvas;
      var loWX = this.viewport_.xViewToWorld(
          (loX - canv.offsetLeft) * pixelRatio);
      var hiWX = this.viewport_.xViewToWorld(
          (hiX - canv.offsetLeft) * pixelRatio);

      var roundedDuration = Math.round((hiWX - loWX) * 100) / 100;
      this.dragBox_.textContent = roundedDuration + 'ms';

      var e = new base.Event('selectionChanging');
      e.loWX = loWX;
      e.hiWX = hiWX;
      this.dispatchEvent(e);
    },

    onGridToggle_: function(left) {
      var tb;
      if (left)
        tb = this.selection_.bounds.min;
      else
        tb = this.selection_.bounds.max;

      // Shift the timebase left until its just left of model_.bounds.min.
      var numInterfvalsSinceStart = Math.ceil((tb - this.model_.bounds.min) /
          this.viewport_.gridStep_);
      this.viewport_.gridTimebase = tb -
          (numInterfvalsSinceStart + 1) * this.viewport_.gridStep_;
      this.viewport_.gridEnabled = true;
    },

    isChildOfThis_: function(el) {
      if (el == this)
        return;

      var isChildOfThis = false;
      var cur = el;
      while (cur.parentNode) {
        if (cur == this)
          return true;
        cur = cur.parentNode;
      }
      return false;
    },

    onMouseDown_: function(e) {
      if (e.button !== 0)
        return;

      if (e.shiftKey) {
        this.rulerTrack_.placeAndBeginDraggingMarker(e.clientX);
        return;
      }

      var canv = this.firstCanvas;
      var rect = this.modelTrack_.getBoundingClientRect();
      var canvRect = this.firstCanvas.getBoundingClientRect();

      var inside = rect &&
          e.clientX >= rect.left &&
          e.clientX < rect.right &&
          e.clientY >= rect.top &&
          e.clientY < rect.bottom &&
          e.clientX >= canvRect.left &&
          e.clientX < canvRect.right;

      if (!inside)
        return;

      var pos = {
        x: e.clientX - canv.offsetLeft,
        y: e.clientY - canv.offsetTop
      };

      var wX = this.viewport_.xViewToWorld(pos.x);

      this.dragBeginEvent_ = e;
      e.preventDefault();
      if (document.activeElement)
        document.activeElement.blur();
      if (this.focusElement.tabIndex >= 0)
        this.focusElement.focus();
    },

    onMouseMove_: function(e) {
      if (!this.firstCanvas)
        return;
      var canv = this.firstCanvas;
      var pos = {
        x: e.clientX - canv.offsetLeft,
        y: e.clientY - canv.offsetTop
      };

      // Remember position. Used during keyboard zooming.
      this.lastMouseViewPos_ = pos;

      // Update the drag box
      if (this.dragBeginEvent_) {
        this.dragBoxXStart_ = this.dragBeginEvent_.clientX;
        this.dragBoxXEnd_ = e.clientX;
        this.dragBoxYStart_ = this.dragBeginEvent_.clientY;
        this.dragBoxYEnd_ = e.clientY;
        var vertical = e.shiftKey;
        this.setDragBoxPosition_(this.dragBoxXStart_, this.dragBoxYStart_,
                                this.dragBoxXEnd_, this.dragBoxYEnd_, vertical);
      }
    },

    onMouseUp_: function(e) {
      var i;
      if (this.dragBeginEvent_) {
        // Stop the dragging.
        this.hideDragBox_();
        var eDown = this.dragBeginEvent_;
        this.dragBeginEvent_ = null;

        // Figure out extents of the drag.
        var loY;
        var hiY;
        var loX = Math.min(eDown.clientX, e.clientX);
        var hiX = Math.max(eDown.clientX, e.clientX);
        var tracksContainer = this.modelTrackContainer_.getBoundingClientRect();
        var topBoundary = tracksContainer.height;
        var vertical = e.shiftKey;
        if (vertical) {
          var modelTrackRect = this.modelTrack_.getBoundingClientRect();
          loY = modelTrackRect.top;
          hiY = modelTrackRect.bottom;
        } else {
          loY = Math.min(eDown.clientY, e.clientY);
          hiY = Math.max(eDown.clientY, e.clientY);
        }

        // Convert to worldspace.
        var canv = this.firstCanvas;
        var loVX = loX - canv.offsetLeft;
        var hiVX = hiX - canv.offsetLeft;

        // Figure out what has been hit.
        var selection = new Selection();
        this.modelTrack_.addIntersectingItemsInRangeToSelection(
            loVX, hiVX, loY, hiY, selection);

        // Activate the new selection, and zoom if ctrl key held down.
        this.selection = selection;
        if ((base.isMac && e.metaKey) || (!base.isMac && e.ctrlKey)) {
          this.zoomToSelection_();
        }
      }
    },

    onDblClick_: function(e) {
      var modelTrackContainerRect =
                              this.modelTrackContainer_.getBoundingClientRect();
      var clipBounds = {
        left: modelTrackContainerRect.left,
        right: modelTrackContainerRect.right,
      };
      var trackTitleWidth = parseInt(this.modelTrack_.headingWidth);
      clipBounds.left = clipBounds.left + trackTitleWidth;

      if (e.clientX < clipBounds.left || e.clientX > clipBounds.right)
        return;

      var canv = this.firstCanvas;

      var scale = 4;
      if (e.shiftKey)
        scale = 1 / scale;
      this.zoomBy_(scale);
      e.preventDefault();
    }
  };

  /**
   * The Model being viewed by the timeline
   * @type {Model}
   */
  base.defineProperty(TimelineTrackView, 'model', base.PropertyKind.JS);

  return {
    TimelineTrackView: TimelineTrackView
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Helper functions for use in selection_analysis files
 */

base.exportTo('tracing.analysis', function() {

  function tsRound(ts) {
    return Math.round(ts * 1000.0) / 1000.0;
  }

  return {
    tsRound: tsRound
  };

});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Analysis summarizes info about the selected slices
 * to the analysis panel.
 */
base.require('analysis.util');
base.require('ui');
base.requireStylesheet('timeline_analysis_view');
base.exportTo('tracing', function() {

  var AnalysisResults = tracing.ui.define('div');

  AnalysisResults.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate: function() {
    },

    appendElement_: function(parent, tagName, opt_text) {
      var n = parent.ownerDocument.createElement(tagName);
      parent.appendChild(n);
      if (opt_text != undefined)
        n.textContent = opt_text;
      return n;
    },

    appendText_: function(parent, text) {
      var textElement = parent.ownerDocument.createTextNode(text);
      parent.appendChild(textNode);
      return textNode;
    },

    appendTableCell_: function(table, row, cellnum, text) {
      var td = this.appendElement_(row, 'td', text);
      td.className = table.className + '-col-' + cellnum;
      return td;
    },

    appendTableCellWithTooltip_: function(table, row, cellnum, text, tooltip) {
      if (tooltip) {
        var td = this.appendElement_(row, 'td');
        td.className = table.className + '-col-' + cellnum;
        var span = this.appendElement_(td, 'span', text);
        span.className = 'tooltip';
        span.title = tooltip;
        return td;
      } else {
        this.appendTableCell_(table, row, cellnum, text);
      }
    },

    /**
     * Adds a table with the given className.
     * @return {HTMLTableElement} The newly created table.
     */
    appendTable: function(className, numColumns) {
      var table = this.appendElement_(this, 'table');
      table.className = className + ' analysis-table';
      table.numColumns = numColumns;
      return table;
    },

    /**
     * Creates and appends a row to |table| with a left-aligned |label]
     * header that spans all columns.
     */
    appendTableHeader: function(table, label) {
      var row = this.appendElement_(table, 'tr');

      var th = this.appendElement_(row, 'th', label);
      th.className = 'analysis-table-header';
    },

    /**
     * Creates and appends a row to |table| with a left-aligned |label]
     * in the first column and an optional |opt_text| value in the second
     * column.
     */
    appendSummaryRow: function(table, label, opt_text) {
      var row = this.appendElement_(table, 'tr');
      row.className = 'analysis-table-row';

      this.appendTableCell_(table, row, 0, label);
      if (opt_text !== undefined) {
        if (opt_text[0] == '{' && opt_text[opt_text.length - 1] == '}') {
          // Try to treat the opt_text as json.
          var value;
          try {
            value = JSON.parse(opt_text)
          } catch(e) {
            value = undefined;
          }
          if (!value === undefined) {
            this.appendTableCell_(table, row, 1, opt_text);
          } else {
            var pretty = JSON.stringify(value, null, ' ');
            this.appendTableCell_(table, row, 1, pretty);
          }
        } else {
          this.appendTableCell_(table, row, 1, opt_text);
        }
        for (var i = 2; i < table.numColumns; i++)
          this.appendTableCell_(table, row, i, '');
      } else {
        for (var i = 1; i < table.numColumns; i++)
          this.appendTableCell_(table, row, 1, '');
      }
    },

    /**
     * Adds a spacing row to spread out results.
     */
    appendSpacingRow: function(table) {
      var row = this.appendElement_(table, 'tr');
      row.className = 'analysis-table-row';
      for (var i = 0; i < table.numColumns; i++)
        this.appendTableCell_(table, row, i, ' ');
    },

    /**
     * Creates and appends a row to |table| with a left-aligned |label]
     * in the first column and a millisecvond |time| value in the second
     * column.
     */
    appendSummaryRowTime: function(table, label, time) {
      this.appendSummaryRow(table, label,
                            tracing.analysis.tsRound(time) + ' ms');
    },

    /**
     * Creates and appends a row to |table| that summarizes one or more slices,
     * or one or more counters.
     * The row has a left-aligned |label| in the first column, the |duration|
     * of the data in the second, the number of |occurrences| in the third.
     * @param {object} opt_statistics May be undefined, or an object which
     * contains calculated staistics containing min/max/avg for slices, or
     * min/max/avg/start/end for counters.
     */
    appendDataRow: function(
        table, label, opt_duration, opt_occurences, opt_statistics) {

      var tooltip = undefined;
      if (opt_statistics) {
        tooltip = 'Min Duration:\u0009' +
                  tracing.analysis.tsRound(opt_statistics.min) +
                  ' ms \u000DMax Duration:\u0009' +
                  tracing.analysis.tsRound(opt_statistics.max) +
                  ' ms \u000DAvg Duration:\u0009' +
                  tracing.analysis.tsRound(opt_statistics.avg) +
                  ' ms (\u03C3 = ' +
                  tracing.analysis.tsRound(opt_statistics.avg_stddev) + ')';

        if (opt_statistics.start) {
          tooltip += '\u000DStart Time:\u0009' +
              tracing.analysis.tsRound(opt_statistics.start) + ' ms';
        }
        if (opt_statistics.end) {
          tooltip += '\u000DEnd Time:\u0009' +
              tracing.analysis.tsRound(opt_statistics.end) + ' ms';
        }
        if (opt_statistics.frequency && opt_statistics.frequency_stddev) {
          tooltip += '\u000DFrequency:\u0009' +
              tracing.analysis.tsRound(opt_statistics.frequency) +
              ' occurrences/s (\u03C3 = ' +
              tracing.analysis.tsRound(opt_statistics.frequency_stddev) + ')';
        }
      }

      var row = this.appendElement_(table, 'tr');
      row.className = 'analysis-table-row';

      this.appendTableCellWithTooltip_(table, row, 0, label, tooltip);

      if (opt_duration !== undefined) {
        this.appendTableCellWithTooltip_(table, row, 1,
            tracing.analysis.tsRound(opt_duration) + ' ms', tooltip);
      } else {
        this.appendTableCell_(table, row, 1, '');
      }

      if (opt_occurences !== undefined) {
        this.appendTableCellWithTooltip_(table, row, 2,
            String(opt_occurences) + ' occurrences', tooltip);

      } else {
        this.appendTableCell_(table, row, 2, '');
      }
    }
  };

  /**
   * Analyzes the selection, outputting the analysis results into the provided
   * results object.
   *
   * @param {AnalysisResults} results Where the analysis is placed.
   * @param {Selection} selection What to analyze.
   */
  function analyzeSelection(results, selection) {

    var sliceHits = selection.getSliceHitsAsSelection();
    var counterSampleHits = selection.getCounterSampleHitsAsSelection();

    if (sliceHits.length == 1) {
      var slice = sliceHits[0].slice;
      var table = results.appendTable('analysis-slice-table', 2);

      results.appendTableHeader(table, 'Selected slice:');
      results.appendSummaryRow(table, 'Title', slice.title);

      if (slice.category)
        results.appendSummaryRow(table, 'Category', slice.category);

      results.appendSummaryRowTime(table, 'Start', slice.start);
      results.appendSummaryRowTime(table, 'Duration', slice.duration);

      if (slice.durationInUserTime) {
        results.appendSummaryRowTime(
            table, 'Duration (U)', slice.durationInUserTime);
      }

      var n = 0;
      for (var argName in slice.args) {
        n += 1;
      }
      if (n > 0) {
        results.appendSummaryRow(table, 'Args');
        for (var argName in slice.args) {
          var argVal = slice.args[argName];
          // TODO(sleffler) use span instead?
          results.appendSummaryRow(table, ' ' + argName, argVal);
        }
      }
    } else if (sliceHits.length > 1) {
      var tsLo = sliceHits.bounds.min;
      var tsHi = sliceHits.bounds.max;

      // compute total sliceHits duration
      var titles = sliceHits.map(function(i) { return i.slice.title; });

      var numTitles = 0;
      var slicesByTitle = {};
      for (var i = 0; i < sliceHits.length; i++) {
        var slice = sliceHits[i].slice;
        if (!slicesByTitle[slice.title]) {
          slicesByTitle[slice.title] = {
            slices: []
          };
          numTitles++;
        }
        slicesByTitle[slice.title].slices.push(slice);
      }

      var table;
      table = results.appendTable('analysis-slices-table', 3);
      results.appendTableHeader(table, 'Slices:');

      var totalDuration = 0;
      for (var sliceGroupTitle in slicesByTitle) {
        var sliceGroup = slicesByTitle[sliceGroupTitle];
        var duration = 0;
        var avg = 0;
        var startOfFirstOccurrence = Number.MAX_VALUE;
        var startOfLastOccurrence = -Number.MAX_VALUE;
        var frequencyDetails = undefined;
        var min = Number.MAX_VALUE;
        var max = -Number.MAX_VALUE;
        for (var i = 0; i < sliceGroup.slices.length; i++) {
          duration += sliceGroup.slices[i].duration;
          startOfFirstOccurrence = Math.min(sliceGroup.slices[i].start,
                                            startOfFirstOccurrence);
          startOfLastOccurrence = Math.max(sliceGroup.slices[i].start,
              startOfLastOccurrence);
          min = Math.min(sliceGroup.slices[i].duration, min);
          max = Math.max(sliceGroup.slices[i].duration, max);
        }

        totalDuration += duration;

        if (sliceGroup.slices.length == 0)
          avg = 0;
        avg = duration / sliceGroup.slices.length;

        var details = {min: min,
          max: max,
          avg: avg,
          avg_stddev: undefined,
          frequency: undefined,
          frequency_stddev: undefined};

        // Compute the stddev of the slice durations.
        var sumOfSquaredDistancesToMean = 0;
        for (var i = 0; i < sliceGroup.slices.length; i++) {
          var signedDistance = details.avg - sliceGroup.slices[i].duration;
          sumOfSquaredDistancesToMean += signedDistance * signedDistance;
        }

        details.avg_stddev = Math.sqrt(
            sumOfSquaredDistancesToMean / (sliceGroup.slices.length - 1));

        // We require at least 3 samples to compute the stddev.
        var elapsed = startOfLastOccurrence - startOfFirstOccurrence;
        if (sliceGroup.slices.length > 2 && elapsed > 0) {
          var numDistances = sliceGroup.slices.length - 1;
          details.frequency = (1000 * numDistances) / elapsed;

          // Compute the stddev.
          sumOfSquaredDistancesToMean = 0;
          for (var i = 1; i < sliceGroup.slices.length; i++) {
            var currentFrequency = 1000 /
                (sliceGroup.slices[i].start - sliceGroup.slices[i - 1].start);
            var signedDistance = details.frequency - currentFrequency;
            sumOfSquaredDistancesToMean += signedDistance * signedDistance;
          }

          details.frequency_stddev = Math.sqrt(
              sumOfSquaredDistancesToMean / (numDistances - 1));
        }
        results.appendDataRow(
            table, sliceGroupTitle, duration, sliceGroup.slices.length,
            details);
      }
      results.appendDataRow(table, '*Totals', totalDuration, sliceHits.length);
      results.appendSpacingRow(table);
      results.appendSummaryRowTime(table, 'Selection start', tsLo);
      results.appendSummaryRowTime(table, 'Selection extent', tsHi - tsLo);
    }

    if (counterSampleHits.length == 1) {
      var hit = counterSampleHits[0];
      var ctr = hit.counter;
      var sampleIndex = hit.sampleIndex;
      var values = [];
      for (var i = 0; i < ctr.numSeries; ++i)
        values.push(ctr.samples[ctr.numSeries * sampleIndex + i]);

      var table = results.appendTable('analysis-counter-table', 2);
      results.appendTableHeader(table, 'Selected counter:');
      results.appendSummaryRow(table, 'Title', ctr.name);
      results.appendSummaryRowTime(
          table, 'Timestamp', ctr.timestamps[sampleIndex]);

      for (var i = 0; i < ctr.numSeries; i++)
        results.appendSummaryRow(table, ctr.seriesNames[i], values[i]);
    } else if (counterSampleHits.length > 1) {
      var hitsByCounter = {};
      for (var i = 0; i < counterSampleHits.length; i++) {
        var ctr = counterSampleHits[i].counter;
        if (!hitsByCounter[ctr.guid])
          hitsByCounter[ctr.guid] = [];
        hitsByCounter[ctr.guid].push(counterSampleHits[i]);
      }

      var table = results.appendTable('analysis-counter-table', 7);
      results.appendTableHeader(table, 'Counters:');
      for (var id in hitsByCounter) {
        var hits = hitsByCounter[id];
        var ctr = hits[0].counter;
        var sampleIndices = [];
        for (var i = 0; i < hits.length; i++)
          sampleIndices.push(hits[i].sampleIndex);

        var stats = ctr.getSampleStatistics(sampleIndices);
        for (var i = 0; i < stats.length; i++) {
          results.appendDataRow(
              table, ctr.name + ': ' + ctr.seriesNames[i], undefined,
              undefined, stats[i]);
        }
      }
    }
  }

  var TimelineAnalysisView = tracing.ui.define('div');

  TimelineAnalysisView.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate: function() {
      this.className = 'analysis';
    },

    set selection(selection) {
      this.textContent = '';
      var results = new AnalysisResults();
      analyzeSelection(results, selection);
      this.appendChild(results);
    }
  };

  return {
    TimelineAnalysisView: TimelineAnalysisView,
    analyzeSelection_: analyzeSelection
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


/**
 * @fileoverview Implements an element that is hidden by default, but
 * when shown, dims and (attempts to) disable the main document.
 *
 * You can turn any div into an overlay. Note that while an
 * overlay element is shown, its parent is changed. Hiding the overlay
 * restores its original parentage.
 *
 */
base.requireStylesheet('overlay');
base.require('ui');
base.require('event_target');
base.exportTo('tracing.ui', function() {
  /**
   * Manages a full-window div that darkens the window, disables
   * input, and hosts the currently-visible overlays. You shouldn't
   * have to instantiate this directly --- it gets set automatically.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLDivElement}
   */
  var OverlayRoot = tracing.ui.define('div');
  OverlayRoot.prototype = {
    __proto__: HTMLDivElement.prototype,
    decorate: function() {
      this.classList.add('overlay-root');
      this.visible = false;

      this.contentHost = this.ownerDocument.createElement('div');
      this.contentHost.classList.add('content-host');

      this.tabCatcher = this.ownerDocument.createElement('span');
      this.tabCatcher.tabIndex = 0;

      this.appendChild(this.contentHost);

      this.onKeydownBoundToThis_ = this.onKeydown_.bind(this);
      this.onFocusInBoundToThis_ = this.onFocusIn_.bind(this);
      this.addEventListener('mousedown', this.onMousedown_.bind(this));
    },

    /**
     * Adds an overlay, attaching it to the contentHost so that it is visible.
     */
    showOverlay: function(overlay) {
      // Reparent this to the overlay content host.
      overlay.oldParent_ = overlay.parentNode;
      this.contentHost.appendChild(overlay);
      this.contentHost.appendChild(this.tabCatcher);

      // Show the overlay root.
      this.ownerDocument.body.classList.add('disabled-by-overlay');
      this.visible = true;

      // Bring overlay into focus.
      overlay.tabIndex = 0;
      var focusElement =
          overlay.querySelector('button, input, list, select, a');
      if (!focusElement) {
        focusElement = overlay;
      }
      focusElement.focus();

      // Listen to key and focus events to prevent focus from
      // leaving the overlay.
      this.ownerDocument.addEventListener('focusin',
          this.onFocusInBoundToThis_, true);
      overlay.addEventListener('keydown', this.onKeydownBoundToThis_);
    },

    /**
     * Clicking outside of the overlay will de-focus the overlay. The
     * next tab will look at the entire document to determine the focus.
     * For certain documents, this can cause focus to "leak" outside of
     * the overlay.
     */
    onMousedown_: function(e) {
      if (e.target == this) {
        e.preventDefault();
      }
    },

    /**
     * Prevents forward-tabbing out of the overlay
     */
    onFocusIn_: function(e) {
      if (e.target == this.tabCatcher) {
        window.setTimeout(this.focusOverlay_.bind(this), 0);
      }
    },

    focusOverlay_: function() {
      this.contentHost.firstChild.focus();
    },

    /**
     * Prevent the user from shift-tabbing backwards out of the overlay.
     */
    onKeydown_: function(e) {
      if (e.keyCode == 9 &&  // tab
          e.shiftKey &&
          e.target == this.contentHost.firstChild) {
        e.preventDefault();
      }
    },

    /**
     * Hides an overlay, attaching it to its original parent if needed.
     */
    hideOverlay: function(overlay) {
      // hide the overlay root
      this.visible = false;
      this.ownerDocument.body.classList.remove('disabled-by-overlay');
      this.lastFocusOut_ = undefined;

      // put the overlay back on its previous parent
      overlay.parentNode.removeChild(this.tabCatcher);
      if (overlay.oldParent_) {
        overlay.oldParent_.appendChild(overlay);
        delete overlay.oldParent_;
      } else {
        this.contentHost.removeChild(overlay);
      }

      // remove listeners
      overlay.removeEventListener('keydown', this.onKeydownBoundToThis_);
      this.ownerDocument.removeEventListener('focusin',
          this.onFocusInBoundToThis_);
    }
  };

  base.defineProperty(OverlayRoot, 'visible', base.PropertyKind.BOOL_ATTR);

  /**
   * Creates a new overlay element. It will not be visible until shown.
   * @param {Object=} opt_propertyBag Optional properties.
   * @constructor
   * @extends {HTMLDivElement}
   */
  var Overlay = tracing.ui.define('div');

  Overlay.prototype = {
    __proto__: HTMLDivElement.prototype,

    /**
     * Initializes the overlay element.
     */
    decorate: function() {
      // create the overlay root on this document if its not present
      if (!this.ownerDocument.querySelector('.overlay-root')) {
        var overlayRoot = this.ownerDocument.createElement('div');
        tracing.ui.decorate(overlayRoot, OverlayRoot);
        this.ownerDocument.body.appendChild(overlayRoot);
      }

      this.classList.add('overlay');
      this.visible = false;
      this.defaultClickShouldClose = true;
      this.autoClose = false;
      this.additionalCloseKeyCodes = [];
      this.onKeyDown = this.onKeyDown.bind(this);
      this.onKeyPress = this.onKeyPress.bind(this);
      this.onDocumentClick = this.onDocumentClick.bind(this);
    },

    onVisibleChanged_: function() {
      var overlayRoot = this.ownerDocument.querySelector('.overlay-root');
      base.dispatchSimpleEvent(this, 'visibleChange');
      if (this.visible) {
        overlayRoot.showOverlay(this);
        document.addEventListener('keydown', this.onKeyDown, true);
        document.addEventListener('keypress', this.onKeyPress, true);
        document.addEventListener('click', this.onDocumentClick, true);
      } else {
        document.removeEventListener('keydown', this.onKeyDown, true);
        document.removeEventListener('keypress', this.onKeyPress, true);
        document.removeEventListener('click', this.onDocumentClick, true);
        overlayRoot.hideOverlay(this);
      }
    },

    onKeyDown: function(e) {
      if (!this.autoClose)
        return;

      if (e.keyCode == 27) {  // escape
        this.visible = false;
        e.preventDefault();
        return;
      }
    },

    onKeyPress: function(e) {
      if (!this.autoClose)
        return;

      for (var i = 0; i < this.additionalCloseKeyCodes.length; i++) {
        if (e.keyCode == this.additionalCloseKeyCodes[i]) {
          this.visible = false;
          e.preventDefault();
          return;
        }
      }
    },

    onDocumentClick: function(e) {
      if (!this.defaultClickShouldClose)
        return;
      var target = e.target;
      while (target !== null) {
        if (target === this)
          return;
        target = target.parentNode;
      }
      this.visible = false;
      e.preventDefault();
      return;
    }

  };

  /**
   * Shows and hides the overlay. Note that while visible == true, the overlay
   * element will be tempoarily reparented to another place in the DOM.
   */
  base.defineProperty(Overlay, 'visible', base.PropertyKind.BOOL_ATTR,
      Overlay.prototype.onVisibleChanged_);
  base.defineProperty(Overlay, 'defaultClickShouldClose',
      base.PropertyKind.BOOL_ATTR);

  return {
    Overlay: Overlay
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview CategoryFilterButton extracts categories from the model
 * and shows/hides them based on settings.
 */
base.require('filter');
base.require('overlay');
base.exportTo('tracing', function() {

  var CategoryFilterDialog = tracing.ui.define('div');

  CategoryFilterDialog.prototype = {
    __proto__: tracing.ui.Overlay.prototype,

    decorate: function() {
      tracing.ui.Overlay.prototype.decorate.call(this);

      this.className = 'view-category-filter-overlay';
      this.autoClose = true;

      var containerEl = document.createElement('div');
      containerEl.className = 'category-filter-dialog';
      containerEl.textContent = 'Select active categories:';
      this.formEl_ = document.createElement('form');
      this.formEl_.className = 'category-filter-dialog-form';
      containerEl.appendChild(this.formEl_);
      this.appendChild(containerEl);

      this.categoriesEl_ = document.createElement('div');
      this.categoriesEl_.className = 'categories';
      this.formEl_.appendChild(this.categoriesEl_);

      this.addEventListener('visibleChange', this.onVisibleChange_.bind(this));

      this.onChangeCallback_ = undefined;
      this.isCheckedCallback_ = undefined;
    },

    set categories(c) {
      this.categories_ = c;
    },

    set settings_key(k) {
      this.settings_key_ = k;
    },

    set settings(s) {
      this.settings_ = s;
    },

    set settingUpdatedCallback(c) {
      this.settingUpdatedCallback_ = c;
    },

    selectedCategories: function() {
      // TODO(dsinclair): This can be made smarter by just storing an array
      // of selected categories when they're clicked.
      var inputs = this.categoriesEl_.querySelectorAll('input');
      var inputs_length = inputs.length;
      var categories = [];
      for (var i = 0; i < inputs_length; ++i) {
        var input = inputs[i];
        if (input.checked)
          categories.push(input.value);
      }
      return categories;
    },

    onVisibleChange_: function() {
      if (this.visible) {
        this.updateForm_();
      }
    },

    updateForm_: function() {
      this.categoriesEl_.innerHTML = ''; // Clear old categories

      // Dedup the categories. We may have things in settings that are also
      // returned when we query the category list.
      var set = {};
      var allCategories =
          this.categories_.concat(this.settings_.keys(this.settings_key_));
      var allCategoriesLength = allCategories.length;
      for (var i = 0; i < allCategoriesLength; ++i) {
        set[allCategories[i]] = true;
      }
      var categories = [];
      for (var category in set) {
        categories.push(category);
      }
      categories = categories.sort();

      for (var i = 0; i < categories.length; i++) {
        var category = categories[i];
        var inputEl = document.createElement('input');
        inputEl.type = 'checkbox';
        inputEl.id = inputEl.value = category;
        inputEl.checked =
            this.settings_.get(category, 'true', this.settings_key_) === 'true';
        inputEl.onchange = this.updateSetting_.bind(this);

        var labelEl = document.createElement('label');
        labelEl.textContent = category;
        labelEl.setAttribute('for', category);

        var divEl = document.createElement('div');
        divEl.appendChild(inputEl);
        divEl.appendChild(labelEl);
        this.categoriesEl_.appendChild(divEl);
      }
    },

    updateSetting_: function(e) {
      var checkbox = e.target;
      this.settings_.set(checkbox.value, checkbox.checked, this.settings_key_);
      if (this.settingUpdatedCallback_ !== undefined)
        this.settingUpdatedCallback_();
    }
  };

  return {
    CategoryFilterDialog: CategoryFilterDialog
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview FindControl and FindController.
 */
base.require('timeline_track_view');
base.require('filter');
base.require('overlay');
base.exportTo('tracing', function() {

  /**
   * FindControl
   * @constructor
   * @extends {tracing.ui.Overlay}
   */
  var FindControl = tracing.ui.define('div');

  FindControl.prototype = {
    __proto__: tracing.ui.Overlay.prototype,

    decorate: function() {
      tracing.ui.Overlay.prototype.decorate.call(this);

      this.className = 'find-control';

      this.hitCountEl_ = document.createElement('div');
      this.hitCountEl_.className = 'hit-count-label';
      this.hitCountEl_.textContent = '1 of 7';

      var findPreviousBn = document.createElement('div');
      findPreviousBn.className = 'button find-previous';
      findPreviousBn.textContent = '\u2190';
      findPreviousBn.addEventListener('click', function() {
        this.controller.findPrevious();
        this.updateHitCountEl_();
      }.bind(this));

      var findNextBn = document.createElement('div');
      findNextBn.className = 'button find-next';
      findNextBn.textContent = '\u2192';
      findNextBn.addEventListener('click', function() {
        this.controller.findNext();
        this.updateHitCountEl_();
      }.bind(this));

      // Filter input element.
      this.filterEl_ = document.createElement('input');
      this.filterEl_.type = 'input';

      this.filterEl_.addEventListener('input', function(e) {
        this.controller.filterText = this.filterEl_.value;
        this.updateHitCountEl_();
      }.bind(this));

      this.filterEl_.addEventListener('keydown', function(e) {
        if (e.keyCode == 13) {
          findNextBn.click();
        } else if (e.keyCode == 27) {
          this.filterEl_.blur();
          this.updateHitCountEl_();
        }
      }.bind(this));

      this.filterEl_.addEventListener('blur', function(e) {
        this.updateHitCountEl_();
      }.bind(this));

      this.filterEl_.addEventListener('focus', function(e) {
        this.updateHitCountEl_();
      }.bind(this));

      // Attach everything.
      this.appendChild(this.filterEl_);

      this.appendChild(findPreviousBn);
      this.appendChild(findNextBn);
      this.appendChild(this.hitCountEl_);

      this.updateHitCountEl_();
    },

    get controller() {
      return this.controller_;
    },

    set controller(c) {
      this.controller_ = c;
      this.updateHitCountEl_();
    },

    focus: function() {
      this.filterEl_.selectionStart = 0;
      this.filterEl_.selectionEnd = this.filterEl_.value.length;
      this.filterEl_.focus();
    },

    updateHitCountEl_: function() {
      if (!this.controller || document.activeElement != this.filterEl_) {
        this.hitCountEl_.textContent = '';
        return;
      }
      var i = this.controller.currentHitIndex;
      var n = this.controller.filterHits.length;
      if (n == 0)
        this.hitCountEl_.textContent = '0 of 0';
      else
        this.hitCountEl_.textContent = (i + 1) + ' of ' + n;
    }
  };

  function FindController() {
    this.timeline_ = undefined;
    this.model_ = undefined;
    this.filterText_ = '';
    this.filterHits_ = new tracing.Selection();
    this.filterHitsDirty_ = true;
    this.currentHitIndex_ = 0;
  };

  FindController.prototype = {
    __proto__: Object.prototype,

    get timeline() {
      return this.timeline_;
    },

    set timeline(t) {
      this.timeline_ = t;
      this.filterHitsDirty_ = true;
    },

    get filterText() {
      return this.filterText_;
    },

    set filterText(f) {
      if (f == this.filterText_)
        return;
      this.filterText_ = f;
      this.filterHitsDirty_ = true;
      this.findNext();
    },

    get filterHits() {
      if (this.filterHitsDirty_) {
        this.filterHitsDirty_ = false;
        if (this.timeline_) {
          var filter = new tracing.TitleFilter(this.filterText);
          this.filterHits_.clear();
          this.timeline.addAllObjectsMatchingFilterToSelection(
              filter, this.filterHits_);
          this.currentHitIndex_ = this.filterHits_.length - 1;
        } else {
          this.filterHits_.clear();
          this.currentHitIndex_ = 0;
        }
      }
      return this.filterHits_;
    },

    get currentHitIndex() {
      return this.currentHitIndex_;
    },

    find_: function(dir) {
      if (!this.timeline)
        return;

      var N = this.filterHits.length;
      this.currentHitIndex_ = this.currentHitIndex_ + dir;

      if (this.currentHitIndex_ < 0) this.currentHitIndex_ = N - 1;
      if (this.currentHitIndex_ >= N) this.currentHitIndex_ = 0;

      if (this.currentHitIndex_ < 0 || this.currentHitIndex_ >= N) {
        this.timeline.selection = new tracing.Selection();
        return;
      }

      // We allow the zoom level to change on the first hit level. But, when
      // then cycling through subsequent changes, restrict it to panning.
      var zoomAllowed = this.currentHitIndex_ == 0;
      var subSelection = this.filterHits.subSelection(this.currentHitIndex_);
      this.timeline.setSelectionAndMakeVisible(subSelection, zoomAllowed);
    },

    findNext: function() {
      this.find_(1);
    },

    findPrevious: function() {
      this.find_(-1);
    }
  };

  return {
    FindControl: FindControl,
    FindController: FindController
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview TraceEventImporter imports TraceEvent-formatted data
 * into the provided model.
 */
base.require('model');
base.require('color_scheme');
base.exportTo('tracing.importer', function() {

  function TraceEventImporter(model, eventData) {
    this.importPriority = 1;
    this.model_ = model;

    if (typeof(eventData) === 'string' || eventData instanceof String) {
      // If the event data begins with a [, then we know it should end with a ].
      // The reason we check for this is because some tracing implementations
      // cannot guarantee that a ']' gets written to the trace file. So, we are
      // forgiving and if this is obviously the case, we fix it up before
      // throwing the string at JSON.parse.
      if (eventData[0] == '[') {
        n = eventData.length;
        if (eventData[n - 1] == '\n') {
          eventData = eventData.substring(0, n - 1);
          n--;

          if (eventData[n - 1] == '\r') {
            eventData = eventData.substring(0, n - 1);
            n--;
          }
        }

        if (eventData[n - 1] == ',')
          eventData = eventData.substring(0, n - 1);
        if (eventData[n - 1] != ']')
          eventData = eventData + ']';
      }

      this.events_ = JSON.parse(eventData);

    } else {
      this.events_ = eventData;
    }

    // Some trace_event implementations put the actual trace events
    // inside a container. E.g { ... , traceEvents: [ ] }
    // If we see that, just pull out the trace events.
    if (this.events_.traceEvents) {
      var container = this.events_;
      this.events_ = this.events_.traceEvents;
      for (fieldName in container) {
        if (fieldName == 'traceEvents')
          continue;
        this.model_.metadata.push({name: fieldName,
          value: container[fieldName]});
      }
    }

    // Async events need to be processed durign finalizeEvents
    this.allAsyncEvents_ = [];
  }

  /**
   * @return {boolean} Whether obj is a TraceEvent array.
   */
  TraceEventImporter.canImport = function(eventData) {
    // May be encoded JSON. But we dont want to parse it fully yet.
    // Use a simple heuristic:
    //   - eventData that starts with [ are probably trace_event
    //   - eventData that starts with { are probably trace_event
    // May be encoded JSON. Treat files that start with { as importable by us.
    if (typeof(eventData) === 'string' || eventData instanceof String) {
      return eventData[0] == '{' || eventData[0] == '[';
    }

    // Might just be an array of events
    if (eventData instanceof Array && eventData.length && eventData[0].ph)
      return true;

    // Might be an object with a traceEvents field in it.
    if (eventData.traceEvents)
      return eventData.traceEvents instanceof Array &&
          eventData.traceEvents[0].ph;

    return false;
  };

  TraceEventImporter.prototype = {

    __proto__: Object.prototype,

    /**
     * Helper to process an 'async finish' event, which will close an open slice
     * on a AsyncSliceGroup object.
     */
    processAsyncEvent: function(index, event) {
      var thread = this.model_.getOrCreateProcess(event.pid).
          getOrCreateThread(event.tid);
      this.allAsyncEvents_.push({
        event: event,
        thread: thread});
    },

    /**
     * Helper that creates and adds samples to a Counter object based on
     * 'C' phase events.
     */
    processCounterEvent: function(event) {
      var ctr_name;
      if (event.id !== undefined)
        ctr_name = event.name + '[' + event.id + ']';
      else
        ctr_name = event.name;

      var ctr = this.model_.getOrCreateProcess(event.pid)
          .getOrCreateCounter(event.cat, ctr_name);
      // Initialize the counter's series fields if needed.
      if (ctr.numSeries == 0) {
        for (var seriesName in event.args) {
          ctr.seriesNames.push(seriesName);
          ctr.seriesColors.push(
              tracing.getStringColorId(ctr.name + '.' + seriesName));
        }
        if (ctr.numSeries == 0) {
          this.model_.importErrors.push('Expected counter ' + event.name +
              ' to have at least one argument to use as a value.');
          // Drop the counter.
          delete ctr.parent.counters[ctr.name];
          return;
        }
      }

      // Add the sample values.
      ctr.timestamps.push(event.ts / 1000);
      for (var i = 0; i < ctr.numSeries; i++) {
        var seriesName = ctr.seriesNames[i];
        if (event.args[seriesName] === undefined) {
          ctr.samples.push(0);
          continue;
        }
        ctr.samples.push(event.args[seriesName]);
      }
    },

    /**
     * Walks through the events_ list and outputs the structures discovered to
     * model_.
     */
    importEvents: function() {
      // Walk through events
      var events = this.events_;
      // Some events cannot be handled until we have done a first pass over the
      // data set.  So, accumulate them into a temporary data structure.
      var second_pass_events = [];
      for (var eI = 0; eI < events.length; eI++) {
        var event = events[eI];
        if (event.ph == 'B') {
          var thread = this.model_.getOrCreateProcess(event.pid)
            .getOrCreateThread(event.tid);
          if (!thread.isTimestampValidForBeginOrEnd(event.ts / 1000)) {
            this.model_.importErrors.push(
                'Timestamps are moving backward.');
            continue;
          }
          thread.beginSlice(event.cat, event.name, event.ts / 1000, event.args);
        } else if (event.ph == 'E') {
          var thread = this.model_.getOrCreateProcess(event.pid)
            .getOrCreateThread(event.tid);
          if (!thread.isTimestampValidForBeginOrEnd(event.ts / 1000)) {
            this.model_.importErrors.push(
                'Timestamps are moving backward.');
            continue;
          }
          if (!thread.openSliceCount) {
            this.model_.importErrors.push(
                'E phase event without a matching B phase event.');
            continue;
          }

          var slice = thread.endSlice(event.ts / 1000);
          for (var arg in event.args) {
            if (slice.args[arg] !== undefined) {
              this.model_.importErrors.push(
                  'Both the B and E phases of ' + slice.name +
                  'provided values for argument ' + arg + '. ' +
                  'The value of the E phase event will be used.');
            }
            slice.args[arg] = event.args[arg];
          }

        } else if (event.ph == 'S') {
          this.processAsyncEvent(eI, event);
        } else if (event.ph == 'F') {
          this.processAsyncEvent(eI, event);
        } else if (event.ph == 'T') {
          this.processAsyncEvent(eI, event);
        } else if (event.ph == 'I' || event.ph == 'i') {
          // Treat an Instant event as a duration 0 slice.
          // SliceTrack's redraw() knows how to handle this.
          var thread = this.model_.getOrCreateProcess(event.pid)
            .getOrCreateThread(event.tid);
          thread.beginSlice(event.cat, event.name, event.ts / 1000, event.args);
          thread.endSlice(event.ts / 1000);
        } else if (event.ph == 'P') {
          var thread = this.model_.getOrCreateProcess(event.pid)
            .getOrCreateThread(event.tid);
          thread.addSample(event.cat, event.name, event.ts / 1000, event.args);
        } else if (event.ph == 'C') {
          this.processCounterEvent(event);
        } else if (event.ph == 'M') {
          if (event.name == 'thread_name') {
            var thread = this.model_.getOrCreateProcess(event.pid)
                             .getOrCreateThread(event.tid);
            thread.name = event.args.name;
          } else {
            this.model_.importErrors.push(
                'Unrecognized metadata name: ' + event.name);
          }
        } else if (event.ph == 's') {
          // NB: toss until there's proper support
        } else if (event.ph == 't') {
          // NB: toss until there's proper support
        } else if (event.ph == 'f') {
          // NB: toss until there's proper support
        } else {
          this.model_.importErrors.push(
              'Unrecognized event phase: ' + event.ph +
              '(' + event.name + ')');
        }
      }
    },

    /**
     * Called by the Model after all other importers have imported their
     * events.
     */
    finalizeImport: function() {
      this.createAsyncSlices_();
    },

    createAsyncSlices_: function() {
      if (this.allAsyncEvents_.length == 0)
        return;

      this.allAsyncEvents_.sort(function(x, y) {
        return x.event.ts - y.event.ts;
      });

      var asyncEventStatesByNameThenID = {};

      var allAsyncEvents = this.allAsyncEvents_;
      for (var i = 0; i < allAsyncEvents.length; i++) {
        var asyncEventState = allAsyncEvents[i];

        var event = asyncEventState.event;
        var name = event.name;
        if (name === undefined) {
          this.model_.importErrors.push(
              'Async events (ph: S, T or F) require an name parameter.');
          continue;
        }

        var id = event.id;
        if (id === undefined) {
          this.model_.importErrors.push(
              'Async events (ph: S, T or F) require an id parameter.');
          continue;
        }

        // TODO(simonjam): Add a synchronous tick on the appropriate thread.

        if (event.ph == 'S') {
          if (asyncEventStatesByNameThenID[name] === undefined)
            asyncEventStatesByNameThenID[name] = {};
          if (asyncEventStatesByNameThenID[name][id]) {
            this.model_.importErrors.push(
                'At ' + event.ts + ', a slice of the same id ' + id +
                ' was alrady open.');
            continue;
          }
          asyncEventStatesByNameThenID[name][id] = [];
          asyncEventStatesByNameThenID[name][id].push(asyncEventState);
        } else {
          if (asyncEventStatesByNameThenID[name] === undefined) {
            this.model_.importErrors.push(
                'At ' + event.ts + ', no slice named ' + name +
                ' was open.');
            continue;
          }
          if (asyncEventStatesByNameThenID[name][id] === undefined) {
            this.model_.importErrors.push(
                'At ' + event.ts + ', no slice named ' + name +
                ' with id=' + id + ' was open.');
            continue;
          }
          var events = asyncEventStatesByNameThenID[name][id];
          events.push(asyncEventState);

          if (event.ph == 'F') {
            // Create a slice from start to end.
            var slice = new tracing.model.AsyncSlice(
                events[0].event.cat,
                name,
                tracing.getStringColorId(name),
                events[0].event.ts / 1000);

            slice.duration = (event.ts / 1000) - (events[0].event.ts / 1000);

            slice.startThread = events[0].thread;
            slice.endThread = asyncEventState.thread;
            slice.id = id;
            slice.args = events[0].event.args;
            slice.subSlices = [];

            // Create subSlices for each step.
            for (var j = 1; j < events.length; ++j) {
              var subName = name;
              if (events[j - 1].event.ph == 'T')
                subName = name + ':' + events[j - 1].event.args.step;
              var subSlice = new tracing.model.AsyncSlice(
                  events[0].event.cat,
                  subName,
                  tracing.getStringColorId(name + j),
                  events[j - 1].event.ts / 1000);

              subSlice.duration =
                  (events[j].event.ts / 1000) - (events[j - 1].event.ts / 1000);

              subSlice.startThread = events[j - 1].thread;
              subSlice.endThread = events[j].thread;
              subSlice.id = id;
              subSlice.args = events[j - 1].event.args;

              slice.subSlices.push(subSlice);
            }

            // The args for the finish event go in the last subSlice.
            var lastSlice = slice.subSlices[slice.subSlices.length - 1];
            for (var arg in event.args)
              lastSlice.args[arg] = event.args[arg];

            // Add |slice| to the start-thread's asyncSlices.
            slice.startThread.asyncSlices.push(slice);
            delete asyncEventStatesByNameThenID[name][id];
          }
        }
      }
    }
  };

  tracing.Model.registerImporter(TraceEventImporter);

  return {
    TraceEventImporter: TraceEventImporter
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Base class for linux perf event parsers.
 *
 * The linux perf trace event importer depends on subclasses of
 * Parser to parse event data.  Each subclass corresponds
 * to a group of trace events; e.g. SchedParser implements
 * parsing of sched:* kernel trace events.  Parser subclasses must
 * call Parser.registerSubtype to arrange to be instantiated
 * and their constructor must register their event handlers with the
 * importer.  For example,
 *
 * var Parser = tracing.importer.linux_perf.Parser;
 *
 * function WorkqueueParser(importer) {
 *   Parser.call(this, importer);
 *
 *   importer.registerEventHandler('workqueue_execute_start',
 *       WorkqueueParser.prototype.executeStartEvent.bind(this));
 *   importer.registerEventHandler('workqueue_execute_end',
 *       WorkqueueParser.prototype.executeEndEvent.bind(this));
 * }
 *
 * Parser.registerSubtype(WorkqueueParser);
 *
 * When a registered event name is found in the data stream the associated
 * event handler is invoked:
 *
 *   executeStartEvent: function(eventName, cpuNumber, ts, eventBase)
 *
 * If the routine returns false the caller will generate an import error
 * saying there was a problem parsing it.  Handlers can also emit import
 * messages using this.importer.importError.  If this is done in lieu of
 * the generic import error it may be desirable for the handler to return
 * true.
 *
 * Trace events generated by writing to the trace_marker file are expected
 * to have a leading text marker followed by a ':'; e.g. the trace clock
 * synchronization event is:
 *
 *  tracing_mark_write: trace_event_clock_sync: parent_ts=0
 *
 * To register an event handler for these events, prepend the marker with
 * 'tracing_mark_write:'; e.g.
 *
 *    this.registerEventHandler('tracing_mark_write:trace_event_clock_sync',
 *
 * All subclasses should depend on importer.linux_perf.parser, e.g.
 *
 * base.defineModule('importer.linux_perf.workqueue_parser')
 *   .dependsOn('importer.linux_perf.parser')
 *   .exportsTo('tracing', function()
 *
 * and be listed in the dependsOn of LinuxPerfImporter.  Beware that after
 * adding a new subclass you must run build/generate_about_tracing_contents.py
 * to regenerate about_tracing.*.
 */
base.exportTo('tracing.importer.linux_perf', function() {

  var subtypeConstructors = [];

  /**
   * Registers a subclass that will help parse linux perf events.
   * The importer will call createParsers (below) before importing
   * data so each subclass can register its handlers.
   *
   * @param {Function} subtypeConstructor The subtype's constructor function.
   */
  Parser.registerSubtype = function(subtypeConstructor) {
    subtypeConstructors.push(subtypeConstructor);
  };

  Parser.getSubtypeConstructors = function() {
    return subtypeConstructors;
  };

  /**
   * Parses linux perf events.
   * @constructor
   */
  function Parser(importer) {
    this.importer = importer;
    this.model = importer.model;
  }

  Parser.prototype = {
    __proto__: Object.prototype
  };

  return {
    Parser: Parser
  };

});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Parses trace_marker events that were inserted in the trace by
 * userland.
 */
base.require('importer.linux_perf.parser');
base.exportTo('tracing.importer.linux_perf', function() {

  var Parser = tracing.importer.linux_perf.Parser;

  /**
   * Parses linux trace mark events that were inserted in the trace by userland.
   * @constructor
   */
  function BusParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('memory_bus_usage',
        BusParser.prototype.traceMarkWriteBusEvent.bind(this));

    this.model_ = importer.model_;
    this.ppids_ = {};
  }

  BusParser.prototype = {
    __proto__: Parser.prototype,

    traceMarkWriteBusEvent: function(eventName, cpuNumber, pid, ts,
                                  eventBase, threadName) {
        var re = new RegExp('bus=(\\S+) rw_bytes=(\\d+) r_bytes=(\\d+) ' +
                            'w_bytes=(\\d+) cycles=(\\d+) ns=(\\d+)');
        var event = re.exec(eventBase.details);

        var name = event[1];
        var rw_bytes = parseInt(event[2]);
        var r_bytes = parseInt(event[3]);
        var w_bytes = parseInt(event[4]);
        var cycles = parseInt(event[5]);
        var ns = parseInt(event[6]);

        // BW in MB/s
        var r_bw = r_bytes * 1000000000 / ns;
        r_bw /= 1024 * 1024;
        var w_bw = w_bytes * 1000000000 / ns;
        w_bw /= 1024 * 1024;

        var ctr = this.model_.getOrCreateProcess(0)
              .getOrCreateCounter(null, 'bus ' + name + ' read');
        // Initialize the counter's series fields if needed.
        if (ctr.numSeries == 0) {
            ctr.seriesNames.push('value');
            ctr.seriesColors.push(
                tracing.getStringColorId(ctr.name + '.' + 'value'));
        }

        // Add the sample value.
        ctr.timestamps.push(ts);
        ctr.samples.push(r_bw);

        ctr = this.model_.getOrCreateProcess(0)
              .getOrCreateCounter(null, 'bus ' + name + ' write');
        // Initialize the counter's series fields if needed.
        if (ctr.numSeries == 0) {
            ctr.seriesNames.push('value');
            ctr.seriesColors.push(
                tracing.getStringColorId(ctr.name + '.' + 'value'));
        }

        // Add the sample value.
        ctr.timestamps.push(ts);
        ctr.samples.push(w_bw);

        return true;
    },
  };

  Parser.registerSubtype(BusParser);

  return {
    BusParser: BusParser
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Parses trace_marker events that were inserted in the trace by
 * userland.
 */
base.require('importer.linux_perf.parser');
base.exportTo('tracing.importer.linux_perf', function() {

  var Parser = tracing.importer.linux_perf.Parser;

  /**
   * Parses linux trace mark events that were inserted in the trace by userland.
   * @constructor
   */
  function ClockParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('clock_set_rate',
        ClockParser.prototype.traceMarkWriteClockEvent.bind(this));

    this.model_ = importer.model_;
    this.ppids_ = {};
  }

  ClockParser.prototype = {
    __proto__: Parser.prototype,

    traceMarkWriteClockEvent: function(eventName, cpuNumber, pid, ts,
                                  eventBase, threadName) {
        var event = /(\S+) state=(\d+) cpu_id=(\d+)/.exec(eventBase.details);


        var name = event[1];
        var rate = parseInt(event[2]);

        var ctr = this.model_.getOrCreateProcess(0)
              .getOrCreateCounter(null, name);
        // Initialize the counter's series fields if needed.
        if (ctr.numSeries == 0) {
            ctr.seriesNames.push('value');
            ctr.seriesColors.push(
                tracing.getStringColorId(ctr.name + '.' + 'value'));
        }

        // Add the sample value.
        ctr.timestamps.push(ts);
        ctr.samples.push(rate);

        return true;
    },
  };

  Parser.registerSubtype(ClockParser);

  return {
    ClockParser: ClockParser
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Parses cpufreq events in the Linux event trace format.
 */
base.require('importer.linux_perf.parser');
base.exportTo('tracing.importer.linux_perf', function() {

  var Parser = tracing.importer.linux_perf.Parser;

  /**
   * Parses linux cpufreq trace events.
   * @constructor
   */
  function CpufreqParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('cpufreq_interactive_up',
        CpufreqParser.prototype.cpufreqUpDownEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_down',
        CpufreqParser.prototype.cpufreqUpDownEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_already',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_notyet',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_setspeed',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_target',
        CpufreqParser.prototype.cpufreqTargetEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_boost',
        CpufreqParser.prototype.cpufreqBoostUnboostEvent.bind(this));
    importer.registerEventHandler('cpufreq_interactive_unboost',
        CpufreqParser.prototype.cpufreqBoostUnboostEvent.bind(this));
  }

  function splitData(input) {
    // TODO(sleffler) split by cpu
    var data = {};
    var args = input.split(/\s+/);
    var len = args.length;
    for (var i = 0; i < len; i++) {
      var item = args[i].split('=');
      data[item[0]] = parseInt(item[1]);
    }
    return data;
  }

  CpufreqParser.prototype = {
    __proto__: Parser.prototype,

    cpufreqSlice: function(ts, eventName, cpu, args) {
      // TODO(sleffler) should be per-cpu
      var kthread = this.importer.getOrCreatePseudoThread('cpufreq');
      kthread.openSlice = eventName;
      var slice = new tracing.model.Slice('', kthread.openSlice,
          tracing.getStringColorId(kthread.openSlice), ts, args, 0);

      kthread.thread.pushSlice(slice);
    },

    cpufreqBoostSlice: function(ts, eventName, args) {
      var kthread = this.importer.getOrCreatePseudoThread('cpufreq_boost');
      kthread.openSlice = eventName;
      var slice = new tracing.model.Slice('', kthread.openSlice,
          tracing.getStringColorId(kthread.openSlice), ts, args, 0);

      kthread.thread.pushSlice(slice);
    },

    /**
     * Parses cpufreq events and sets up state in the importer.
     */
    cpufreqUpDownEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var data = splitData(eventBase.details);
      this.cpufreqSlice(ts, eventName, data.cpu, data);
      return true;
    },

    cpufreqTargetEvent: function(eventName, cpuNumber, pid, ts,
                                 eventBase) {
      var data = splitData(eventBase.details);
      this.cpufreqSlice(ts, eventName, data.cpu, data);
      return true;
    },

    cpufreqBoostUnboostEvent: function(eventName, cpuNumber, pid, ts,
                                       eventBase) {
      this.cpufreqBoostSlice(ts, eventName,
          {
            type: eventBase.details
          });
      return true;
    }
  };

  Parser.registerSubtype(CpufreqParser);

  return {
    CpufreqParser: CpufreqParser
  };
});

// Copyright (c) 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Parses filesystem and block device events in the Linux event
 * trace format.
 */
base.require('importer.linux_perf.parser');
base.exportTo('tracing.importer.linux_perf', function() {

  var Parser = tracing.importer.linux_perf.Parser;

  /**
   * Parses linux filesystem and block device trace events.
   * @constructor
   */
  function DiskParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('ext4_sync_file_enter',
        DiskParser.prototype.ext4SyncFileEnterEvent.bind(this));
    importer.registerEventHandler('ext4_sync_file_exit',
        DiskParser.prototype.ext4SyncFileExitEvent.bind(this));
    importer.registerEventHandler('block_rq_issue',
        DiskParser.prototype.blockRqIssueEvent.bind(this));
    importer.registerEventHandler('block_rq_complete',
        DiskParser.prototype.blockRqCompleteEvent.bind(this));
  }

  DiskParser.prototype = {
    __proto__: Parser.prototype,

    openAsyncSlice: function(ts, category, threadName, pid, key, name) {
      var kthread = this.importer.getOrCreateKernelThread(
          category + ':' + threadName, pid);
      var slice = new tracing.model.AsyncSlice(
          category, name, tracing.getStringColorId(name), ts);
      slice.startThread = kthread.thread;

      if (!kthread.openAsyncSlices) {
        kthread.openAsyncSlices = { };
      }
      kthread.openAsyncSlices[key] = slice;
    },

    closeAsyncSlice: function(ts, category, threadName, pid, key, args) {
      var kthread = this.importer.getOrCreateKernelThread(
          category + ':' + threadName, pid);
      if (kthread.openAsyncSlices) {
        var slice = kthread.openAsyncSlices[key];
        if (slice) {
          slice.duration = ts - slice.start;
          slice.args = args;
          slice.endThread = kthread.thread;
          slice.subSlices = [new tracing.model.Slice(category, slice.title,
              slice.colorId, slice.start, slice.args, slice.duration)];
          kthread.thread.asyncSlices.push(slice);
          delete kthread.openAsyncSlices[key];
        }
      }
    },

    /**
     * Parses events and sets up state in the importer.
     */
    ext4SyncFileEnterEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev (\d+,\d+) ino (\d+) parent (\d+) datasync (\d+)/.
          exec(eventBase.details);
      if (!event)
        return false;

      var device = event[1];
      var inode = parseInt(event[2]);
      var datasync = event[4] == 1;
      var key = device + '-' + inode;
      var action = datasync ? 'fdatasync' : 'fsync';
      this.openAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid,
          key, action);
      return true;
    },

    ext4SyncFileExitEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev (\d+,\d+) ino (\d+) ret (\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var device = event[1];
      var inode = parseInt(event[2]);
      var error = parseInt(event[3]);
      var key = device + '-' + inode;
      this.closeAsyncSlice(ts, 'ext4', eventBase.threadName, eventBase.pid,
          key, {
          device: device,
          inode: inode,
          error: error
      });
      return true;
    },

    blockRqIssueEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = new RegExp('(\\d+,\\d+) (F)?([DWRN])(F)?(A)?(S)?(M)? ' +
          '\\d+ \\(.*\\) (\\d+) \\+ (\\d+) \\[.*\\]').exec(eventBase.details);
      if (!event)
        return false;

      var action;
      switch (event[3]) {
        case 'D':
          action = 'discard';
          break;
        case 'W':
          action = 'write';
          break;
        case 'R':
          action = 'read';
          break;
        case 'N':
          action = 'none';
          break;
        default:
          action = 'unknown';
          break;
      }

      if (event[2]) {
        action += ' flush';
      }
      if (event[4] == 'F') {
        action += ' fua';
      }
      if (event[5] == 'A') {
        action += ' ahead';
      }
      if (event[6] == 'S') {
        action += ' sync';
      }
      if (event[7] == 'M') {
        action += ' meta';
      }
      var device = event[1];
      var sector = parseInt(event[8]);
      var numSectors = parseInt(event[9]);
      var key = device + '-' + sector + '-' + numSectors;
      this.openAsyncSlice(ts, 'block', eventBase.threadName, eventBase.pid,
          key, action);
      return true;
    },

    blockRqCompleteEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = new RegExp('(\\d+,\\d+) (F)?([DWRN])(F)?(A)?(S)?(M)? ' +
          '\\(.*\\) (\\d+) \\+ (\\d+) \\[(.*)\\]').exec(eventBase.details);
      if (!event)
        return false;

      var device = event[1];
      var sector = parseInt(event[8]);
      var numSectors = parseInt(event[9]);
      var error = parseInt(event[10]);
      var key = device + '-' + sector + '-' + numSectors;
      this.closeAsyncSlice(ts, 'block', eventBase.threadName, eventBase.pid,
          key, {
          device: device,
          sector: sector,
          numSectors: numSectors,
          error: error
      });
      return true;
    },
  };

  Parser.registerSubtype(DiskParser);

  return {
    DiskParser: DiskParser
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Parses drm driver events in the Linux event trace format.
 */
base.require('importer.linux_perf.parser');
base.exportTo('tracing.importer.linux_perf', function() {

  var Parser = tracing.importer.linux_perf.Parser;

  /**
   * Parses linux drm trace events.
   * @constructor
   */
  function DrmParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('drm_vblank_event',
        DrmParser.prototype.vblankEvent.bind(this));
  }

  DrmParser.prototype = {
    __proto__: Parser.prototype,

    drmVblankSlice: function(ts, eventName, args) {
      var kthread = this.importer.getOrCreatePseudoThread('drm_vblank');
      kthread.openSlice = eventName;
      var slice = new tracing.model.Slice('', kthread.openSlice,
          tracing.getStringColorId(kthread.openSlice), ts, args, 0);

      kthread.thread.pushSlice(slice);
    },

    /**
     * Parses drm driver events and sets up state in the importer.
     */
    vblankEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /crtc=(\d+), seq=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var crtc = parseInt(event[1]);
      var seq = parseInt(event[2]);
      this.drmVblankSlice(ts, 'vblank:' + crtc,
          {
            crtc: crtc,
            seq: seq
          });
      return true;
    }
  };

  Parser.registerSubtype(DrmParser);

  return {
    DrmParser: DrmParser
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Parses exynos events in the Linux event trace format.
 */
base.require('importer.linux_perf.parser');
base.exportTo('tracing.importer.linux_perf', function() {

  var Parser = tracing.importer.linux_perf.Parser;

  /**
   * Parses linux exynos trace events.
   * @constructor
   */
  function ExynosParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('exynos_flip_request',
        ExynosParser.prototype.flipEvent.bind(this));
    importer.registerEventHandler('exynos_flip_complete',
        ExynosParser.prototype.flipEvent.bind(this));

    importer.registerEventHandler('exynos_busfreq_target_int',
        ExynosParser.prototype.busfreqTargetIntEvent.bind(this));
    importer.registerEventHandler('exynos_busfreq_target_mif',
        ExynosParser.prototype.busfreqTargetMifEvent.bind(this));
  }

  ExynosParser.prototype = {
    __proto__: Parser.prototype,

    exynosFlipOpenSlice: function(ts, pipe) {
      // use pipe?
      var kthread = this.importer.getOrCreatePseudoThread('exynos_flip');
      kthread.openSliceTS = ts;
      kthread.openSlice = 'flip:' + pipe;
    },

    exynosFlipCloseSlice: function(ts, args) {
      var kthread = this.importer.getOrCreatePseudoThread('exynos_flip');
      if (kthread.openSlice) {
        var slice = new tracing.model.Slice('', kthread.openSlice,
            tracing.getStringColorId(kthread.openSlice),
            kthread.openSliceTS,
            args,
            ts - kthread.openSliceTS);

        kthread.thread.pushSlice(slice);
      }
      kthread.openSlice = undefined;
    },

    /**
     * Parses exynos events and sets up state in the importer.
     */
    flipEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /pipe=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var pipe = parseInt(event[1]);
      if (eventName == 'exynos_flip_request')
        this.exynosFlipOpenSlice(ts, pipe);
      else
        this.exynosFlipCloseSlice(ts,
            {
              pipe: pipe
            });
      return true;
    },

    exynosBusfreqSample: function(name, ts, frequency) {
      var targetCpu = this.importer.getOrCreateCpuState(0);
      var counter = targetCpu.cpu.getOrCreateCounter('', name);
      if (counter.numSeries == 0) {
        counter.seriesNames.push('frequency');
        counter.seriesColors.push(
            tracing.getStringColorId(counter.name + '.' + 'frequency'));
      }
      counter.timestamps.push(ts);
      counter.samples.push(frequency);
    },

    /**
     * Parses exynos_busfreq_target_int events and sets up state.
     */
    busfreqTargetIntEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /frequency=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      this.exynosBusfreqSample('INT Frequency', ts, parseInt(event[1]));
      return true;
    },

    /**
     * Parses exynos_busfreq_target_mif events and sets up state.
     */
    busfreqTargetMifEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /frequency=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      this.exynosBusfreqSample('MIF Frequency', ts, parseInt(event[1]));
      return true;
    },
  };

  Parser.registerSubtype(ExynosParser);

  return {
    ExynosParser: ExynosParser
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Parses gesture events in the Linux event trace format.
 */
base.require('importer.linux_perf.parser');
base.exportTo('tracing.importer.linux_perf', function() {

  var Parser = tracing.importer.linux_perf.Parser;

  /**
   * Parses trace events generated by gesture library for touchpad.
   * @constructor
   */
  function GestureParser(importer) {
    Parser.call(this, importer);
    importer.registerEventHandler('tracing_mark_write:log',
        GestureParser.prototype.logEvent.bind(this));
    importer.registerEventHandler('tracing_mark_write:SyncInterpret',
        GestureParser.prototype.syncEvent.bind(this));
    importer.registerEventHandler('tracing_mark_write:HandleTimer',
        GestureParser.prototype.timerEvent.bind(this));
  }

  GestureParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parse events generate by gesture library.
     * gestureOpenSlice and gestureCloseSlice are two common
     * functions to store the begin time and end time for all
     * events in gesture library
     */
    gestureOpenSlice: function(title, ts, opt_args) {
      this.importer.getOrCreatePseudoThread('gesture').thread.beginSlice(
              'touchpad_gesture', title, ts, opt_args);
    },

    gestureCloseSlice: function(title, ts) {
      var thread = this.importer.getOrCreatePseudoThread('gesture').thread;
      if (thread.openSliceCount) {
        var slice = thread.openPartialSlices_[thread.openSliceCount - 1];
        if (slice.title != title) {
           this.importer.importError('Titles do not match. Title is ' +
                                     slice.title + ' in openSlice, and is ' +
                                     title + ' in endSlice');
        } else {
          thread.endSlice(ts);
        }
      }
    },

    /**
     * For log events, events will come in pairs with a tag log:
     * like this:
     * tracing_mark_write: log: start: TimerLogOutputs
     * tracing_mark_write: log: end: TimerLogOutputs
     * which represent the start and the end time of certain log behavior
     * Take these logs above for example, they are the start and end time
     * of logging Output for HandleTimer function
     */
    logEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var innerEvent =
          /^\s*(\w+):\s*(\w+)$/.exec(eventBase.details);
      switch (innerEvent[1]) {
        case 'start':
          this.gestureOpenSlice('GestureLog', ts, {name: innerEvent[2]});
          break;
        case 'end':
          this.gestureCloseSlice('GestureLog', ts);
      }
      return true;
    },

    /**
     * For SyncInterpret events, events will come in pairs with
     * a tag SyncInterpret:
     * like this:
     * tracing_mark_write: SyncInterpret: start: ClickWiggleFilterInterpreter
     * tracing_mark_write: SyncInterpret: end: ClickWiggleFilterInterpreter
     * which represent the start and the end time of SyncInterpret function
     * inside the certain interpreter in the gesture library.
     * Take the logs above for example, they are the start and end time
     * of the SyncInterpret function inside ClickWiggleFilterInterpreter
     */
    syncEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var innerEvent = /^\s*(\w+):\s*(\w+)$/.exec(eventBase.details);
      switch (innerEvent[1]) {
        case 'start':
          this.gestureOpenSlice('SyncInterpret', ts,
                                {interpreter: innerEvent[2]});
          break;
        case 'end':
          this.gestureCloseSlice('SyncInterpret', ts);
      }
      return true;
    },

    /**
     * For HandleTimer events, events will come in pairs with
     * a tag HandleTimer:
     * like this:
     * tracing_mark_write: HandleTimer: start: LookaheadFilterInterpreter
     * tracing_mark_write: HandleTimer: end: LookaheadFilterInterpreter
     * which represent the start and the end time of HandleTimer function
     * inside the certain interpreter in the gesture library.
     * Take the logs above for example, they are the start and end time
     * of the HandleTimer function inside LookaheadFilterInterpreter
     */
    timerEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var innerEvent = /^\s*(\w+):\s*(\w+)$/.exec(eventBase.details);
      switch (innerEvent[1]) {
        case 'start':
          this.gestureOpenSlice('HandleTimer', ts,
                                {interpreter: innerEvent[2]});
          break;
        case 'end':
          this.gestureCloseSlice('HandleTimer', ts);
      }
      return true;
    }
  };

  Parser.registerSubtype(GestureParser);

  return {
    GestureParser: GestureParser
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Parses i915 driver events in the Linux event trace format.
 */
base.require('importer.linux_perf.parser');
base.exportTo('tracing.importer.linux_perf', function() {

  var Parser = tracing.importer.linux_perf.Parser;

  /**
   * Parses linux i915 trace events.
   * @constructor
   */
  function I915Parser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('i915_gem_object_create',
        I915Parser.prototype.gemObjectCreateEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_bind',
        I915Parser.prototype.gemObjectBindEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_unbind',
        I915Parser.prototype.gemObjectBindEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_change_domain',
        I915Parser.prototype.gemObjectChangeDomainEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_pread',
        I915Parser.prototype.gemObjectPreadWriteEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_pwrite',
        I915Parser.prototype.gemObjectPreadWriteEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_fault',
        I915Parser.prototype.gemObjectFaultEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_clflush',
        // NB: reuse destroy handler
        I915Parser.prototype.gemObjectDestroyEvent.bind(this));
    importer.registerEventHandler('i915_gem_object_destroy',
        I915Parser.prototype.gemObjectDestroyEvent.bind(this));
    importer.registerEventHandler('i915_gem_ring_dispatch',
        I915Parser.prototype.gemRingDispatchEvent.bind(this));
    importer.registerEventHandler('i915_gem_ring_flush',
        I915Parser.prototype.gemRingFlushEvent.bind(this));
    importer.registerEventHandler('i915_gem_request',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_add',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_complete',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_retire',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_wait_begin',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_request_wait_end',
        I915Parser.prototype.gemRequestEvent.bind(this));
    importer.registerEventHandler('i915_gem_ring_wait_begin',
        I915Parser.prototype.gemRingWaitEvent.bind(this));
    importer.registerEventHandler('i915_gem_ring_wait_end',
        I915Parser.prototype.gemRingWaitEvent.bind(this));
    importer.registerEventHandler('i915_reg_rw',
        I915Parser.prototype.regRWEvent.bind(this));
    importer.registerEventHandler('i915_flip_request',
        I915Parser.prototype.flipEvent.bind(this));
    importer.registerEventHandler('i915_flip_complete',
        I915Parser.prototype.flipEvent.bind(this));
  }

  I915Parser.prototype = {
    __proto__: Parser.prototype,

    i915FlipOpenSlice: function(ts, obj, plane) {
      // use i915_flip_obj_plane?
      var kthread = this.importer.getOrCreatePseudoThread('i915_flip');
      kthread.openSliceTS = ts;
      kthread.openSlice = 'flip:' + obj + '/' + plane;
    },

    i915FlipCloseSlice: function(ts, args) {
      var kthread = this.importer.getOrCreatePseudoThread('i915_flip');
      if (kthread.openSlice) {
        var slice = new tracing.model.Slice('', kthread.openSlice,
            tracing.getStringColorId(kthread.openSlice),
            kthread.openSliceTS,
            args,
            ts - kthread.openSliceTS);

        kthread.thread.pushSlice(slice);
      }
      kthread.openSlice = undefined;
    },

    i915GemObjectSlice: function(ts, eventName, obj, args) {
      var kthread = this.importer.getOrCreatePseudoThread('i915_gem');
      kthread.openSlice = eventName + ':' + obj;
      var slice = new tracing.model.Slice('', kthread.openSlice,
          tracing.getStringColorId(kthread.openSlice), ts, args, 0);

      kthread.thread.pushSlice(slice);
    },

    i915GemRingSlice: function(ts, eventName, dev, ring, args) {
      var kthread = this.importer.getOrCreatePseudoThread('i915_gem_ring');
      kthread.openSlice = eventName + ':' + dev + '.' + ring;
      var slice = new tracing.model.Slice('', kthread.openSlice,
          tracing.getStringColorId(kthread.openSlice), ts, args, 0);

      kthread.thread.pushSlice(slice);
    },

    i915RegSlice: function(ts, eventName, reg, args) {
      var kthread = this.importer.getOrCreatePseudoThread('i915_reg');
      kthread.openSlice = eventName + ':' + reg;
      var slice = new tracing.model.Slice('', kthread.openSlice,
          tracing.getStringColorId(kthread.openSlice), ts, args, 0);

      kthread.thread.pushSlice(slice);
    },

    /**
     * Parses i915 driver events and sets up state in the importer.
     */
    gemObjectCreateEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /obj=(\w+), size=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var obj = event[1];
      var size = parseInt(event[2]);
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj: obj,
            size: size
          });
      return true;
    },

    gemObjectBindEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO(sleffler) mappable
      var event = /obj=(\w+), offset=(\w+), size=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var obj = event[1];
      var offset = event[2];
      var size = parseInt(event[3]);
      this.i915ObjectGemSlice(ts, eventName + ':' + obj,
          {
            obj: obj,
            offset: offset,
            size: size
          });
      return true;
    },

    gemObjectChangeDomainEvent: function(eventName, cpuNumber, pid, ts,
                                         eventBase) {
      var event = /obj=(\w+), read=(\w+=>\w+), write=(\w+=>\w+)/
          .exec(eventBase.details);
      if (!event)
        return false;

      var obj = event[1];
      var read = event[2];
      var write = event[3];
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj: obj,
            read: read,
            write: write
          });
      return true;
    },

    gemObjectPreadWriteEvent: function(eventName, cpuNumber, pid, ts,
                                       eventBase) {
      var event = /obj=(\w+), offset=(\d+), len=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var obj = event[1];
      var offset = parseInt(event[2]);
      var len = parseInt(event[3]);
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj: obj,
            offset: offset,
            len: len
          });
      return true;
    },

    gemObjectFaultEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO(sleffler) writable
      var event = /obj=(\w+), (\w+) index=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var obj = event[1];
      var type = event[2];
      var index = parseInt(event[3]);
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj: obj,
            type: type,
            index: index
          });
      return true;
    },

    gemObjectDestroyEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /obj=(\w+)/.exec(eventBase.details);
      if (!event)
        return false;

      var obj = event[1];
      this.i915GemObjectSlice(ts, eventName, obj,
          {
            obj: obj
          });
      return true;
    },

    gemRingDispatchEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev=(\d+), ring=(\d+), seqno=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var dev = parseInt(event[1]);
      var ring = parseInt(event[2]);
      var seqno = parseInt(event[3]);
      this.i915GemRingSlice(ts, eventName, dev, ring,
          {
            dev: dev,
            ring: ring,
            seqno: seqno
          });
      return true;
    },

    gemRingFlushEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev=(\d+), ring=(\w+), invalidate=(\w+), flush=(\w+)/
          .exec(eventBase.details);
      if (!event)
        return false;

      var dev = parseInt(event[1]);
      var ring = parseInt(event[2]);
      var invalidate = event[3];
      var flush = event[4];
      this.i915GemRingSlice(ts, eventName, dev, ring,
          {
            dev: dev,
            ring: ring,
            invalidate: invalidate,
            flush: flush
          });
      return true;
    },

    gemRequestEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev=(\d+), ring=(\d+), seqno=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var dev = parseInt(event[1]);
      var ring = parseInt(event[2]);
      var seqno = parseInt(event[3]);
      this.i915GemRingSlice(ts, eventName, dev, ring,
          {
            dev: dev,
            ring: ring,
            seqno: seqno
          });
      return true;
    },

    gemRingWaitEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /dev=(\d+), ring=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      var dev = parseInt(event[1]);
      var ring = parseInt(event[2]);
      this.i915GemRingSlice(ts, eventName, dev, ring,
          {
            dev: dev,
            ring: ring
          });
      return true;
    },

    regRWEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /(\w+) reg=(\w+), len=(\d+), val=(\(\w+, \w+\))/
          .exec(eventBase.details);
      if (!event)
        return false;

      var rw = event[1];
      var reg = event[2];
      var len = event[3];
      var data = event[3];
      this.i915RegSlice(ts, rw, reg,
          {
            rw: rw,
            reg: reg,
            len: len,
            data: data
          });
      return true;
    },

    flipEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /plane=(\d+), obj=(\w+)/.exec(eventBase.details);
      if (!event)
        return false;

      var plane = parseInt(event[1]);
      var obj = event[2];
      if (eventName == 'i915_flip_request')
        this.i915FlipOpenSlice(ts, obj, plane);
      else
        this.i915FlipCloseSlice(ts,
            {
              obj: obj,
              plane: plane
            });
      return true;
    }
  };

  Parser.registerSubtype(I915Parser);

  return {
    I915Parser: I915Parser
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Parses Mali DDK/kernel events in the Linux event trace format.
 */
base.require('importer.linux_perf.parser');
base.exportTo('tracing.importer.linux_perf', function() {

  var Parser = tracing.importer.linux_perf.Parser;

  /**
   * Parses Mali DDK/kernel trace events.
   * @constructor
   */
  function MaliParser(importer) {
    Parser.call(this, importer);

    // kernel DVFS events
    importer.registerEventHandler('mali_dvfs_event',
        MaliParser.prototype.dvfsEventEvent.bind(this));
    importer.registerEventHandler('mali_dvfs_set_clock',
        MaliParser.prototype.dvfsSetClockEvent.bind(this));
    importer.registerEventHandler('mali_dvfs_set_voltage',
        MaliParser.prototype.dvfsSetVoltageEvent.bind(this));

    // kernel Mali hw counter events
    this.addJMCounter('mali_hwc_MESSAGES_SENT', 'Messages Sent');
    this.addJMCounter('mali_hwc_MESSAGES_RECEIVED', 'Messages Received');
    this.addJMCycles('mali_hwc_GPU_ACTIVE', 'GPU Active');
    this.addJMCycles('mali_hwc_IRQ_ACTIVE', 'IRQ Active');

    for (var i = 0; i < 7; i++) {
      var jobStr = 'JS' + i;
      var jobHWCStr = 'mali_hwc_' + jobStr;
      this.addJMCounter(jobHWCStr + '_JOBS', jobStr + ' Jobs');
      this.addJMCounter(jobHWCStr + '_TASKS', jobStr + ' Tasks');
      this.addJMCycles(jobHWCStr + '_ACTIVE', jobStr + ' Active');
      this.addJMCycles(jobHWCStr + '_WAIT_READ', jobStr + ' Wait Read');
      this.addJMCycles(jobHWCStr + '_WAIT_ISSUE', jobStr + ' Wait Issue');
      this.addJMCycles(jobHWCStr + '_WAIT_DEPEND', jobStr + ' Wait Depend');
      this.addJMCycles(jobHWCStr + '_WAIT_FINISH', jobStr + ' Wait Finish');
    }

    this.addTilerCounter('mali_hwc_TRIANGLES', 'Triangles');
    this.addTilerCounter('mali_hwc_QUADS', 'Quads');
    this.addTilerCounter('mali_hwc_POLYGONS', 'Polygons');
    this.addTilerCounter('mali_hwc_POINTS', 'Points');
    this.addTilerCounter('mali_hwc_LINES', 'Lines');
    this.addTilerCounter('mali_hwc_VCACHE_HIT', 'VCache Hit');
    this.addTilerCounter('mali_hwc_VCACHE_MISS', 'VCache Miss');
    this.addTilerCounter('mali_hwc_FRONT_FACING', 'Front Facing');
    this.addTilerCounter('mali_hwc_BACK_FACING', 'Back Facing');
    this.addTilerCounter('mali_hwc_PRIM_VISIBLE', 'Prim Visible');
    this.addTilerCounter('mali_hwc_PRIM_CULLED', 'Prim Culled');
    this.addTilerCounter('mali_hwc_PRIM_CLIPPED', 'Prim Clipped');

    this.addTilerCounter('mali_hwc_WRBUF_HIT', 'Wrbuf Hit');
    this.addTilerCounter('mali_hwc_WRBUF_MISS', 'Wrbuf Miss');
    this.addTilerCounter('mali_hwc_WRBUF_LINE', 'Wrbuf Line');
    this.addTilerCounter('mali_hwc_WRBUF_PARTIAL', 'Wrbuf Partial');
    this.addTilerCounter('mali_hwc_WRBUF_STALL', 'Wrbuf Stall');

    this.addTilerCycles('mali_hwc_ACTIVE', 'Tiler Active');
    this.addTilerCycles('mali_hwc_INDEX_WAIT', 'Index Wait');
    this.addTilerCycles('mali_hwc_INDEX_RANGE_WAIT', 'Index Range Wait');
    this.addTilerCycles('mali_hwc_VERTEX_WAIT', 'Vertex Wait');
    this.addTilerCycles('mali_hwc_PCACHE_WAIT', 'Pcache Wait');
    this.addTilerCycles('mali_hwc_WRBUF_WAIT', 'Wrbuf Wait');
    this.addTilerCycles('mali_hwc_BUS_READ', 'Bus Read');
    this.addTilerCycles('mali_hwc_BUS_WRITE', 'Bus Write');

    this.addTilerCycles('mali_hwc_TILER_UTLB_STALL', 'Tiler UTLB Stall');
    this.addTilerCycles('mali_hwc_TILER_UTLB_HIT', 'Tiler UTLB Hit');

    this.addFragCycles('mali_hwc_FRAG_ACTIVE', 'Active');
    /* NB: don't propagate spelling mistakes to labels */
    this.addFragCounter('mali_hwc_FRAG_PRIMATIVES', 'Primitives');
    this.addFragCounter('mali_hwc_FRAG_PRIMATIVES_DROPPED',
        'Primitives Dropped');
    this.addFragCycles('mali_hwc_FRAG_CYCLE_DESC', 'Descriptor Processing');
    this.addFragCycles('mali_hwc_FRAG_CYCLES_PLR', 'PLR Processing??');
    this.addFragCycles('mali_hwc_FRAG_CYCLES_VERT', 'Vertex Processing');
    this.addFragCycles('mali_hwc_FRAG_CYCLES_TRISETUP', 'Triangle Setup');
    this.addFragCycles('mali_hwc_FRAG_CYCLES_RAST', 'Rasterization???');
    this.addFragCounter('mali_hwc_FRAG_THREADS', 'Threads');
    this.addFragCounter('mali_hwc_FRAG_DUMMY_THREADS', 'Dummy Threads');
    this.addFragCounter('mali_hwc_FRAG_QUADS_RAST', 'Quads Rast');
    this.addFragCounter('mali_hwc_FRAG_QUADS_EZS_TEST', 'Quads EZS Test');
    this.addFragCounter('mali_hwc_FRAG_QUADS_EZS_KILLED', 'Quads EZS Killed');
    this.addFragCounter('mali_hwc_FRAG_QUADS_LZS_TEST', 'Quads LZS Test');
    this.addFragCounter('mali_hwc_FRAG_QUADS_LZS_KILLED', 'Quads LZS Killed');
    this.addFragCycles('mali_hwc_FRAG_CYCLE_NO_TILE', 'No Tiles');
    this.addFragCounter('mali_hwc_FRAG_NUM_TILES', 'Tiles');
    this.addFragCounter('mali_hwc_FRAG_TRANS_ELIM', 'Transactions Eliminated');

    this.addComputeCycles('mali_hwc_COMPUTE_ACTIVE', 'Active');
    this.addComputeCounter('mali_hwc_COMPUTE_TASKS', 'Tasks');
    this.addComputeCounter('mali_hwc_COMPUTE_THREADS', 'Threads Started');
    this.addComputeCycles('mali_hwc_COMPUTE_CYCLES_DESC',
        'Waiting for Descriptors');

    this.addTripipeCycles('mali_hwc_TRIPIPE_ACTIVE', 'Active');

    this.addArithCounter('mali_hwc_ARITH_WORDS', 'Instructions (/Pipes)');
    this.addArithCycles('mali_hwc_ARITH_CYCLES_REG',
        'Reg scheduling stalls (/Pipes)');
    this.addArithCycles('mali_hwc_ARITH_CYCLES_L0',
        'L0 cache miss stalls (/Pipes)');
    this.addArithCounter('mali_hwc_ARITH_FRAG_DEPEND',
        'Frag dep check failures (/Pipes)');

    this.addLSCounter('mali_hwc_LS_WORDS', 'Instruction Words Completed');
    this.addLSCounter('mali_hwc_LS_ISSUES', 'Full Pipeline Issues');
    this.addLSCounter('mali_hwc_LS_RESTARTS', 'Restarts (unpairable insts)');
    this.addLSCounter('mali_hwc_LS_REISSUES_MISS',
        'Pipeline reissue (cache miss/uTLB)');
    this.addLSCounter('mali_hwc_LS_REISSUES_VD',
        'Pipeline reissue (varying data)');
    /* TODO(sleffler) fix kernel event typo */
    this.addLSCounter('mali_hwc_LS_REISSUE_ATTRIB_MISS',
        'Pipeline reissue (attribute cache miss)');
    this.addLSCounter('mali_hwc_LS_REISSUE_NO_WB', 'Writeback not used');

    this.addTexCounter('mali_hwc_TEX_WORDS', 'Words');
    this.addTexCounter('mali_hwc_TEX_BUBBLES', 'Bubbles');
    this.addTexCounter('mali_hwc_TEX_WORDS_L0', 'Words L0');
    this.addTexCounter('mali_hwc_TEX_WORDS_DESC', 'Words Desc');
    this.addTexCounter('mali_hwc_TEX_THREADS', 'Threads');
    this.addTexCounter('mali_hwc_TEX_RECIRC_FMISS', 'Recirc due to Full Miss');
    this.addTexCounter('mali_hwc_TEX_RECIRC_DESC', 'Recirc due to Desc Miss');
    this.addTexCounter('mali_hwc_TEX_RECIRC_MULTI', 'Recirc due to Multipass');
    this.addTexCounter('mali_hwc_TEX_RECIRC_PMISS',
        'Recirc due to Partial Cache Miss');
    this.addTexCounter('mali_hwc_TEX_RECIRC_CONF',
        'Recirc due to Cache Conflict');

    this.addLSCCounter('mali_hwc_LSC_READ_HITS', 'Read Hits');
    this.addLSCCounter('mali_hwc_LSC_READ_MISSES', 'Read Misses');
    this.addLSCCounter('mali_hwc_LSC_WRITE_HITS', 'Write Hits');
    this.addLSCCounter('mali_hwc_LSC_WRITE_MISSES', 'Write Misses');
    this.addLSCCounter('mali_hwc_LSC_ATOMIC_HITS', 'Atomic Hits');
    this.addLSCCounter('mali_hwc_LSC_ATOMIC_MISSES', 'Atomic Misses');
    this.addLSCCounter('mali_hwc_LSC_LINE_FETCHES', 'Line Fetches');
    this.addLSCCounter('mali_hwc_LSC_DIRTY_LINE', 'Dirty Lines');
    this.addLSCCounter('mali_hwc_LSC_SNOOPS', 'Snoops');

    this.addAXICounter('mali_hwc_AXI_TLB_STALL', 'Address channel stall');
    this.addAXICounter('mali_hwc_AXI_TLB_MISS', 'Cache Miss');
    this.addAXICounter('mali_hwc_AXI_TLB_TRANSACTION', 'Transactions');
    this.addAXICounter('mali_hwc_LS_TLB_MISS', 'LS Cache Miss');
    this.addAXICounter('mali_hwc_LS_TLB_HIT', 'LS Cache Hit');
    this.addAXICounter('mali_hwc_AXI_BEATS_READ', 'Read Beats');
    this.addAXICounter('mali_hwc_AXI_BEATS_WRITE', 'Write Beats');

    this.addMMUCounter('mali_hwc_MMU_TABLE_WALK', 'Page Table Walks');
    this.addMMUCounter('mali_hwc_MMU_REPLAY_MISS',
        'Cache Miss from Replay Buffer');
    this.addMMUCounter('mali_hwc_MMU_REPLAY_FULL', 'Replay Buffer Full');
    this.addMMUCounter('mali_hwc_MMU_NEW_MISS', 'Cache Miss on New Request');
    this.addMMUCounter('mali_hwc_MMU_HIT', 'Cache Hit');

    this.addMMUCycles('mali_hwc_UTLB_STALL', 'UTLB Stalled');
    this.addMMUCycles('mali_hwc_UTLB_REPLAY_MISS', 'UTLB Replay Miss');
    this.addMMUCycles('mali_hwc_UTLB_REPLAY_FULL', 'UTLB Replay Full');
    this.addMMUCycles('mali_hwc_UTLB_NEW_MISS', 'UTLB New Miss');
    this.addMMUCycles('mali_hwc_UTLB_HIT', 'UTLB Hit');

    this.addL2Counter('mali_hwc_L2_READ_BEATS', 'Read Beats');
    this.addL2Counter('mali_hwc_L2_WRITE_BEATS', 'Write Beats');
    this.addL2Counter('mali_hwc_L2_ANY_LOOKUP', 'Any Lookup');
    this.addL2Counter('mali_hwc_L2_READ_LOOKUP', 'Read Lookup');
    this.addL2Counter('mali_hwc_L2_SREAD_LOOKUP', 'Shareable Read Lookup');
    this.addL2Counter('mali_hwc_L2_READ_REPLAY', 'Read Replayed');
    this.addL2Counter('mali_hwc_L2_READ_SNOOP', 'Read Snoop');
    this.addL2Counter('mali_hwc_L2_READ_HIT', 'Read Cache Hit');
    this.addL2Counter('mali_hwc_L2_CLEAN_MISS', 'CleanUnique Miss');
    this.addL2Counter('mali_hwc_L2_WRITE_LOOKUP', 'Write Lookup');
    this.addL2Counter('mali_hwc_L2_SWRITE_LOOKUP', 'Shareable Write Lookup');
    this.addL2Counter('mali_hwc_L2_WRITE_REPLAY', 'Write Replayed');
    this.addL2Counter('mali_hwc_L2_WRITE_SNOOP', 'Write Snoop');
    this.addL2Counter('mali_hwc_L2_WRITE_HIT', 'Write Cache Hit');
    this.addL2Counter('mali_hwc_L2_EXT_READ_FULL', 'ExtRD with BIU Full');
    this.addL2Counter('mali_hwc_L2_EXT_READ_HALF', 'ExtRD with BIU >1/2 Full');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE_FULL', 'ExtWR with BIU Full');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE_HALF', 'ExtWR with BIU >1/2 Full');

    this.addL2Counter('mali_hwc_L2_EXT_READ', 'External Read (ExtRD)');
    this.addL2Counter('mali_hwc_L2_EXT_READ_LINE', 'ExtRD (linefill)');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE', 'External Write (ExtWR)');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE_LINE', 'ExtWR (linefill)');
    this.addL2Counter('mali_hwc_L2_EXT_WRITE_SMALL', 'ExtWR (burst size <64B)');
    this.addL2Counter('mali_hwc_L2_EXT_BARRIER', 'External Barrier');
    this.addL2Counter('mali_hwc_L2_EXT_AR_STALL', 'Address Read stalls');
    this.addL2Counter('mali_hwc_L2_EXT_R_BUF_FULL',
        'Response Buffer full stalls');
    this.addL2Counter('mali_hwc_L2_EXT_RD_BUF_FULL',
        'Read Data Buffer full stalls');
    this.addL2Counter('mali_hwc_L2_EXT_R_RAW', 'RAW hazard stalls');
    this.addL2Counter('mali_hwc_L2_EXT_W_STALL', 'Write Data stalls');
    this.addL2Counter('mali_hwc_L2_EXT_W_BUF_FULL', 'Write Data Buffer full');
    this.addL2Counter('mali_hwc_L2_EXT_R_W_HAZARD', 'WAW or WAR hazard stalls');
    this.addL2Counter('mali_hwc_L2_TAG_HAZARD', 'Tag hazard replays');
    this.addL2Cycles('mali_hwc_L2_SNOOP_FULL', 'Snoop buffer full');
    this.addL2Cycles('mali_hwc_L2_REPLAY_FULL', 'Replay buffer full');

    // DDK events (from X server)
    importer.registerEventHandler('tracing_mark_write:mali_driver',
        MaliParser.prototype.maliDDKEvent.bind(this));

    this.model_ = importer.model_;
  }

  MaliParser.prototype = {
    __proto__: Parser.prototype,

    maliDDKOpenSlice: function(pid, tid, ts, func, blockinfo) {
      var thread = this.importer.model_.getOrCreateProcess(pid)
        .getOrCreateThread(tid);
      var funcArgs = /^([\w\d_]*)(?:\(\))?:?\s*(.*)$/.exec(func);
      thread.beginSlice('gpu-driver', funcArgs[1], ts,
          { 'args': funcArgs[2],
            'blockinfo': blockinfo });
    },

    maliDDKCloseSlice: function(pid, tid, ts, args, blockinfo) {
      var thread = this.importer.model_.getOrCreateProcess(pid)
        .getOrCreateThread(tid);
      if (!thread.openSliceCount) {
        // Discard unmatched ends.
        return;
      }
      thread.endSlice(ts);
    },

    /**
     * Deduce the format of Mali perf events.
     *
     * @return {RegExp} the regular expression for parsing data when the format
     * is recognized; otherwise null.
     */
    autoDetectLineRE: function(line) {
      // Matches Mali perf events with thread info
      var lineREWithThread =
        /^\s*\(([\w\-]*)\)\s*(\w+):\s*([\w\\\/\.\-]*@\d*):?\s*(.*)$/;
      if (lineREWithThread.test(line))
        return lineREWithThread;

      // Matches old-style Mali perf events
      var lineRENoThread = /^s*()(\w+):\s*([\w\\\/.\-]*):?\s*(.*)$/;
      if (lineRENoThread.test(line))
        return lineRENoThread;
      return null;
    },

    lineRE: null,

    /**
     * Parses maliDDK events and sets up state in the importer.
     * events will come in pairs with a cros_trace_print_enter
     * like this (line broken here for formatting):
     *
     * tracing_mark_write: mali_driver: (mali-012345) cros_trace_print_enter: \
     *   gles/src/texture/mali_gles_texture_slave.c@1505: gles2_texturep_upload
     *
     * and a cros_trace_print_exit like this:
     *
     * tracing_mark_write: mali_driver: (mali-012345) cros_trace_print_exit: \
     *   gles/src/texture/mali_gles_texture_slave.c@1505:
     */
    maliDDKEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      if (this.lineRE == null) {
        this.lineRE = this.autoDetectLineRE(eventBase.details);
        if (this.lineRE == null)
          return false;
      }
      var maliEvent = this.lineRE.exec(eventBase.details);
      // Old-style Mali perf events have no thread id, so make one.
      var tid = (maliEvent[1] === '' ? 'mali' : maliEvent[1]);
      switch (maliEvent[2]) {
        case 'cros_trace_print_enter':
          this.maliDDKOpenSlice(pid, tid, ts, maliEvent[4],
              maliEvent[3]);
          break;
        case 'cros_trace_print_exit':
          this.maliDDKCloseSlice(pid, tid, ts, [], maliEvent[3]);
      }
      return true;
    },

    /*
     * Kernel event support.
     */

    dvfsSample: function(counterName, seriesName, ts, s) {
      var value = parseInt(s);
      var counter = this.model_.getOrCreateProcess(0).
          getOrCreateCounter('DVFS', counterName);
      if (counter.numSeries == 0) {
        counter.seriesNames.push(seriesName);
        counter.seriesColors.push(tracing.getStringColorId(counter.name));
      }
      counter.timestamps.push(ts);
      counter.samples.push(value);
    },

    dvfsEventEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /utilization=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      this.dvfsSample('DVFS Utilization', 'utilization', ts, event[1]);
      return true;
    },

    dvfsSetClockEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /frequency=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      this.dvfsSample('DVFS Frequency', 'frequency', ts, event[1]);
      return true;
    },

    dvfsSetVoltageEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /voltage=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;

      this.dvfsSample('DVFS Voltage', 'voltage', ts, event[1]);
      return true;
    },

    hwcSample: function(cat, counterName, seriesName, ts, eventBase) {
      var event = /val=(\d+)/.exec(eventBase.details);
      if (!event)
        return false;
      var value = parseInt(event[1]);

      var counter = this.model_.getOrCreateProcess(0).
          getOrCreateCounter(cat, counterName);
      if (counter.numSeries == 0) {
        counter.seriesNames.push(seriesName);
        counter.seriesColors.push(tracing.getStringColorId(counter.name));
      }
      counter.timestamps.push(ts);
      counter.samples.push(value);
      return true;
    },

    /*
     * Job Manager block counters.
     */
    jmSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:jm', 'JM: ' + ctrName, seriesName, ts,
          eventBase);
    },
    addJMCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.jmSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addJMCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.jmSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Tiler block counters.
     */
    tilerSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:tiler', 'Tiler: ' + ctrName, seriesName,
          ts, eventBase);
    },
    addTilerCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.tilerSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addTilerCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.tilerSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Fragment counters.
     */
    fragSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:fragment', 'Fragment: ' + ctrName,
          seriesName, ts, eventBase);
    },
    addFragCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.fragSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addFragCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.fragSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Compute counters.
     */
    computeSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:compute', 'Compute: ' + ctrName,
          seriesName, ts, eventBase);
    },
    addComputeCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.computeSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addComputeCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.computeSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Tripipe counters.
     */
    addTripipeCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.hwcSample('mali:shader', 'Tripipe: ' + hwcTitle, 'cycles',
            ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Arith counters.
     */
    arithSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:arith', 'Arith: ' + ctrName, seriesName, ts,
          eventBase);
    },
    addArithCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.arithSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addArithCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.arithSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Load/Store counters.
     */
    addLSCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.hwcSample('mali:ls', 'LS: ' + hwcTitle, 'count', ts,
            eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * Texture counters.
     */
    textureSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:texture', 'Texture: ' + ctrName,
          seriesName, ts, eventBase);
    },
    addTexCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.textureSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * LSC counters.
     */
    addLSCCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.hwcSample('mali:lsc', 'LSC: ' + hwcTitle, 'count', ts,
            eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * TLB counters.
     */
    addAXICounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.hwcSample('mali:axi', 'AXI: ' + hwcTitle, 'count', ts,
            eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * MMU counters.
     */
    mmuSample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:mmu', 'MMU: ' + ctrName, seriesName, ts,
          eventBase);
    },
    addMMUCounter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.mmuSample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addMMUCycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.mmuSample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },

    /*
     * L2 counters.
     */
    l2Sample: function(ctrName, seriesName, ts, eventBase) {
      return this.hwcSample('mali:l2', 'L2: ' + ctrName, seriesName, ts,
          eventBase);
    },
    addL2Counter: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.l2Sample(hwcTitle, 'count', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    },
    addL2Cycles: function(hwcEventName, hwcTitle) {
      function handler(eventName, cpuNumber, pid, ts, eventBase) {
        return this.l2Sample(hwcTitle, 'cycles', ts, eventBase);
      }
      this.importer.registerEventHandler(hwcEventName, handler.bind(this));
    }
  };

  Parser.registerSubtype(MaliParser);

  return {
    MaliParser: MaliParser
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Parses power events in the Linux event trace format.
 */
base.require('importer.linux_perf.parser');
base.exportTo('tracing.importer.linux_perf', function() {

  var Parser = tracing.importer.linux_perf.Parser;

  /**
   * Parses linux power trace events.
   * @constructor
   */
  function PowerParser(importer) {
    Parser.call(this, importer);

    // NB: old-style power events, deprecated
    importer.registerEventHandler('power_start',
        PowerParser.prototype.powerStartEvent.bind(this));
    importer.registerEventHandler('power_frequency',
        PowerParser.prototype.powerFrequencyEvent.bind(this));

    importer.registerEventHandler('cpu_frequency',
        PowerParser.prototype.cpuFrequencyEvent.bind(this));
    importer.registerEventHandler('cpu_idle',
        PowerParser.prototype.cpuIdleEvent.bind(this));
  }

  PowerParser.prototype = {
    __proto__: Parser.prototype,

    cpuStateSlice: function(ts, targetCpuNumber, eventType, cpuState) {
      var targetCpu = this.importer.getOrCreateCpuState(targetCpuNumber);
      var powerCounter;
      if (eventType != '1') {
        this.importer.importError('Don\'t understand power_start events of ' +
            'type ' + eventType);
        return;
      }
      powerCounter = targetCpu.cpu.getOrCreateCounter('', 'C-State');
      if (powerCounter.numSeries == 0) {
        powerCounter.seriesNames.push('state');
        powerCounter.seriesColors.push(
            tracing.getStringColorId(powerCounter.name + '.' + 'state'));
      }
      powerCounter.timestamps.push(ts);
      powerCounter.samples.push(cpuState);
    },

    cpuIdleSlice: function(ts, targetCpuNumber, cpuState) {
      var targetCpu = this.importer.getOrCreateCpuState(targetCpuNumber);
      var powerCounter = targetCpu.cpu.getOrCreateCounter('', 'C-State');
      if (powerCounter.numSeries == 0) {
        powerCounter.seriesNames.push('state');
        powerCounter.seriesColors.push(
            tracing.getStringColorId(powerCounter.name));
      }
      // NB: 4294967295/-1 means an exit from the current state
      if (cpuState != 4294967295)
        powerCounter.samples.push(cpuState);
      else
        powerCounter.samples.push(0);
      powerCounter.timestamps.push(ts);
    },

    cpuFrequencySlice: function(ts, targetCpuNumber, powerState) {
      var targetCpu = this.importer.getOrCreateCpuState(targetCpuNumber);
      var powerCounter =
          targetCpu.cpu.getOrCreateCounter('', 'Clock Frequency');
      if (powerCounter.numSeries == 0) {
        powerCounter.seriesNames.push('state');
        powerCounter.seriesColors.push(
            tracing.getStringColorId(powerCounter.name + '.' + 'state'));
      }
      powerCounter.timestamps.push(ts);
      powerCounter.samples.push(powerState);
    },

    /**
     * Parses power events and sets up state in the importer.
     */
    powerStartEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /type=(\d+) state=(\d) cpu_id=(\d)+/.exec(eventBase.details);
      if (!event)
        return false;

      var targetCpuNumber = parseInt(event[3]);
      var cpuState = parseInt(event[2]);
      this.cpuStateSlice(ts, targetCpuNumber, event[1], cpuState);
      return true;
    },

    powerFrequencyEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /type=(\d+) state=(\d+) cpu_id=(\d)+/
          .exec(eventBase.details);
      if (!event)
        return false;

      var targetCpuNumber = parseInt(event[3]);
      var powerState = parseInt(event[2]);
      this.cpuFrequencySlice(ts, targetCpuNumber, powerState);
      return true;
    },

    cpuFrequencyEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /state=(\d+) cpu_id=(\d)+/.exec(eventBase.details);
      if (!event)
        return false;

      var targetCpuNumber = parseInt(event[2]);
      var powerState = parseInt(event[1]);
      this.cpuFrequencySlice(ts, targetCpuNumber, powerState);
      return true;
    },

    cpuIdleEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /state=(\d+) cpu_id=(\d)+/.exec(eventBase.details);
      if (!event)
        return false;

      var targetCpuNumber = parseInt(event[2]);
      var cpuState = parseInt(event[1]);
      this.cpuIdleSlice(ts, targetCpuNumber, cpuState);
      return true;
    }
  };

  Parser.registerSubtype(PowerParser);

  return {
    PowerParser: PowerParser
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Parses scheduler events in the Linux event trace format.
 */
base.require('importer.linux_perf.parser');
base.exportTo('tracing.importer.linux_perf', function() {

  var Parser = tracing.importer.linux_perf.Parser;

  /**
   * Parses linux sched trace events.
   * @constructor
   */
  function SchedParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('sched_switch',
        SchedParser.prototype.schedSwitchEvent.bind(this));
    importer.registerEventHandler('sched_wakeup',
        SchedParser.prototype.schedWakeupEvent.bind(this));
  }

  TestExports = {};

  // Matches the sched_switch record
  var schedSwitchRE = new RegExp(
      'prev_comm=(.+) prev_pid=(\\d+) prev_prio=(\\d+) ' +
      'prev_state=(\\S\\+?|\\S\\|\\S) ==> ' +
      'next_comm=(.+) next_pid=(\\d+) next_prio=(\\d+)');
  TestExports.schedSwitchRE = schedSwitchRE;

  // Matches the sched_wakeup record
  var schedWakeupRE =
      /comm=(.+) pid=(\d+) prio=(\d+) success=(\d+) target_cpu=(\d+)/;
  TestExports.schedWakeupRE = schedWakeupRE;

  SchedParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses scheduler events and sets up state in the importer.
     */
    schedSwitchEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = schedSwitchRE.exec(eventBase.details);
      if (!event)
        return false;

      var prevState = event[4];
      var nextComm = event[5];
      var nextPid = parseInt(event[6]);
      var nextPrio = parseInt(event[7]);

      var cpuState = this.importer.getOrCreateCpuState(cpuNumber);
      cpuState.switchRunningLinuxPid(this.importer,
          prevState, ts, nextPid, nextComm, nextPrio);
      return true;
    },

    schedWakeupEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = schedWakeupRE.exec(eventBase.details);
      if (!event)
        return false;

      var fromPid = pid;
      var comm = event[1];
      var pid = parseInt(event[2]);
      var prio = parseInt(event[3]);
      this.importer.markPidRunnable(ts, pid, comm, prio, fromPid);
      return true;
    }
  };

  Parser.registerSubtype(SchedParser);

  return {
    SchedParser: SchedParser,
    _SchedParserTestExports: TestExports
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Parses workqueue events in the Linux event trace format.
 */
base.require('importer.linux_perf.parser');
base.exportTo('tracing.importer.linux_perf', function() {

  var Parser = tracing.importer.linux_perf.Parser;

  /**
   * Parses linux workqueue trace events.
   * @constructor
   */
  function WorkqueueParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('workqueue_execute_start',
        WorkqueueParser.prototype.executeStartEvent.bind(this));
    importer.registerEventHandler('workqueue_execute_end',
        WorkqueueParser.prototype.executeEndEvent.bind(this));
    importer.registerEventHandler('workqueue_queue_work',
        WorkqueueParser.prototype.executeQueueWork.bind(this));
    importer.registerEventHandler('workqueue_activate_work',
        WorkqueueParser.prototype.executeActivateWork.bind(this));
  }

  // Matches the workqueue_execute_start record
  //  workqueue_execute_start: work struct c7a8a89c: function MISRWrapper
  var workqueueExecuteStartRE = /work struct (.+): function (\S+)/;

  // Matches the workqueue_execute_start record
  //  workqueue_execute_end: work struct c7a8a89c
  var workqueueExecuteEndRE = /work struct (.+)/;

  WorkqueueParser.prototype = {
    __proto__: Parser.prototype,

    /**
     * Parses workqueue events and sets up state in the importer.
     */
    executeStartEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = workqueueExecuteStartRE.exec(eventBase.details);
      if (!event)
        return false;

      var kthread = this.importer.getOrCreateKernelThread(eventBase.threadName,
        pid, pid);
      kthread.openSliceTS = ts;
      kthread.openSlice = event[2];
      return true;
    },

    executeEndEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = workqueueExecuteEndRE.exec(eventBase.details);
      if (!event)
        return false;

      var kthread = this.importer.getOrCreateKernelThread(eventBase.threadName,
        pid, pid);
      if (kthread.openSlice) {
        var slice = new tracing.model.Slice('', kthread.openSlice,
            tracing.getStringColorId(kthread.openSlice),
            kthread.openSliceTS,
            {},
            ts - kthread.openSliceTS);

        kthread.thread.pushSlice(slice);
      }
      kthread.openSlice = undefined;
      return true;
    },

    executeQueueWork: function(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO: Do something with this event?
      return true;
    },

    executeActivateWork: function(eventName, cpuNumber, pid, ts, eventBase) {
      // TODO: Do something with this event?
      return true;
    },

  };

  Parser.registerSubtype(WorkqueueParser);

  return {
    WorkqueueParser: WorkqueueParser
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Parses trace_marker events that were inserted in the trace by
 * userland.
 */
base.require('importer.linux_perf.parser');
base.exportTo('tracing.importer.linux_perf', function() {

  var Parser = tracing.importer.linux_perf.Parser;

  /**
   * Parses linux trace mark events that were inserted in the trace by userland.
   * @constructor
   */
  function AndroidParser(importer) {
    Parser.call(this, importer);

    importer.registerEventHandler('tracing_mark_write:android',
        AndroidParser.prototype.traceMarkWriteAndroidEvent.bind(this));
    importer.registerEventHandler('0:android',
        AndroidParser.prototype.traceMarkWriteAndroidEvent.bind(this));

    this.model_ = importer.model_;
    this.ppids_ = {};
  }

  function parseArgs(argsString) {
    var args = {};
    if (argsString) {
      var argsArray = argsString.split(';');
      for (var i = 0; i < argsArray.length; ++i) {
        var parts = argsArray[i].split('=');
        if (parts[0])
          args[parts.shift()] = parts.join('=');
      }
    }
    return args;
  }

  AndroidParser.prototype = {
    __proto__: Parser.prototype,

    traceMarkWriteAndroidEvent: function(eventName, cpuNumber, pid, ts,
                                  eventBase) {
      var eventData = eventBase.details.split('|');
      switch (eventData[0]) {
        case 'B':
          var ppid = parseInt(eventData[1]);
          var category = eventData[4];
          var title = eventData[2];
          var thread = this.model_.getOrCreateProcess(ppid)
            .getOrCreateThread(pid);
          thread.name = eventBase.threadName;
          if (!thread.isTimestampValidForBeginOrEnd(ts)) {
            this.model_.importErrors.push(
                'Timestamps are moving backward.');
            return false;
          }

          this.ppids_[pid] = ppid;
          thread.beginSlice(category, title, ts, parseArgs(eventData[3]));

          break;
        case 'E':
          var ppid = this.ppids_[pid];
          if (ppid === undefined) {
            // Silently ignore unmatched E events.
            break;
          }

          var thread = this.model_.getOrCreateProcess(ppid)
            .getOrCreateThread(pid);
          if (!thread.openSliceCount) {
            // Silently ignore unmatched E events.
            break;
          }

          var slice = thread.endSlice(ts);

          var args = parseArgs(eventData[3]);
          for (var arg in args) {
            if (slice.args[arg] !== undefined) {
              this.model_.importErrors.push(
                  'Both the B and E events of ' + slice.title +
                  'provided values for argument ' + arg + '. ' +
                  'The value of the E event will be used.');
            }
            slice.args[arg] = args[arg];
          }

          break;
        case 'C':
          var ppid = parseInt(eventData[1]);
          var name = eventData[2];
          var value = parseInt(eventData[3]);
          var category = eventData[4];

          var ctr = this.model_.getOrCreateProcess(ppid)
              .getOrCreateCounter(category, name);
          // Initialize the counter's series fields if needed.
          if (ctr.numSeries == 0) {
            ctr.seriesNames.push('value');
            ctr.seriesColors.push(
                tracing.getStringColorId(ctr.name + '.' + 'value'));
          }

          // Add the sample value.
          ctr.timestamps.push(ts);
          ctr.samples.push(value);

          break;
        default:
          return false;
      }

      return true;
    },
  };

  Parser.registerSubtype(AndroidParser);

  return {
    AndroidParser: AndroidParser
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Imports text files in the Linux event trace format into the
 * model. This format is output both by sched_trace and by Linux's perf
 * tool.
 *
 * This importer assumes the events arrive as a string. The unit tests provide
 * examples of the trace format.
 *
 * Linux scheduler traces use a definition for 'pid' that is different than
 * tracing uses. Whereas tracing uses pid to identify a specific process, a pid
 * in a linux trace refers to a specific thread within a process. Within this
 * file, we the definition used in Linux traces, as it improves the importing
 * code's readability.
 */
'use strict';

base.require('model');
base.require('color_scheme');
base.require('importer.linux_perf.bus_parser');
base.require('importer.linux_perf.clock_parser');
base.require('importer.linux_perf.cpufreq_parser');
base.require('importer.linux_perf.disk_parser');
base.require('importer.linux_perf.drm_parser');
base.require('importer.linux_perf.exynos_parser');
base.require('importer.linux_perf.gesture_parser');
base.require('importer.linux_perf.i915_parser');
base.require('importer.linux_perf.mali_parser');
base.require('importer.linux_perf.power_parser');
base.require('importer.linux_perf.sched_parser');
base.require('importer.linux_perf.workqueue_parser');
base.require('importer.linux_perf.android_parser');

base.exportTo('tracing.importer', function() {
  /**
   * Represents the scheduling state for a single thread.
   * @constructor
   */
  function CpuState(cpu) {
    this.cpu = cpu;
  }

  CpuState.prototype = {
    __proto__: Object.prototype,

    /**
     * Switches the active pid on this Cpu. If necessary, add a Slice
     * to the cpu representing the time spent on that Cpu since the last call to
     * switchRunningLinuxPid.
     */
    switchRunningLinuxPid: function(importer, prevState, ts, pid, comm, prio) {
      // Generate a slice if the last active pid was not the idle task
      if (this.lastActivePid !== undefined && this.lastActivePid != 0) {
        var duration = ts - this.lastActiveTs;
        var thread = importer.threadsByLinuxPid[this.lastActivePid];
        var name;
        if (thread)
          name = thread.userFriendlyName;
        else
          name = this.lastActiveComm;

        var slice = new tracing.model.Slice('', name,
                                            tracing.getStringColorId(name),
                                            this.lastActiveTs,
                                            {
                                              comm: this.lastActiveComm,
                                              tid: this.lastActivePid,
                                              prio: this.lastActivePrio,
                                              stateWhenDescheduled: prevState
                                            },
                                            duration);
        this.cpu.slices.push(slice);
      }

      this.lastActiveTs = ts;
      this.lastActivePid = pid;
      this.lastActiveComm = comm;
      this.lastActivePrio = prio;
    }
  };

  /**
   * Imports linux perf events into a specified model.
   * @constructor
   */
  function LinuxPerfImporter(model, events) {
    this.importPriority = 2;
    this.model_ = model;
    this.events_ = events;
    this.clockSyncRecords_ = [];
    this.cpuStates_ = {};
    this.wakeups_ = [];
    this.kernelThreadStates_ = {};
    this.buildMapFromLinuxPidsToThreads();
    this.lineNumberBase = 0;
    this.lineNumber = -1;
    this.pseudoThreadCounter = 1;
    this.parsers_ = [];
    this.eventHandlers_ = {};
  }

  TestExports = {};

  // Matches the trace record in 3.2 and later with the print-tgid option:
  //          <idle>-0    0 [001] d...  1.23: sched_switch
  //
  // A TGID (Thread Group ID) is basically what the Linux kernel calls what
  // userland refers to as a process ID (as opposed to a Linux pid, which is
  // what userland calls a thread ID).
  var lineREWithTGID = new RegExp(
      '^\\s*(.+)-(\\d+)\\s+\\(\\s*(\\d+|-+)\\)\\s\\[(\\d+)\\]' +
      '\\s+[dX.][N.][Hhs.][0-9a-f.]' +
      '\\s+(\\d+\\.\\d+):\\s+(\\S+):\\s(.*)$');
  var lineParserWithTGID = function(line) {
    var groups = lineREWithTGID.exec(line);
    if (!groups) {
      return groups;
    }

    var tgid = groups[3];
    if (tgid[0] === '-')
      tgid = undefined;

    return {
      threadName: groups[1],
      pid: groups[2],
      tgid: tgid,
      cpuNumber: groups[4],
      timestamp: groups[5],
      eventName: groups[6],
      details: groups[7]
    };
  }
  TestExports.lineParserWithTGID = lineParserWithTGID;

  // Matches the default trace record in 3.2 and later (includes irq-info):
  //          <idle>-0     [001] d...  1.23: sched_switch
  var lineREWithIRQInfo = new RegExp(
      '^\\s*(.+)-(\\d+)\\s+\\[(\\d+)\\]' +
      '\\s+[dX.][N.][Hhs.][0-9a-f.]' +
      '\\s+(\\d+\\.\\d+):\\s+(\\S+):\\s(.*)$');
  var lineParserWithIRQInfo = function(line) {
    var groups = lineREWithIRQInfo.exec(line);
    if (!groups) {
      return groups;
    }
    return {
      threadName: groups[1],
      pid: groups[2],
      cpuNumber: groups[3],
      timestamp: groups[4],
      eventName: groups[5],
      details: groups[6]
    };
  }
  TestExports.lineParserWithIRQInfo = lineParserWithIRQInfo;

  // Matches the default trace record pre-3.2:
  //          <idle>-0     [001]  1.23: sched_switch
  var lineREWithLegacyFmt =
    /^\s*(.+)-(\d+)\s+\[(\d+)\]\s*(\d+\.\d+):\s+(\S+):\s(.*)$/;
  var lineParserWithLegacyFmt = function(line) {
    var groups = lineREWithLegacyFmt.exec(line);
    if (!groups) {
      return groups;
    }
    return {
      threadName: groups[1],
      pid: groups[2],
      cpuNumber: groups[3],
      timestamp: groups[4],
      eventName: groups[5],
      details: groups[6]
    };
  }
  TestExports.lineParserWithLegacyFmt = lineParserWithLegacyFmt;

  // Matches the trace_event_clock_sync record
  //  0: trace_event_clock_sync: parent_ts=19581477508
  var traceEventClockSyncRE = /trace_event_clock_sync: parent_ts=(\d+\.?\d*)/;
  TestExports.traceEventClockSyncRE = traceEventClockSyncRE;

  // Some kernel trace events are manually classified in slices and
  // hand-assigned a pseudo PID.
  var pseudoKernelPID = 0;

  /**
   * Deduce the format of trace data. Linix kernels prior to 3.3 used one
   * format (by default); 3.4 and later used another.  Additionally, newer
   * kernels can optionally trace the TGID.
   *
   * @return {function} the function for parsing data when the format is
   * recognized; otherwise null.
   */
  function autoDetectLineParser(line) {
    if (lineREWithTGID.test(line))
      return lineParserWithTGID;
    if (lineREWithIRQInfo.test(line))
      return lineParserWithIRQInfo;
    if (lineREWithLegacyFmt.test(line))
      return lineParserWithLegacyFmt;
    return null;
  };
  TestExports.autoDetectLineParser = autoDetectLineParser;

  /**
   * Guesses whether the provided events is a Linux perf string.
   * Looks for the magic string "# tracer" at the start of the file,
   * or the typical task-pid-cpu-timestamp-function sequence of a typical
   * trace's body.
   *
   * @return {boolean} True when events is a linux perf array.
   */
  LinuxPerfImporter.canImport = function(events) {
    if (!(typeof(events) === 'string' || events instanceof String))
      return false;

    if (LinuxPerfImporter._extractEventsFromSystraceHTML(events, false).ok)
      return true;

    if (/^# tracer:/.test(events))
      return true;

    var m = /^(.+)\n/.exec(events);
    if (m)
      events = m[1];
    if (autoDetectLineParser(events))
      return true;

    return false;
  };

  LinuxPerfImporter._extractEventsFromSystraceHTML = function(
    incoming_events, produce_result) {
    var failure = {ok: false};
    if (produce_result === undefined)
      produce_result = true;

    if (/^<!DOCTYPE HTML>/.test(incoming_events) == false)
      return failure;
    var lines = incoming_events.split('\n');
    var cur_line = 1;
    function advanceToLineMatching(regex) {
      for (; cur_line < lines.length; cur_line++) {
        if (regex.test(lines[cur_line]))
          return true;
      }
      return false;
    }

    // Try to find the data...
    if (!advanceToLineMatching(/^  <script>$/))
      return failure;
    if (!advanceToLineMatching(/^  var linuxPerfData = "\\$/))
      return failure;
    var events_begin_at_line = cur_line + 1;

    if (!advanceToLineMatching(/^  <\/script>$/))
      return failure;
    var events_end_at_line = cur_line;

    if (!advanceToLineMatching(/^<\/body>$/))
      return failure;
    if (!advanceToLineMatching(/^<\/html>$/))
      return failure;

    var raw_events = lines.slice(events_begin_at_line,
                                 events_end_at_line);
    function endsWith(str, suffix) {
      return str.indexOf(suffix, str.length - suffix.length) !== -1;
    }
    function stripSuffix(str, suffix) {
      if (!endsWith(str, suffix))
        return str;
      return str.substring(str, str.length - suffix.length);
    }

    // Strip off escaping in the file needed to preserve linebreaks.
    var events = [];
    if (produce_result) {
      for (var i = 0; i < raw_events.length; i++) {
        var event = raw_events[i];
        event = stripSuffix(event, '\\n\\');
        events.push(event);
      }
    } else {
      events = [raw_events[raw_events.length - 1]];
    }

    // Last event ends differently. Strip that off too,
    // treating absence of that trailing stirng as a failure.
    var oldLastEvent = events[events.length - 1];
    var newLastEvent = stripSuffix(oldLastEvent, '\\n";');
    if (newLastEvent == oldLastEvent)
      return failure;
    events[events.length - 1] = newLastEvent;

    return {ok: true,
            lines: produce_result ? events : undefined,
            events_begin_at_line: events_begin_at_line};
  }

  LinuxPerfImporter.prototype = {
    __proto__: Object.prototype,

    get model() {
      return this.model_;
    },

    /**
     * Precomputes a lookup table from linux pids back to existing
     * Threads. This is used during importing to add information to each
     * thread about whether it was running, descheduled, sleeping, et
     * cetera.
     */
    buildMapFromLinuxPidsToThreads: function() {
      this.threadsByLinuxPid = {};
      this.model_.getAllThreads().forEach(
          function(thread) {
            this.threadsByLinuxPid[thread.tid] = thread;
          }.bind(this));
    },

    /**
     * @return {CpuState} A CpuState corresponding to the given cpuNumber.
     */
    getOrCreateCpuState: function(cpuNumber) {
      if (!this.cpuStates_[cpuNumber]) {
        var cpu = this.model_.getOrCreateCpu(cpuNumber);
        this.cpuStates_[cpuNumber] = new CpuState(cpu);
      }
      return this.cpuStates_[cpuNumber];
    },

    /**
     * @return {TimelinThread} A thread corresponding to the kernelThreadName.
     */
    getOrCreateKernelThread: function(kernelThreadName, pid, tid) {
      if (!this.kernelThreadStates_[kernelThreadName]) {
        var thread = this.model_.getOrCreateProcess(pid).getOrCreateThread(tid);
        thread.name = kernelThreadName;
        this.kernelThreadStates_[kernelThreadName] = {
          pid: pid,
          thread: thread,
          openSlice: undefined,
          openSliceTS: undefined
        };
        this.threadsByLinuxPid[pid] = thread;
      }
      return this.kernelThreadStates_[kernelThreadName];
    },

    /**
     * @return {TimelinThread} A pseudo thread corresponding to the
     * threadName.  Pseudo threads are for events that we want to break
     * out to a separate timeline but would not otherwise happen.
     * These threads are assigned to pseudoKernelPID and given a
     * unique (incrementing) TID.
     */
    getOrCreatePseudoThread: function(threadName) {
      var thread = this.kernelThreadStates_[threadName];
      if (!thread) {
        thread = this.getOrCreateKernelThread(threadName, pseudoKernelPID,
            this.pseudoThreadCounter);
        this.pseudoThreadCounter++;
      }
      return thread;
    },

    /**
     * Imports the data in this.events_ into model_.
     */
    importEvents: function(isSecondaryImport) {
      this.createParsers();
      this.importCpuData();
      if (!this.alignClocks(isSecondaryImport))
        return;
      this.buildMapFromLinuxPidsToThreads();
      this.buildPerThreadCpuSlicesFromCpuState();
    },

    /**
     * Called by the Model after all other importers have imported their
     * events.
     */
    finalizeImport: function() {
    },

    /**
     * Builds the cpuSlices array on each thread based on our knowledge of what
     * each Cpu is doing.  This is done only for Threads that are
     * already in the model, on the assumption that not having any traced data
     * on a thread means that it is not of interest to the user.
     */
    buildPerThreadCpuSlicesFromCpuState: function() {
      // Push the cpu slices to the threads that they run on.
      for (var cpuNumber in this.cpuStates_) {
        var cpuState = this.cpuStates_[cpuNumber];
        var cpu = cpuState.cpu;

        for (var i = 0; i < cpu.slices.length; i++) {
          var slice = cpu.slices[i];

          var thread = this.threadsByLinuxPid[slice.args.tid];
          if (!thread)
            continue;
          if (!thread.tempCpuSlices)
            thread.tempCpuSlices = [];
          thread.tempCpuSlices.push(slice);
        }
      }

      for (var i in this.wakeups_) {
        var wakeup = this.wakeups_[i];
        var thread = this.threadsByLinuxPid[wakeup.tid];
        if (!thread)
          continue;
        thread.tempWakeups = thread.tempWakeups || [];
        thread.tempWakeups.push(wakeup);
      }

      // Create slices for when the thread is not running.
      var runningId = tracing.getColorIdByName('running');
      var runnableId = tracing.getColorIdByName('runnable');
      var sleepingId = tracing.getColorIdByName('sleeping');
      var ioWaitId = tracing.getColorIdByName('iowait');
      this.model_.getAllThreads().forEach(function(thread) {
        if (thread.tempCpuSlices === undefined)
          return;
        var origSlices = thread.tempCpuSlices;
        delete thread.tempCpuSlices;

        origSlices.sort(function(x, y) {
          return x.start - y.start;
        });

        var wakeups = thread.tempWakeups || [];
        delete thread.tempWakeups;
        wakeups.sort(function(x, y) {
          return x.ts - y.ts;
        });

        // Walk the slice list and put slices between each original slice
        // to show when the thread isn't running
        var slices = [];
        if (origSlices.length) {
          var slice = origSlices[0];
          slices.push(new tracing.model.Slice('', 'Running', runningId,
              slice.start, {}, slice.duration));
        }
        var wakeup = undefined;
        for (var i = 1; i < origSlices.length; i++) {
          var prevSlice = origSlices[i - 1];
          var nextSlice = origSlices[i];
          var midDuration = nextSlice.start - prevSlice.end;
          while (wakeups.length && wakeups[0].ts < nextSlice.start) {
            wakeup = wakeups.shift();
          }

          // Push a sleep slice onto the slices list, interrupting it with a
          // wakeup if appropriate.
          var pushSleep = function(title, id) {
            if (wakeup !== undefined) {
              midDuration = wakeup.ts - prevSlice.end;
            }
            slices.push(new tracing.model.Slice('', title, id, prevSlice.end,
              {}, midDuration));
            if (wakeup !== undefined) {
              var wakeupDuration = nextSlice.start - wakeup.ts;
              var args = {'wakeup from tid': wakeup.fromTid};
              slices.push(new tracing.model.Slice('', 'Runnable', runnableId,
                  wakeup.ts, args, wakeupDuration));
              wakeup = undefined;
            }
          }

          if (prevSlice.args.stateWhenDescheduled == 'S') {
            pushSleep('Sleeping', sleepingId);
          } else if (prevSlice.args.stateWhenDescheduled == 'R' ||
                     prevSlice.args.stateWhenDescheduled == 'R+') {
            slices.push(new tracing.model.Slice('', 'Runnable', runnableId,
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 'D') {
            pushSleep('Uninterruptible Sleep', ioWaitId);
          } else if (prevSlice.args.stateWhenDescheduled == 'T') {
            slices.push(new tracing.model.Slice('', '__TASK_STOPPED',
                ioWaitId, prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 't') {
            slices.push(new tracing.model.Slice('', 'debug', ioWaitId,
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 'Z') {
            slices.push(new tracing.model.Slice('', 'Zombie', ioWaitId,
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 'X') {
            slices.push(new tracing.model.Slice('', 'Exit Dead', ioWaitId,
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 'x') {
            slices.push(new tracing.model.Slice('', 'Task Dead', ioWaitId,
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 'W') {
            slices.push(new tracing.model.Slice('', 'WakeKill', ioWaitId,
                prevSlice.end, {}, midDuration));
          } else if (prevSlice.args.stateWhenDescheduled == 'D|W') {
            pushSleep('Uninterruptable Sleep | WakeKill', ioWaitId);
          } else {
            throw new Error('Unrecognized state: ') +
                prevSlice.args.stateWhenDescheduled;
          }

          slices.push(new tracing.model.Slice('', 'Running', runningId,
              nextSlice.start, {}, nextSlice.duration));
        }
        thread.cpuSlices = slices;
      });
    },

    /**
     * Walks the slices stored on this.cpuStates_ and adjusts their timestamps
     * based on any alignment metadata we discovered.
     */
    alignClocks: function(isSecondaryImport) {
      if (this.clockSyncRecords_.length == 0) {
        // If this is a secondary import, and no clock syncing records were
        // found, then abort the import. Otherwise, just skip clock alignment.
        if (!isSecondaryImport)
          return true;

        // Remove the newly imported CPU slices from the model.
        this.abortImport();
        return false;
      }

      // Shift all the slice times based on the sync record.
      var sync = this.clockSyncRecords_[0];
      // NB: parentTS of zero denotes no times-shift; this is
      // used when user and kernel event clocks are identical.
      if (sync.parentTS == 0 || sync.parentTS == sync.perfTS)
        return true;
      var timeShift = sync.parentTS - sync.perfTS;
      for (var cpuNumber in this.cpuStates_) {
        var cpuState = this.cpuStates_[cpuNumber];
        var cpu = cpuState.cpu;

        for (var i = 0; i < cpu.slices.length; i++) {
          var slice = cpu.slices[i];
          slice.start = slice.start + timeShift;
          slice.duration = slice.duration;
        }

        for (var counterName in cpu.counters) {
          var counter = cpu.counters[counterName];
          for (var sI = 0; sI < counter.timestamps.length; sI++)
            counter.timestamps[sI] = (counter.timestamps[sI] + timeShift);
        }
      }
      for (var kernelThreadName in this.kernelThreadStates_) {
        var kthread = this.kernelThreadStates_[kernelThreadName];
        var thread = kthread.thread;
        thread.shiftTimestampsForward(timeShift);
      }
      return true;
    },

    /**
     * Removes any data that has been added to the model because of an error
     * detected during the import.
     */
    abortImport: function() {
      if (this.pushedEventsToThreads)
        throw new Error('Cannot abort, have alrady pushedCpuDataToThreads.');

      for (var cpuNumber in this.cpuStates_)
        delete this.model_.cpus[cpuNumber];
      for (var kernelThreadName in this.kernelThreadStates_) {
        var kthread = this.kernelThreadStates_[kernelThreadName];
        var thread = kthread.thread;
        var process = thread.parent;
        delete process.threads[thread.tid];
        delete this.model_.processes[process.pid];
      }
      this.model_.importErrors.push(
          'Cannot import kernel trace without a clock sync.');
    },

    /**
     * Creates an instance of each registered linux perf event parser.
     * This allows the parsers to register handlers for the events they
     * understand.  We also register our own special handlers (for the
     * timestamp synchronization markers).
     */
    createParsers: function() {
      // Instantiate the parsers; this will register handlers for known events
      var parserConstructors =
          tracing.importer.linux_perf.Parser.getSubtypeConstructors();
      for (var i = 0; i < parserConstructors.length; ++i) {
        var parserConstructor = parserConstructors[i];
        this.parsers_.push(new parserConstructor(this));
      }

      this.registerEventHandler('tracing_mark_write:trace_event_clock_sync',
          LinuxPerfImporter.prototype.traceClockSyncEvent.bind(this));
      this.registerEventHandler('tracing_mark_write',
          LinuxPerfImporter.prototype.traceMarkingWriteEvent.bind(this));
      // NB: old-style trace markers; deprecated
      this.registerEventHandler('0:trace_event_clock_sync',
          LinuxPerfImporter.prototype.traceClockSyncEvent.bind(this));
      this.registerEventHandler('0',
          LinuxPerfImporter.prototype.traceMarkingWriteEvent.bind(this));
    },

    /**
     * Registers a linux perf event parser used by importCpuData.
     */
    registerEventHandler: function(eventName, handler) {
      // TODO(sleffler) how to handle conflicts?
      this.eventHandlers_[eventName] = handler;
    },

    /**
     * Records the fact that a pid has become runnable. This data will
     * eventually get used to derive each thread's cpuSlices array.
     */
    markPidRunnable: function(ts, pid, comm, prio, fromPid) {
      // The the pids that get passed in to this function are Linux kernel
      // pids, which identify threads.  The rest of trace-viewer refers to
      // these as tids, so the change of nomenclature happens in the following
      // construction of the wakeup object.
      this.wakeups_.push({ts: ts, tid: pid, fromTid: fromPid});
    },

    importError: function(message) {
      this.model_.importErrors.push(
        'Line ' + (this.lineNumberBase + this.lineNumber + 1) +
          ': ' + message);
    },

    /**
     * Processes a trace_event_clock_sync event.
     */
    traceClockSyncEvent: function(eventName, cpuNumber, pid, ts, eventBase) {
      var event = /parent_ts=(\d+\.?\d*)/.exec(eventBase.details);
      if (!event)
        return false;

      this.clockSyncRecords_.push({
        perfTS: ts,
        parentTS: event[1] * 1000
      });
      return true;
    },

    /**
     * Processes a trace_marking_write event.
     */
    traceMarkingWriteEvent: function(eventName, cpuNumber, pid, ts, eventBase,
                                     threadName) {
      var event = /^\s*(\w+):\s*(.*)$/.exec(eventBase.details);
      if (!event) {
        // Check if the event matches events traced by the Android framework
        var tag = eventBase.details.substring(0, 2);
        if (tag == 'B|' || tag == 'E' || tag == 'E|' || tag == 'C|') {
          eventBase.subEventName = 'android';
        } else {
          return false;
        }
      } else {
        eventBase.subEventName = event[1];
        eventBase.details = event[2];
      }

      var writeEventName = eventName + ':' + eventBase.subEventName;
      var handler = this.eventHandlers_[writeEventName];
      if (!handler) {
        this.importError('Unknown trace_marking_write event ' + writeEventName);
        return true;
      }
      return handler(writeEventName, cpuNumber, pid, ts, eventBase, threadName);
    },

    /**
     * Walks the this.events_ structure and creates Cpu objects.
     */
    importCpuData: function() {
      var extractResult = LinuxPerfImporter._extractEventsFromSystraceHTML(
        this.events_, true);
      if (extractResult.ok) {
        this.lineNumberBase = extractResult.events_begin_at_line;
        this.lines_ = extractResult.lines;
      } else {
        this.lineNumberBase = 0;
        this.lines_ = this.events_.split('\n');
      }

      var lineParser = null;
      for (this.lineNumber = 0;
           this.lineNumber < this.lines_.length;
          ++this.lineNumber) {
        var line = this.lines_[this.lineNumber];
        if (line.length == 0 || /^#/.test(line))
          continue;
        if (lineParser == null) {
          lineParser = autoDetectLineParser(line);
          if (lineParser == null) {
            this.importError('Cannot parse line: ' + line);
            continue;
          }
        }
        var eventBase = lineParser(line);
        if (!eventBase) {
          this.importError('Unrecognized line: ' + line);
          continue;
        }

        var pid = parseInt(eventBase.pid);
        var cpuNumber = parseInt(eventBase.cpuNumber);
        var ts = parseFloat(eventBase.timestamp) * 1000;
        var eventName = eventBase.eventName;

        var handler = this.eventHandlers_[eventName];
        if (!handler) {
          this.importError('Unknown event ' + eventName + ' (' + line + ')');
          continue;
        }
        if (!handler(eventName, cpuNumber, pid, ts, eventBase))
          this.importError('Malformed ' + eventName + ' event (' + line + ')');
      }
    }
  };

  tracing.Model.registerImporter(LinuxPerfImporter);

  return {
    LinuxPerfImporter: LinuxPerfImporter,
    _LinuxPerfImporterTestExports: TestExports
  };

});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview Log Reader is used to process log file produced by V8.
 */
base.exportTo('tracing.importer.v8', function() {
  /**
   * Creates a CSV lines parser.
   */
  function CsvParser() {
  };


  /**
   * A regex for matching a CSV field.
   * @private
   */
  CsvParser.CSV_FIELD_RE_ = /^"((?:[^"]|"")*)"|([^,]*)/;


  /**
   * A regex for matching a double quote.
   * @private
   */
  CsvParser.DOUBLE_QUOTE_RE_ = /""/g;


  /**
   * Parses a line of CSV-encoded values. Returns an array of fields.
   *
   * @param {string} line Input line.
   */
  CsvParser.prototype.parseLine = function(line) {
    var fieldRe = CsvParser.CSV_FIELD_RE_;
    var doubleQuoteRe = CsvParser.DOUBLE_QUOTE_RE_;
    var pos = 0;
    var endPos = line.length;
    var fields = [];
    if (endPos > 0) {
      do {
        var fieldMatch = fieldRe.exec(line.substr(pos));
        if (typeof fieldMatch[1] === 'string') {
          var field = fieldMatch[1];
          pos += field.length + 3;  // Skip comma and quotes.
          fields.push(field.replace(doubleQuoteRe, '"'));
        } else {
          // The second field pattern will match anything, thus
          // in the worst case the match will be an empty string.
          var field = fieldMatch[2];
          pos += field.length + 1;  // Skip comma.
          fields.push(field);
        }
      } while (pos <= endPos);
    }
    return fields;
  };

  /**
   * Base class for processing log files.
   *
   * @param {Array.<Object>} dispatchTable A table used for parsing and
   * processing log records.
   *
   * @constructor
   */
  function LogReader(dispatchTable) {
    /**
     * @type {Array.<Object>}
     */
    this.dispatchTable_ = dispatchTable;

    /**
     * Current line.
     * @type {number}
     */
    this.lineNum_ = 0;

    /**
     * CSV lines parser.
     * @type {CsvParser}
     */
    this.csvParser_ = new CsvParser();
  };


  /**
   * Used for printing error messages.
   *
   * @param {string} str Error message.
   */
  LogReader.prototype.printError = function(str) {
    // Do nothing.
  };


  /**
   * Processes a portion of V8 profiler event log.
   *
   * @param {string} chunk A portion of log.
   */
  LogReader.prototype.processLogChunk = function(chunk) {
    this.processLog_(chunk.split('\n'));
  };


  /**
   * Processes a line of V8 profiler event log.
   *
   * @param {string} line A line of log.
   */
  LogReader.prototype.processLogLine = function(line) {
    this.processLog_([line]);
  };


  /**
   * Processes stack record.
   *
   * @param {number} pc Program counter.
   * @param {number} func JS Function.
   * @param {Array.<string>} stack String representation of a stack.
   * @return {Array.<number>} Processed stack.
   */
  LogReader.prototype.processStack = function(pc, func, stack) {
    var fullStack = func ? [pc, func] : [pc];
    var prevFrame = pc;
    for (var i = 0, n = stack.length; i < n; ++i) {
      var frame = stack[i];
      var firstChar = frame.charAt(0);
      if (firstChar == '+' || firstChar == '-') {
        // An offset from the previous frame.
        prevFrame += parseInt(frame, 16);
        fullStack.push(prevFrame);
      // Filter out possible 'overflow' string.
      } else if (firstChar != 'o') {
        fullStack.push(parseInt(frame, 16));
      }
    }
    return fullStack;
  };


  /**
   * Returns whether a particular dispatch must be skipped.
   *
   * @param {!Object} dispatch Dispatch record.
   * @return {boolean} True if dispatch must be skipped.
   */
  LogReader.prototype.skipDispatch = function(dispatch) {
    return false;
  };


  /**
   * Does a dispatch of a log record.
   *
   * @param {Array.<string>} fields Log record.
   * @private
   */
  LogReader.prototype.dispatchLogRow_ = function(fields) {
    // Obtain the dispatch.
    var command = fields[0];
    if (!(command in this.dispatchTable_)) return;

    var dispatch = this.dispatchTable_[command];

    if (dispatch === null || this.skipDispatch(dispatch)) {
      return;
    }

    // Parse fields.
    var parsedFields = [];
    for (var i = 0; i < dispatch.parsers.length; ++i) {
      var parser = dispatch.parsers[i];
      if (parser === null) {
        parsedFields.push(fields[1 + i]);
      } else if (typeof parser == 'function') {
        parsedFields.push(parser(fields[1 + i]));
      } else {
        // var-args
        parsedFields.push(fields.slice(1 + i));
        break;
      }
    }

    // Run the processor.
    dispatch.processor.apply(this, parsedFields);
  };


  /**
   * Processes log lines.
   *
   * @param {Array.<string>} lines Log lines.
   * @private
   */
  LogReader.prototype.processLog_ = function(lines) {
    for (var i = 0, n = lines.length; i < n; ++i, ++this.lineNum_) {
      var line = lines[i];
      if (!line) {
        continue;
      }
      try {
        var fields = this.csvParser_.parseLine(line);
        this.dispatchLogRow_(fields);
      } catch (e) {
        this.printError('line ' + (this.lineNum_ + 1) + ': ' +
                        (e.message || e));
      }
    }
  };
  return {
    LogReader: LogReader
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.


/**
 * @fileoverview Splay tree used by CodeMap.
 */
base.exportTo('tracing.importer.v8', function() {
  /**
   * Constructs a Splay tree.  A splay tree is a self-balancing binary
   * search tree with the additional property that recently accessed
   * elements are quick to access again. It performs basic operations
   * such as insertion, look-up and removal in O(log(n)) amortized time.
   *
   * @constructor
   */
  function SplayTree() {
  };


  /**
   * Pointer to the root node of the tree.
   *
   * @type {SplayTree.Node}
   * @private
   */
  SplayTree.prototype.root_ = null;


  /**
   * @return {boolean} Whether the tree is empty.
   */
  SplayTree.prototype.isEmpty = function() {
    return !this.root_;
  };



  /**
   * Inserts a node into the tree with the specified key and value if
   * the tree does not already contain a node with the specified key. If
   * the value is inserted, it becomes the root of the tree.
   *
   * @param {number} key Key to insert into the tree.
   * @param {*} value Value to insert into the tree.
   */
  SplayTree.prototype.insert = function(key, value) {
    if (this.isEmpty()) {
      this.root_ = new SplayTree.Node(key, value);
      return;
    }
    // Splay on the key to move the last node on the search path for
    // the key to the root of the tree.
    this.splay_(key);
    if (this.root_.key == key) {
      return;
    }
    var node = new SplayTree.Node(key, value);
    if (key > this.root_.key) {
      node.left = this.root_;
      node.right = this.root_.right;
      this.root_.right = null;
    } else {
      node.right = this.root_;
      node.left = this.root_.left;
      this.root_.left = null;
    }
    this.root_ = node;
  };


  /**
   * Removes a node with the specified key from the tree if the tree
   * contains a node with this key. The removed node is returned. If the
   * key is not found, an exception is thrown.
   *
   * @param {number} key Key to find and remove from the tree.
   * @return {SplayTree.Node} The removed node.
   */
  SplayTree.prototype.remove = function(key) {
    if (this.isEmpty()) {
      throw Error('Key not found: ' + key);
    }
    this.splay_(key);
    if (this.root_.key != key) {
      throw Error('Key not found: ' + key);
    }
    var removed = this.root_;
    if (!this.root_.left) {
      this.root_ = this.root_.right;
    } else {
      var right = this.root_.right;
      this.root_ = this.root_.left;
      // Splay to make sure that the new root has an empty right child.
      this.splay_(key);
      // Insert the original right child as the right child of the new
      // root.
      this.root_.right = right;
    }
    return removed;
  };


  /**
   * Returns the node having the specified key or null if the tree doesn't
   * contain a node with the specified key.
   *
   *
   * @param {number} key Key to find in the tree.
   * @return {SplayTree.Node} Node having the specified key.
   */
  SplayTree.prototype.find = function(key) {
    if (this.isEmpty()) {
      return null;
    }
    this.splay_(key);
    return this.root_.key == key ? this.root_ : null;
  };


  /**
   * @return {SplayTree.Node} Node having the minimum key value.
   */
  SplayTree.prototype.findMin = function() {
    if (this.isEmpty()) {
      return null;
    }
    var current = this.root_;
    while (current.left) {
      current = current.left;
    }
    return current;
  };


  /**
   * @return {SplayTree.Node} Node having the maximum key value.
   */
  SplayTree.prototype.findMax = function(opt_startNode) {
    if (this.isEmpty()) {
      return null;
    }
    var current = opt_startNode || this.root_;
    while (current.right) {
      current = current.right;
    }
    return current;
  };


  /**
   * @return {SplayTree.Node} Node having the maximum key value that
   *     is less or equal to the specified key value.
   */
  SplayTree.prototype.findGreatestLessThan = function(key) {
    if (this.isEmpty()) {
      return null;
    }
    // Splay on the key to move the node with the given key or the last
    // node on the search path to the top of the tree.
    this.splay_(key);
    // Now the result is either the root node or the greatest node in
    // the left subtree.
    if (this.root_.key <= key) {
      return this.root_;
    } else if (this.root_.left) {
      return this.findMax(this.root_.left);
    } else {
      return null;
    }
  };


  /**
   * @return {Array<*>} An array containing all the values of tree's nodes
   * paired with keys.
   *
   */
  SplayTree.prototype.exportKeysAndValues = function() {
    var result = [];
    this.traverse_(function(node) { result.push([node.key, node.value]); });
    return result;
  };


  /**
   * @return {Array<*>} An array containing all the values of tree's nodes.
   */
  SplayTree.prototype.exportValues = function() {
    var result = [];
    this.traverse_(function(node) { result.push(node.value); });
    return result;
  };


  /**
   * Perform the splay operation for the given key. Moves the node with
   * the given key to the top of the tree.  If no node has the given
   * key, the last node on the search path is moved to the top of the
   * tree. This is the simplified top-down splaying algorithm from:
   * "Self-adjusting Binary Search Trees" by Sleator and Tarjan
   *
   * @param {number} key Key to splay the tree on.
   * @private
   */
  SplayTree.prototype.splay_ = function(key) {
    if (this.isEmpty()) {
      return;
    }
    // Create a dummy node.  The use of the dummy node is a bit
    // counter-intuitive: The right child of the dummy node will hold
    // the L tree of the algorithm.  The left child of the dummy node
    // will hold the R tree of the algorithm.  Using a dummy node, left
    // and right will always be nodes and we avoid special cases.
    var dummy, left, right;
    dummy = left = right = new SplayTree.Node(null, null);
    var current = this.root_;
    while (true) {
      if (key < current.key) {
        if (!current.left) {
          break;
        }
        if (key < current.left.key) {
          // Rotate right.
          var tmp = current.left;
          current.left = tmp.right;
          tmp.right = current;
          current = tmp;
          if (!current.left) {
            break;
          }
        }
        // Link right.
        right.left = current;
        right = current;
        current = current.left;
      } else if (key > current.key) {
        if (!current.right) {
          break;
        }
        if (key > current.right.key) {
          // Rotate left.
          var tmp = current.right;
          current.right = tmp.left;
          tmp.left = current;
          current = tmp;
          if (!current.right) {
            break;
          }
        }
        // Link left.
        left.right = current;
        left = current;
        current = current.right;
      } else {
        break;
      }
    }
    // Assemble.
    left.right = current.left;
    right.left = current.right;
    current.left = dummy.right;
    current.right = dummy.left;
    this.root_ = current;
  };


  /**
   * Performs a preorder traversal of the tree.
   *
   * @param {function(SplayTree.Node)} f Visitor function.
   * @private
   */
  SplayTree.prototype.traverse_ = function(f) {
    var nodesToVisit = [this.root_];
    while (nodesToVisit.length > 0) {
      var node = nodesToVisit.shift();
      if (node == null) {
        continue;
      }
      f(node);
      nodesToVisit.push(node.left);
      nodesToVisit.push(node.right);
    }
  };


  /**
   * Constructs a Splay tree node.
   *
   * @param {number} key Key.
   * @param {*} value Value.
   */
  SplayTree.Node = function(key, value) {
    this.key = key;
    this.value = value;
  };


  /**
   * @type {SplayTree.Node}
   */
  SplayTree.Node.prototype.left = null;


  /**
   * @type {SplayTree.Node}
   */
  SplayTree.Node.prototype.right = null;

  return {
    SplayTree: SplayTree
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

base.require('importer.v8.splaytree');

/**
 * @fileoverview Map addresses to dynamically created functions.
 */

base.exportTo('tracing.importer.v8', function() {
  /**
   * Constructs a mapper that maps addresses into code entries.
   *
   * @constructor
   */
  function CodeMap() {
    /**
     * Dynamic code entries. Used for JIT compiled code.
     */
    this.dynamics_ = new tracing.importer.v8.SplayTree();

    /**
     * Name generator for entries having duplicate names.
     */
    this.dynamicsNameGen_ = new tracing.importer.v8.CodeMap.NameGenerator();

    /**
     * Static code entries. Used for statically compiled code.
     */
    this.statics_ = new tracing.importer.v8.SplayTree();

    /**
     * Libraries entries. Used for the whole static code libraries.
     */
    this.libraries_ = new tracing.importer.v8.SplayTree();

    /**
     * Map of memory pages occupied with static code.
     */
    this.pages_ = [];
  };


  /**
   * The number of alignment bits in a page address.
   */
  CodeMap.PAGE_ALIGNMENT = 12;


  /**
   * Page size in bytes.
   */
  CodeMap.PAGE_SIZE =
      1 << CodeMap.PAGE_ALIGNMENT;


  /**
   * Adds a dynamic (i.e. moveable and discardable) code entry.
   *
   * @param {number} start The starting address.
   * @param {CodeMap.CodeEntry} codeEntry Code entry object.
   */
  CodeMap.prototype.addCode = function(start, codeEntry) {
    this.deleteAllCoveredNodes_(this.dynamics_, start, start + codeEntry.size);
    this.dynamics_.insert(start, codeEntry);
  };


  /**
   * Moves a dynamic code entry. Throws an exception if there is no dynamic
   * code entry with the specified starting address.
   *
   * @param {number} from The starting address of the entry being moved.
   * @param {number} to The destination address.
   */
  CodeMap.prototype.moveCode = function(from, to) {
    var removedNode = this.dynamics_.remove(from);
    this.deleteAllCoveredNodes_(this.dynamics_, to,
                                to + removedNode.value.size);
    this.dynamics_.insert(to, removedNode.value);
  };


  /**
   * Discards a dynamic code entry. Throws an exception if there is no dynamic
   * code entry with the specified starting address.
   *
   * @param {number} start The starting address of the entry being deleted.
   */
  CodeMap.prototype.deleteCode = function(start) {
    var removedNode = this.dynamics_.remove(start);
  };


  /**
   * Adds a library entry.
   *
   * @param {number} start The starting address.
   * @param {CodeMap.CodeEntry} codeEntry Code entry object.
   */
  CodeMap.prototype.addLibrary = function(
      start, codeEntry) {
    this.markPages_(start, start + codeEntry.size);
    this.libraries_.insert(start, codeEntry);
  };


  /**
   * Adds a static code entry.
   *
   * @param {number} start The starting address.
   * @param {CodeMap.CodeEntry} codeEntry Code entry object.
   */
  CodeMap.prototype.addStaticCode = function(
      start, codeEntry) {
    this.statics_.insert(start, codeEntry);
  };


  /**
   * @private
   */
  CodeMap.prototype.markPages_ = function(start, end) {
    for (var addr = start; addr <= end;
         addr += CodeMap.PAGE_SIZE) {
      this.pages_[addr >>> CodeMap.PAGE_ALIGNMENT] = 1;
    }
  };


  /**
   * @private
   */
  CodeMap.prototype.deleteAllCoveredNodes_ = function(tree, start, end) {
    var to_delete = [];
    var addr = end - 1;
    while (addr >= start) {
      var node = tree.findGreatestLessThan(addr);
      if (!node) break;
      var start2 = node.key, end2 = start2 + node.value.size;
      if (start2 < end && start < end2) to_delete.push(start2);
      addr = start2 - 1;
    }
    for (var i = 0, l = to_delete.length; i < l; ++i) tree.remove(to_delete[i]);
  };


  /**
   * @private
   */
  CodeMap.prototype.isAddressBelongsTo_ = function(addr, node) {
    return addr >= node.key && addr < (node.key + node.value.size);
  };


  /**
   * @private
   */
  CodeMap.prototype.findInTree_ = function(tree, addr) {
    var node = tree.findGreatestLessThan(addr);
    return node && this.isAddressBelongsTo_(addr, node) ? node.value : null;
  };


  /**
   * Finds a code entry that contains the specified address. Both static and
   * dynamic code entries are considered.
   *
   * @param {number} addr Address.
   */
  CodeMap.prototype.findEntry = function(addr) {
    var pageAddr = addr >>> CodeMap.PAGE_ALIGNMENT;
    if (pageAddr in this.pages_) {
      // Static code entries can contain "holes" of unnamed code.
      // In this case, the whole library is assigned to this address.
      return this.findInTree_(this.statics_, addr) ||
          this.findInTree_(this.libraries_, addr);
    }
    var min = this.dynamics_.findMin();
    var max = this.dynamics_.findMax();
    if (max != null && addr < (max.key + max.value.size) && addr >= min.key) {
      var dynaEntry = this.findInTree_(this.dynamics_, addr);
      if (dynaEntry == null) return null;
      // Dedupe entry name.
      if (!dynaEntry.nameUpdated_) {
        dynaEntry.name = this.dynamicsNameGen_.getName(dynaEntry.name);
        dynaEntry.nameUpdated_ = true;
      }
      return dynaEntry;
    }
    return null;
  };


  /**
   * Returns a dynamic code entry using its starting address.
   *
   * @param {number} addr Address.
   */
  CodeMap.prototype.findDynamicEntryByStartAddress =
      function(addr) {
    var node = this.dynamics_.find(addr);
    return node ? node.value : null;
  };


  /**
   * Returns an array of all dynamic code entries.
   */
  CodeMap.prototype.getAllDynamicEntries = function() {
    return this.dynamics_.exportValues();
  };


  /**
   * Returns an array of pairs of all dynamic code entries and their addresses.
   */
  CodeMap.prototype.getAllDynamicEntriesWithAddresses = function() {
    return this.dynamics_.exportKeysAndValues();
  };


  /**
   * Returns an array of all static code entries.
   */
  CodeMap.prototype.getAllStaticEntries = function() {
    return this.statics_.exportValues();
  };


  /**
   * Returns an array of all libraries entries.
   */
  CodeMap.prototype.getAllLibrariesEntries = function() {
    return this.libraries_.exportValues();
  };


  /**
   * Creates a code entry object.
   *
   * @param {number} size Code entry size in bytes.
   * @param {string} opt_name Code entry name.
   * @constructor
   */
  CodeMap.CodeEntry = function(size, opt_name) {
    this.size = size;
    this.name = opt_name || '';
    this.nameUpdated_ = false;
  };


  CodeMap.CodeEntry.prototype.getName = function() {
    return this.name;
  };


  CodeMap.CodeEntry.prototype.toString = function() {
    return this.name + ': ' + this.size.toString(16);
  };


  CodeMap.NameGenerator = function() {
    this.knownNames_ = {};
  };


  CodeMap.NameGenerator.prototype.getName = function(name) {
    if (!(name in this.knownNames_)) {
      this.knownNames_[name] = 0;
      return name;
    }
    var count = ++this.knownNames_[name];
    return name + ' {' + count + '}';
  };
  return {
    CodeMap: CodeMap
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

/**
 * @fileoverview V8LogImporter imports v8.log files into the provided model.
 */
base.require('model');
base.require('model.slice');
base.require('color_scheme');
base.require('importer.v8.log_reader');
base.require('importer.v8.codemap');
base.exportTo('tracing.importer', function() {

  function V8LogImporter(model, eventData) {

    this.importPriority = 3;
    this.model_ = model;

    this.logData_ = eventData;

    this.code_map_ = new tracing.importer.v8.CodeMap();
    this.v8_timer_thread_ = undefined;
    this.v8_stack_thread_ = undefined;
    this.v8_samples_thread_ = undefined;
  }

  var kV8BinarySuffixes = ['/d8', '/libv8.so'];
  var kStackFrames = 8;

  var TimerEventDefaultArgs = {
    'V8.Execute': { pause: false, no_execution: false},
    'V8.External': { pause: false, no_execution: true},
    'V8.CompileFullCode': { pause: true, no_execution: true},
    'V8.RecompileSynchronous': { pause: true, no_execution: true},
    'V8.RecompileParallel': { pause: false, no_execution: false},
    'V8.CompileEval': { pause: true, no_execution: true},
    'V8.Parse': { pause: true, no_execution: true},
    'V8.PreParse': { pause: true, no_execution: true},
    'V8.ParseLazy': { pause: true, no_execution: true},
    'V8.GCScavenger': { pause: true, no_execution: true},
    'V8.GCCompactor': { pause: true, no_execution: true},
    'V8.GCContext': { pause: true, no_execution: true},
  };

  /**
   * @return {boolean} Whether obj is a V8 log string.
   */
  V8LogImporter.canImport = function(eventData) {
    if (typeof(eventData) !== 'string' && !(eventData instanceof String))
      return false;

    return eventData.substring(0, 12) == 'timer-event,' ||
           eventData.substring(0, 5) == 'tick,' ||
           eventData.substring(0, 15) == 'shared-library,' ||
           eventData.substring(0, 9) == 'profiler,';
  };

  V8LogImporter.prototype = {

    __proto__: Object.prototype,

    processTimerEvent_: function(name, start, length) {
      var args = TimerEventDefaultArgs[name];
      if (args === undefined) return;
      start /= 1000;  // Convert to milliseconds.
      length /= 1000;
      var colorId = tracing.getStringColorId(name);
      var slice = new tracing.model.Slice('v8', name, colorId, start,
                                          args, length);
      this.v8_timer_thread_.pushSlice(slice);
    },

    processTimerEventStart_: function(name, start) {
      debugger;
      var args = TimerEventDefaultArgs[name];
      if (args === undefined) return;
      start /= 1000;  // Convert to milliseconds.
      this.v8_timer_thread_.beginSlice('v8', name, start, args);
    },

    processTimerEventEnd_: function(name, end) {
      debugger;
      end /= 1000;  // Convert to milliseconds.
      this.v8_timer_thread_.endSlice(end);
    },

    processCodeCreateEvent_: function(type, kind, address, size, name) {
      var code_entry = new tracing.importer.v8.CodeMap.CodeEntry(size, name);
      code_entry.kind = kind;
      this.code_map_.addCode(address, code_entry);
    },

    processCodeMoveEvent_: function(from, to) {
      this.code_map_.moveCode(from, to);
    },

    processCodeDeleteEvent_: function(address) {
      this.code_map_.deleteCode(address);
    },

    processSharedLibrary_: function(name, start, end) {
      var code_entry = new tracing.importer.v8.CodeMap.CodeEntry(
          end - start, name);
      code_entry.kind = -3;  // External code kind.
      for (var i = 0; i < kV8BinarySuffixes.length; i++) {
        var suffix = kV8BinarySuffixes[i];
        if (name.indexOf(suffix, name.length - suffix.length) >= 0) {
          code_entry.kind = -1;  // V8 runtime code kind.
          break;
        }
      }
      this.code_map_.addLibrary(start, code_entry);
    },

    findCodeKind_: function(kind) {
      for (name in CodeKinds) {
        if (CodeKinds[name].kinds.indexOf(kind) >= 0) {
          return CodeKinds[name];
        }
      }
    },

    nameForCodeEntry_: function(entry) {
      if (entry)
        return entry.name;
      return 'UnknownCode';
    },

    processTickEvent_: function(pc, sp, start, unused_x, unused_y, vmstate,
                                stack) {
      var entry = this.code_map_.findEntry(pc);
      var name = this.nameForCodeEntry_(entry);
      start /= 1000;
      this.v8_samples_thread_.addSample('v8', name, start);
      if (stack && stack.length) {
        for (var i = 0; i < 8; i++) {
          if (!stack[i]) break;
          entry = this.code_map_.findEntry(stack[i]);
          name = this.nameForCodeEntry_(entry);
          var colorId = tracing.getStringColorId(name);
          var slice = new tracing.model.Slice('v8', name, colorId, start,
                                              {}, 0);
          this.v8_stack_thread_.pushSlice(slice);
        }
      }
    },

    processDistortion_: function(distortion_in_picoseconds) {
      distortion_per_entry = distortion_in_picoseconds / 1000000;
    },

    processPlotRange_: function(start, end) {
      xrange_start_override = start;
      xrange_end_override = end;
    },

    /**
     * Walks through the events_ list and outputs the structures discovered to
     * model_.
     */
    importEvents: function() {
      var logreader = new tracing.importer.v8.LogReader(
        { 'timer-event' : {
            parsers: [null, parseInt, parseInt],
            processor: this.processTimerEvent_.bind(this)
          },
          'shared-library': {
            parsers: [null, parseInt, parseInt],
            processor: this.processSharedLibrary_.bind(this)
          },
          'timer-event-start' : {
            parsers: [null, parseInt],
            processor: this.processTimerEventStart_.bind(this)
          },
          'timer-event-end' : {
            parsers: [null, parseInt],
            processor: this.processTimerEventEnd_.bind(this)
          },
          'code-creation': {
            parsers: [null, parseInt, parseInt, parseInt, null],
            processor: this.processCodeCreateEvent_.bind(this)
          },
          'code-move': {
            parsers: [parseInt, parseInt],
            processor: this.processCodeMoveEvent_.bind(this)
          },
          'code-delete': {
            parsers: [parseInt],
            processor: this.processCodeDeleteEvent_.bind(this)
          },
          'tick': {
            parsers: [parseInt, parseInt, parseInt, null, null, parseInt,
                      'var-args'],
            processor: this.processTickEvent_.bind(this)
          },
          'distortion': {
            parsers: [parseInt],
            processor: this.processDistortion_.bind(this)
          },
          'plot-range': {
            parsers: [parseInt, parseInt],
            processor: this.processPlotRange_.bind(this)
          },
        });

      this.v8_timer_thread_ =
        this.model_.getOrCreateProcess(-32).getOrCreateThread(1);
      this.v8_timer_thread_.name = 'V8 Timers';
      this.v8_stack_thread_ =
        this.model_.getOrCreateProcess(-32).getOrCreateThread(2);
      this.v8_stack_thread_.name = 'V8 JavaScript';
      this.v8_samples_thread_ =
        this.model_.getOrCreateProcess(-32).getOrCreateThread(3);
      this.v8_samples_thread_.name = 'V8 PC';

      var lines = this.logData_.split('\n');
      for (var i = 0; i < lines.length; i++) {
        logreader.processLogLine(lines[i]);
      }
    },

    /**
     * Called by the Model after all other importers have imported their
     * events.
     */
    finalizeImport: function() {
    },
  };

  tracing.Model.registerImporter(V8LogImporter);

  return {
    V8LogImporter: V8LogImporter
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview Provides the Settings class.
 */
base.exportTo('base', function() {
  var alternativeStorageInstance = undefined;

  /**
   * Settings is a simple wrapper around local storage, to make it easier
   * to test classes that have settings.
   *
   * @constructor
   */
  function Settings() {
    if (alternativeStorageInstance) {
      this.storage_ = alternativeStorageInstance;
    } else if ('G_testRunner' in global) {
      /**
       * In unit tests, use a mock object for storage so we don't change
       * localStorage in tests.
       */
      this.storage_ = new FakeLocalStorage();
    } else {
      this.storage_ = localStorage;
    }
  }

  Settings.setAlternativeStorageInstance = function(instance) {
    alternativeStorageInstance = instance;
  }

  Settings.prototype = {

    /**
     * Get the setting with the given name.
     *
     * @param {string} key The name of the setting.
     * @param {string} opt_default The default value to return if not set.
     * @param {string} opt_namespace If set, the setting name will be prefixed
     * with this namespace, e.g. "categories.settingName". This is useful for
     * a set of related settings.
     */
    get: function(key, opt_default, opt_namespace) {
      key = this.namespace_(key, opt_namespace);
      var val = this.storage_.getItem(key);
      if (val === null || val === undefined)
        return opt_default;
      return String(val);
    },

    /**
     * Set the setting with the given name to the given value.
     *
     * @param {string} key The name of the setting.
     * @param {string} value The value of the setting.
     * @param {string} opt_namespace If set, the setting name will be prefixed
     * with this namespace, e.g. "categories.settingName". This is useful for
     * a set of related settings.
     */
    set: function(key, value, opt_namespace) {
      this.storage_.setItem(this.namespace_(key, opt_namespace), String(value));
    },

    /**
     * Return a list of all the keys, or all the keys in the given namespace
     * if one is provided.
     *
     * @param {string} opt_namespace If set, only return settings which
     * begin with this prefix.
     */
    keys: function(opt_namespace) {
      var result = [];
      opt_namespace = opt_namespace || '';
      for (var i = 0; i < this.storage_.length; i++) {
        var key = this.storage_.key(i);
        if (this.isnamespaced_(key, opt_namespace))
          result.push(this.unnamespace_(key, opt_namespace));
      }
      return result;
    },

    isnamespaced_: function(key, opt_namespace) {
      return key.indexOf(this.normalize_(opt_namespace)) == 0;
    },

    namespace_: function(key, opt_namespace) {
      return this.normalize_(opt_namespace) + key;
    },

    unnamespace_: function(key, opt_namespace) {
      return key.replace(this.normalize_(opt_namespace), '');
    },

    /**
     * All settings are prefixed with a global namespace to avoid collisions.
     * Settings may also be namespaced with an additional prefix passed into
     * the get, set, and keys methods in order to group related settings.
     * This method makes sure the two namespaces are always set properly.
     */
    normalize_: function(opt_namespace) {
      return Settings.NAMESPACE + (opt_namespace ? opt_namespace + '.' : '');
    }
  };

  Settings.NAMESPACE = 'trace-viewer';

  /**
   * Create a Fake localStorage object which just stores to a dictionary
   * instead of actually saving into localStorage. Only used in unit tests.
   * @constructor
   */
  function FakeLocalStorage() {
  }

  FakeLocalStorage.prototype = {
    __proto__: Object.prototype,

    getItem: function(key) {
      // LocalStorage returns null if the key isn't found, not undefined.
      if (this[key] === undefined || this[key] === null)
        return null;
      return this[key];
    },

    setItem: function(key, value) {
      this[key] = value;
    },

    key: function(i) {
      return Object.keys(this).sort()[i];
    },
    get length() {
      return Object.keys(this).length;
    }
  };

  return {
    Settings: Settings
  };
});

// Copyright (c) 2012 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

'use strict';

/**
 * @fileoverview View visualizes TRACE_EVENT events using the
 * tracing.Timeline component and adds in selection summary and control buttons.
 */
base.requireStylesheet('timeline_view');

base.require('timeline_track_view');
base.require('timeline_analysis_view');
base.require('category_filter_dialog');
base.require('filter');
base.require('find_control');
base.require('overlay');
base.require('importer.trace_event_importer');
base.require('importer.linux_perf_importer');
base.require('importer.v8_log_importer');
base.require('settings');

base.exportTo('tracing', function() {

  /**
   * View
   * @constructor
   * @extends {HTMLDivElement}
   */
  var TimelineView = tracing.ui.define('div');

  TimelineView.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate: function() {
      this.classList.add('view');

      // Create individual elements.
      this.titleEl_ = document.createElement('div');
      this.titleEl_.textContent = 'Tracing: ';
      this.titleEl_.className = 'title';

      this.controlDiv_ = document.createElement('div');
      this.controlDiv_.className = 'control';

      this.leftControlsEl_ = document.createElement('div');
      this.leftControlsEl_.className = 'controls';
      this.rightControlsEl_ = document.createElement('div');
      this.rightControlsEl_.className = 'controls';

      var spacingEl = document.createElement('div');
      spacingEl.className = 'spacer';

      this.timelineContainer_ = document.createElement('div');
      this.timelineContainer_.className = 'container';

      var analysisContainer_ = document.createElement('div');
      analysisContainer_.className = 'analysis-container';

      this.analysisEl_ = new tracing.TimelineAnalysisView();

      this.dragEl_ = new DragHandle();
      this.dragEl_.target = analysisContainer_;

      this.findCtl_ = new tracing.FindControl();
      this.findCtl_.controller = new tracing.FindController();

      this.importErrorsButton_ = this.createImportErrorsButton_();
      this.categoryFilterButton_ = this.createCategoryFilterButton_();
      this.categoryFilterButton_.callback =
          this.updateCategoryFilterFromSettings_.bind(this);
      this.metadataButton_ = this.createMetadataButton_();

      // Connect everything up.
      this.rightControls.appendChild(this.importErrorsButton_);
      this.rightControls.appendChild(this.categoryFilterButton_);
      this.rightControls.appendChild(this.metadataButton_);
      this.rightControls.appendChild(this.findCtl_);
      this.controlDiv_.appendChild(this.titleEl_);
      this.controlDiv_.appendChild(this.leftControlsEl_);
      this.controlDiv_.appendChild(spacingEl);
      this.controlDiv_.appendChild(this.rightControlsEl_);
      this.appendChild(this.controlDiv_);

      this.appendChild(this.timelineContainer_);
      this.appendChild(this.dragEl_);

      analysisContainer_.appendChild(this.analysisEl_);
      this.appendChild(analysisContainer_);

      this.rightControls.appendChild(this.createHelpButton_());

      // Bookkeeping.
      this.onSelectionChangedBoundToThis_ = this.onSelectionChanged_.bind(this);
      document.addEventListener('keypress', this.onKeypress_.bind(this), true);
    },

    createImportErrorsButton_: function() {
      var dlg = new tracing.ui.Overlay();
      dlg.classList.add('view-import-errors-overlay');
      dlg.autoClose = true;

      var showEl = document.createElement('div');
      showEl.className = 'button view-import-errors-button view-info-button';
      showEl.textContent = 'Import errors!';

      var textEl = document.createElement('div');
      textEl.className = 'info-button-text import-errors-dialog-text';

      var containerEl = document.createElement('div');
      containerEl.className = 'info-button-container' +
          'import-errors-dialog';

      containerEl.textContent = 'Errors occurred during import:';
      containerEl.appendChild(textEl);
      dlg.appendChild(containerEl);

      var that = this;
      function onClick() {
        dlg.visible = true;
        textEl.textContent = that.model.importErrors.join('\n');
      }
      showEl.addEventListener('click', onClick.bind(this));

      function updateVisibility() {
        if (that.model &&
            that.model.importErrors.length)
          showEl.style.display = '';
        else
          showEl.style.display = 'none';
      }
      updateVisibility();
      that.addEventListener('modelChange', updateVisibility);

      return showEl;
    },

    createCategoryFilterButton_: function() {
      // Set by the embedder of the help button that we create in this function.
      var callback;

      var showEl = document.createElement('div');
      showEl.className = 'button view-info-button';
      showEl.textContent = 'Categories';
      showEl.__defineSetter__('callback', function(value) {
        callback = value;
      });


      var that = this;
      function onClick() {
        var dlg = new tracing.CategoryFilterDialog();
        dlg.categories = that.model.categories;
        dlg.settings = that.settings;
        dlg.settings_key = 'categories';
        dlg.settingUpdatedCallback = callback;
        dlg.visible = true;
      }

      function updateVisibility() {
        if (that.model)
          showEl.style.display = '';
        else
          showEl.style.display = 'none';
      }
      updateVisibility();
      that.addEventListener('modelChange', updateVisibility);

      showEl.addEventListener('click', onClick.bind(this));
      return showEl;
    },

    createHelpButton_: function() {
      var dlg = new tracing.ui.Overlay();
      dlg.classList.add('view-help-overlay');
      dlg.autoClose = true;
      dlg.additionalCloseKeyCodes.push('?'.charCodeAt(0));

      var showEl = document.createElement('div');
      showEl.className = 'button view-help-button';
      showEl.textContent = '?';

      var helpTextEl = document.createElement('div');
      helpTextEl.style.whiteSpace = 'pre';
      helpTextEl.style.fontFamily = 'monospace';
      dlg.appendChild(helpTextEl);

      function onClick(e) {
        dlg.visible = true;
        if (this.timeline_)
          helpTextEl.textContent = this.timeline_.keyHelp;
        else
          helpTextEl.textContent = 'No content loaded. For interesting help,' +
              ' load something.';

        // Stop event so it doesn't trigger new click listener on document.
        e.stopPropagation();
        return false;
      }

      showEl.addEventListener('click', onClick.bind(this));

      return showEl;
    },

    createMetadataButton_: function() {
      var dlg = new tracing.ui.Overlay();
      dlg.classList.add('view-metadata-overlay');
      dlg.autoClose = true;

      var showEl = document.createElement('div');
      showEl.className = 'button view-metadata-button view-info-button';
      showEl.textContent = 'Metadata';

      var textEl = document.createElement('div');
      textEl.className = 'info-button-text metadata-dialog-text';

      var containerEl = document.createElement('div');
      containerEl.className = 'info-button-container metadata-dialog';

      containerEl.textContent = 'Metadata Info:';
      containerEl.appendChild(textEl);
      dlg.appendChild(containerEl);

      var that = this;
      function onClick() {
        dlg.visible = true;

        var metadataStrings = [];

        var model = that.model;
        for (var data in model.metadata) {
          metadataStrings.push(JSON.stringify(model.metadata[data].name) +
                               ': ' + JSON.stringify(model.metadata[data].value, undefined, ' '));
        }
        textEl.textContent = metadataStrings.join('\n');
      }
      showEl.addEventListener('click', onClick.bind(this));

      function updateVisibility() {
        if (that.model &&
            that.model.metadata.length)
          showEl.style.display = '';
        else
          showEl.style.display = 'none';
      }
      updateVisibility();
      that.addEventListener('modelChange', updateVisibility);

      return showEl;
    },

    get leftControls() {
      return this.leftControlsEl_;
    },

    get rightControls() {
      return this.rightControlsEl_;
    },

    get title() {
      return this.titleEl_.textContent.substring(
          this.titleEl_.textContent.length - 2);
    },

    set title(text) {
      this.titleEl_.textContent = text + ':';
    },

    set traceData(traceData) {
      this.model = new tracing.Model(traceData);
    },

    get model() {
      if (this.timeline_)
        return this.timeline_.model;
      return undefined;
    },

    set model(model) {
      var modelInstanceChanged = model != this.model;
      var modelValid = model && !model.bounds.isEmpty;

      // Remove old timeline if the model has completely changed.
      if (modelInstanceChanged) {
        this.timelineContainer_.textContent = '';
        if (this.timeline_) {
          this.timeline_.removeEventListener(
              'selectionChange', this.onSelectionChangedBoundToThis_);
          this.timeline_.detach();
          this.timeline_ = undefined;
          this.findCtl_.controller.timeline = undefined;
        }
      }

      // Create new timeline if needed.
      if (modelValid && !this.timeline_) {
        this.timeline_ = new tracing.TimelineTrackView();
        this.timeline_.focusElement =
            this.focusElement_ ? this.focusElement_ : this.parentElement;
        this.timelineContainer_.appendChild(this.timeline_);
        this.findCtl_.controller.timeline = this.timeline_;
        this.timeline_.addEventListener(
            'selectionChange', this.onSelectionChangedBoundToThis_);
        this.updateCategoryFilterFromSettings_();
      }

      // Set the model.
      if (modelValid)
        this.timeline_.model = model;
      base.dispatchSimpleEvent(this, 'modelChange');

      // Do things that are selection specific
      if (modelInstanceChanged)
        this.onSelectionChanged_();
    },

    get timeline() {
      return this.timeline_;
    },

    get settings() {
      if (!this.settings_)
        this.settings_ = new base.Settings();
      return this.settings_;
    },

    /**
     * Sets the element whose focus state will determine whether
     * to respond to keybaord input.
     */
    set focusElement(value) {
      this.focusElement_ = value;
      if (this.timeline_)
        this.timeline_.focusElement = value;
    },

    /**
     * @return {Element} The element whose focused state determines
     * whether to respond to keyboard inputs.
     * Defaults to the parent element.
     */
    get focusElement() {
      if (this.focusElement_)
        return this.focusElement_;
      return this.parentElement;
    },

    /**
     * @return {boolean} Whether the current timeline is attached to the
     * document.
     */
    get isAttachedToDocument_() {
      var cur = this;
      while (cur.parentNode)
        cur = cur.parentNode;
      return cur == this.ownerDocument;
    },

    get listenToKeys_() {
      if (!this.isAttachedToDocument_)
        return;
      if (!this.focusElement_)
        return true;
      if (this.focusElement.tabIndex >= 0)
        return document.activeElement == this.focusElement;
      return true;
    },

    onKeypress_: function(e) {
      if (!this.listenToKeys_)
        return;

      if (event.keyCode == '/'.charCodeAt(0)) { // / key
        this.findCtl_.focus();
        event.preventDefault();
        return;
      } else if (e.keyCode == '?'.charCodeAt(0)) {
        this.querySelector('.view-help-button').click();
        e.preventDefault();
      }
    },

    beginFind: function() {
      if (this.findInProgress_)
        return;
      this.findInProgress_ = true;
      var dlg = tracing.FindControl();
      dlg.controller = new tracing.FindController();
      dlg.controller.timeline = this.timeline;
      dlg.visible = true;
      dlg.addEventListener('close', function() {
        this.findInProgress_ = false;
      }.bind(this));
      dlg.addEventListener('findNext', function() {
      });
      dlg.addEventListener('findPrevious', function() {
      });
    },

    onSelectionChanged_: function(e) {
      var oldScrollTop = this.timelineContainer_.scrollTop;

      var selection = this.timeline_ ?
          this.timeline_.selection :
          new tracing.Selection();
      this.analysisEl_.selection = selection;
      this.timelineContainer_.scrollTop = oldScrollTop;
    },

    updateCategoryFilterFromSettings_: function() {
      if (!this.timeline_)
        return;

      // Get the disabled categories from settings.
      var categories = this.settings.keys('categories');
      var disabledCategories = [];
      for (var i = 0; i < categories.length; i++) {
        if (this.settings.get(categories[i], 'true', 'categories') == 'false')
          disabledCategories.push(categories[i]);
      }

      this.timeline_.categoryFilter =
          new tracing.CategoryFilter(disabledCategories);
    }
  };

  /**
   * Timeline Drag Handle
   * Detects when user clicks handle determines new height of container based
   * on user's vertical mouse move and resizes the target.
   * @constructor
   * @extends {HTMLDivElement}
   * You will need to set target to be the draggable element
   */
  var DragHandle = tracing.ui.define('div');

  DragHandle.prototype = {
    __proto__: HTMLDivElement.prototype,

    decorate: function() {
      this.className = 'drag-handle';
      this.lastMousePosY = 0;
      this.dragAnalysis = this.dragAnalysis.bind(this);
      this.onMouseUp = this.onMouseUp.bind(this);
      this.addEventListener('mousedown', this.onMouseDown);
    },

    dragAnalysis: function(e) {
      // Compute the difference in height position.
      var dy = this.lastMousePosY - e.clientY;
      // If style is not set, start off with computed height.
      if (!this.target.style.height)
        this.target.style.height = window.getComputedStyle(this.target).height;
      // Calculate new height of the container.
      this.target.style.height = parseInt(this.target.style.height) + dy + 'px';
      this.lastMousePosY = e.clientY;
    },

    onMouseDown: function(e) {
      this.lastMousePosY = e.clientY;
      document.addEventListener('mousemove', this.dragAnalysis);
      document.addEventListener('mouseup', this.onMouseUp);
      e.stopPropagation();
      return false;
    },

    onMouseUp: function(e) {
      document.removeEventListener('mousemove', this.dragAnalysis);
      document.removeEventListener('mouseup', this.onMouseUp);
    }
  };

  return {
    TimelineView: TimelineView
  };
});

